<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>浅谈C语言的大整数库实现 | LightCloveyou's Blog</title><meta name="author" content="LightCloveyou"><meta name="copyright" content="LightCloveyou"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言 记录一手程序设计的实验作业，所使用的算法都是一些普通的算法，时间原因来不及做出太好的，只是稍微对几点想法说一下 函数体系及实现 核心是我们的头文件 #ifndef WLC_BN_H#define WLC_BN_H#include &quot;wlc_types.h&quot;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;tim">
<meta property="og:type" content="article">
<meta property="og:title" content="浅谈C语言的大整数库实现">
<meta property="og:url" content="https://lightcloveyou.github.io/2025/12/21/%E6%B5%85%E8%B0%88C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A4%A7%E6%95%B4%E6%95%B0%E5%BA%93%E5%AE%9E%E7%8E%B0/index.html">
<meta property="og:site_name" content="LightCloveyou&#39;s Blog">
<meta property="og:description" content="前言 记录一手程序设计的实验作业，所使用的算法都是一些普通的算法，时间原因来不及做出太好的，只是稍微对几点想法说一下 函数体系及实现 核心是我们的头文件 #ifndef WLC_BN_H#define WLC_BN_H#include &quot;wlc_types.h&quot;#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;tim">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lightcloveyou.github.io/img/47.jpg">
<meta property="article:published_time" content="2025-12-21T12:21:07.000Z">
<meta property="article:modified_time" content="2025-12-28T12:15:21.971Z">
<meta property="article:author" content="LightCloveyou">
<meta property="article:tag" content="Programming Language">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lightcloveyou.github.io/img/47.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "浅谈C语言的大整数库实现",
  "url": "https://lightcloveyou.github.io/2025/12/21/%E6%B5%85%E8%B0%88C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A4%A7%E6%95%B4%E6%95%B0%E5%BA%93%E5%AE%9E%E7%8E%B0/",
  "image": "https://lightcloveyou.github.io/img/47.jpg",
  "datePublished": "2025-12-21T12:21:07.000Z",
  "dateModified": "2025-12-28T12:15:21.971Z",
  "author": [
    {
      "@type": "Person",
      "name": "LightCloveyou",
      "url": "https://LightCloveyou.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="https://lightcloveyou.github.io/2025/12/21/%E6%B5%85%E8%B0%88C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A4%A7%E6%95%B4%E6%95%B0%E5%BA%93%E5%AE%9E%E7%8E%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.4/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!true && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":1000,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '浅谈C语言的大整数库实现',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;500&display=swap"><link rel="stylesheet" href="https://fontsapi.zeoseven.com/442/main/result.css"><meta name="generator" content="Hexo 8.0.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/47.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">LightCloveyou's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">浅谈C语言的大整数库实现</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">浅谈C语言的大整数库实现</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-21T12:21:07.000Z" title="发表于 2025-12-21 20:21:07">2025-12-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-28T12:15:21.971Z" title="更新于 2025-12-28 20:15:21">2025-12-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Knowledge/">Knowledge</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">8.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>48分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h3 id="前言">前言</h3>
<p>记录一手程序设计的实验作业，所使用的算法都是一些普通的算法，时间原因来不及做出太好的，只是稍微对几点想法说一下</p>
<h3 id="函数体系及实现">函数体系及实现</h3>
<p>核心是我们的头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> WLC_BN_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WLC_BN_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">"wlc_types.h"</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> {</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAX_BN_DIGS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_BN_DIGS 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> dig_t</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WBITS == 64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint64_t</span> <span class="type">dig_t</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">uint32_t</span> <span class="type">dig_t</span>;					<span class="comment">// 这个程序中WBITS是32</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIG_BYTES (WBITS / 8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIG_MASK ((1ULL &lt;&lt; WBITS) - 1)	<span class="comment">// 掩码 0xFFFFFFFF</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值（错误码）定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> {</span></span><br><span class="line">    BN_SUCCESS = <span class="number">0</span>,</span><br><span class="line">    BN_ERR_NULL_PTR = <span class="number">-1</span>,</span><br><span class="line">    BN_ERR_INVALID_SIZE = <span class="number">-2</span>,</span><br><span class="line">    BN_ERR_BUFFER_OVERFLOW = <span class="number">-3</span>,</span><br><span class="line">    BN_ERR_MEMORY = <span class="number">-4</span>,</span><br><span class="line">    BN_ERR_MODULUS_EVEN = <span class="number">-5</span>,</span><br><span class="line">    BN_ERR_INVALID_PARAM = <span class="number">-6</span>,</span><br><span class="line">    BN_ERR_NO_MODULAR_INVERSE = <span class="number">-7</span>,</span><br><span class="line">    BN_ERR_MONTGOMERY_INVALID = <span class="number">-8</span>,</span><br><span class="line">    BN_ERR_NO_INVERSE = <span class="number">-9</span>,</span><br><span class="line">    BN_ERR_ALL_NEGATIVE_RESULT = <span class="number">-10</span>,</span><br><span class="line">    BN_ERR_FIRST_NEGATIVE_RESULT = <span class="number">-11</span>,</span><br><span class="line">    BN_ERR_SECOND_NEGATIVE_RESULT = <span class="number">-12</span>,</span><br><span class="line">    BN_ERR_RANDOM_ALLOC_FAIL = <span class="number">-13</span>,</span><br><span class="line">} <span class="type">bn_err_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Resize函数能否截断有用数据</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> {</span></span><br><span class="line">    BN_RESIZE_SAFE,   </span><br><span class="line">    BN_RESIZE_TRUNCATE</span><br><span class="line">} <span class="type">bn_resize_mode_t</span>;    </span><br><span class="line"></span><br><span class="line"><span class="comment">// BN结构体，封装大整数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">dig_t</span> *data;      <span class="comment">// 数据数组</span></span><br><span class="line">    <span class="type">int</span> used_digs;    <span class="comment">// 实际使用的dig_t个数，方便我们判断数的大小</span></span><br><span class="line">    <span class="type">int</span> capacity;     <span class="comment">// 容量（dig_t个数），方便我们判断内存大小是否满足需要</span></span><br><span class="line">} <span class="type">bn_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 蒙哥马利上下文结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> {</span></span><br><span class="line">    <span class="type">bn_t</span> N;           <span class="comment">// 模数</span></span><br><span class="line">    <span class="type">bn_t</span> R;           <span class="comment">// R = 2^k</span></span><br><span class="line">    <span class="type">bn_t</span> N_prime;     <span class="comment">// N' = -N⁻¹ mod R</span></span><br><span class="line">    <span class="type">bn_t</span> R2;          <span class="comment">// R2 = R^2 mod N </span></span><br><span class="line">    <span class="type">int</span> k;            <span class="comment">// R的位数</span></span><br><span class="line">    <span class="type">int</span> k_digs;       <span class="comment">// k对应的dig_t数量</span></span><br><span class="line">} <span class="type">mont_ctx_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== 内存管理 ====================</span></span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_init</span><span class="params">(<span class="type">bn_t</span> *bn, <span class="type">int</span> capacity)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_init_copy</span><span class="params">(<span class="type">bn_t</span> *bn, <span class="type">const</span> <span class="type">dig_t</span> *data, <span class="type">int</span> digs)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_free</span><span class="params">(<span class="type">bn_t</span> *bn)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_resize</span><span class="params">(<span class="type">bn_t</span> *bn, <span class="type">int</span> new_capacity, <span class="type">bn_resize_mode_t</span> mode)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_ensure_capacity</span><span class="params">(<span class="type">bn_t</span> *bn, <span class="type">int</span> required_digs)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== 工具函数 ====================</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">bn_get_bits</span><span class="params">(<span class="type">const</span> <span class="type">bn_t</span> *bn)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bn_cmp</span><span class="params">(<span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bn_is_zero</span><span class="params">(<span class="type">const</span> <span class="type">bn_t</span> *bn)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bn_is_even</span><span class="params">(<span class="type">const</span> <span class="type">bn_t</span> *bn)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">bn_is_one</span><span class="params">(<span class="type">const</span> <span class="type">bn_t</span> *bn)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_set_zero</span><span class="params">(<span class="type">bn_t</span> *bn)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_set_one</span><span class="params">(<span class="type">bn_t</span> *bn)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_copy</span><span class="params">(<span class="type">bn_t</span> *dst, <span class="type">const</span> <span class="type">bn_t</span> *src)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_rand</span><span class="params">(<span class="type">bn_t</span> *bn, <span class="type">int</span> bits)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_rand_range</span><span class="params">(<span class="type">bn_t</span> *bn, <span class="type">const</span> <span class="type">bn_t</span> *max)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_rand_security</span><span class="params">(<span class="type">bn_t</span> *bn, <span class="type">int</span> bits)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bn_print</span><span class="params">(<span class="type">const</span> <span class="type">bn_t</span> *bn, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">bn_print_hex</span><span class="params">(<span class="type">const</span> <span class="type">bn_t</span> *bn, <span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_truncate_replace</span><span class="params">(<span class="type">bn_t</span> *dst, <span class="type">const</span> <span class="type">bn_t</span> *src, <span class="type">int</span> num_digs)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_truncate</span><span class="params">(<span class="type">bn_t</span> *bn, <span class="type">int</span> digs)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_truncate_bits</span><span class="params">(<span class="type">bn_t</span> *bn, <span class="type">int</span> bits)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== 基础运算 ====================</span></span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_add</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *b)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_sub</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *b)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_sub_signed</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *b)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_sub_with_sign</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">int</span> *is_negative, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *b)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_mul</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *b)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_sqr</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_div</span><span class="params">(<span class="type">bn_t</span> *q, <span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *b)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_mod</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *m)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_lsh</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">int</span> bits)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_rsh</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">int</span> bits)</span>;</span><br><span class="line"><span class="type">dig_t</span> <span class="title function_">bn_add_dig</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">dig_t</span> b)</span>;</span><br><span class="line"><span class="type">dig_t</span> <span class="title function_">bn_sub_dig</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">dig_t</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== 模运算 ====================</span></span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_mod_add</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *b, <span class="type">const</span> <span class="type">bn_t</span> *m)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_mod_sub</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *b, <span class="type">const</span> <span class="type">bn_t</span> *m)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_mod_mul</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *b, <span class="type">const</span> <span class="type">bn_t</span> *m)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_mod_sqr</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *m)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_mod_exp</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *e, <span class="type">const</span> <span class="type">bn_t</span> *m)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_mod_inv</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *m)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_mod_hlv</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *m)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== 蒙哥马利算法 ====================</span></span><br><span class="line"><span class="comment">// 蒙哥马利上下文管理</span></span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">mont_ctx_init</span><span class="params">(<span class="type">mont_ctx_t</span> *ctx, <span class="type">const</span> <span class="type">bn_t</span> *N)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mont_ctx_free</span><span class="params">(<span class="type">mont_ctx_t</span> *ctx)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">mont_ctx_compute</span><span class="params">(<span class="type">mont_ctx_t</span> *ctx, <span class="type">const</span> <span class="type">bn_t</span> *N)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 蒙哥马利预计算</span></span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">mont_compute_R</span><span class="params">(<span class="type">bn_t</span> *R, <span class="type">const</span> <span class="type">bn_t</span> *N, <span class="type">int</span> *k)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">mont_compute_N_prime</span><span class="params">(<span class="type">bn_t</span> *N_prime, <span class="type">const</span> <span class="type">bn_t</span> *N, <span class="type">const</span> <span class="type">bn_t</span> *R)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 蒙哥马利转换</span></span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">mont_map</span><span class="params">(<span class="type">bn_t</span> *a_mont, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">mont_ctx_t</span> *ctx)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">mont_reduce</span><span class="params">(<span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *a_mont, <span class="type">const</span> <span class="type">mont_ctx_t</span> *ctx)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 蒙哥马利运算</span></span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">mont_add</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *b, <span class="type">const</span> <span class="type">mont_ctx_t</span> *ctx)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">mont_sub</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *b, <span class="type">const</span> <span class="type">mont_ctx_t</span> *ctx)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">mont_mul</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *b, <span class="type">const</span> <span class="type">mont_ctx_t</span> *ctx)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">mont_sqr</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">mont_ctx_t</span> *ctx)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">mont_exp</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *e, <span class="type">const</span> <span class="type">mont_ctx_t</span> *ctx)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">mont_redc_internal</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *T, <span class="type">const</span> <span class="type">bn_t</span> *N, <span class="type">const</span> <span class="type">bn_t</span> *N_prime, <span class="type">int</span> k)</span>;</span><br><span class="line"><span class="comment">// 使用蒙哥马利的模运算（高级接口）</span></span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_mod_mul_mont</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *b, <span class="type">const</span> <span class="type">bn_t</span> *m)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_mod_exp_mont</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *e, <span class="type">const</span> <span class="type">bn_t</span> *m)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==================== 辅助函数 ====================</span></span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_from_hex</span><span class="params">(<span class="type">bn_t</span> *bn, <span class="type">const</span> <span class="type">char</span> *hex_str)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_from_bytes</span><span class="params">(<span class="type">bn_t</span> *bn, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *bytes, <span class="type">int</span> byte_len)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_to_bytes</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *bytes, <span class="type">int</span> *byte_len, <span class="type">const</span> <span class="type">bn_t</span> *bn, <span class="type">int</span> max_len)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_extend</span><span class="params">(<span class="type">bn_t</span> *bn, <span class="type">int</span> digs, <span class="type">dig_t</span> fill)</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">}</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* WLC_BN_H */</span></span></span><br></pre></td></tr></table></figure>
<h4 id="内存管理">内存管理</h4>
<p>鉴于我们是进行大整数运算，可能会申请大量的内存，因此我设立了一系列函数帮助我在堆上管理内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_init</span><span class="params">(<span class="type">bn_t</span> *bn, <span class="type">int</span> capacity)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_init_copy</span><span class="params">(<span class="type">bn_t</span> *bn, <span class="type">const</span> <span class="type">dig_t</span> *data, <span class="type">int</span> digs)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_free</span><span class="params">(<span class="type">bn_t</span> *bn)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_resize</span><span class="params">(<span class="type">bn_t</span> *bn, <span class="type">int</span> new_capacity)</span>;</span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_ensure_capacity</span><span class="params">(<span class="type">bn_t</span> *bn, <span class="type">int</span> required_digs)</span>;</span><br></pre></td></tr></table></figure>
<p>首先是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_init</span><span class="params">(<span class="type">bn_t</span> *bn, <span class="type">int</span> capacity)</span>;</span><br></pre></td></tr></table></figure>
<p>帮助我们初始化<code>bn_t</code>这个结构体，得到一个至少容量为1的dig容量，并且calloc会将内存清零便于我们快速使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_init</span><span class="params">(<span class="type">bn_t</span> *bn, <span class="type">int</span> capacity)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!bn) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) capacity = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    bn-&gt;data = (<span class="type">dig_t</span> *)<span class="built_in">calloc</span>(capacity, <span class="keyword">sizeof</span>(<span class="type">dig_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (!bn-&gt;data) <span class="keyword">return</span> BN_ERR_MEMORY;</span><br><span class="line">    </span><br><span class="line">    bn-&gt;capacity = capacity;</span><br><span class="line">    bn-&gt;used_digs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>方便我们申请一个bn_t结构体进行后续使用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_t</span> temp;</span><br><span class="line">bn_init(&amp;temp, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>然后是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_init_copy</span><span class="params">(<span class="type">bn_t</span> *bn, <span class="type">const</span> <span class="type">dig_t</span> *data, <span class="type">int</span> digs)</span>;</span><br></pre></td></tr></table></figure>
<p>一样是初始化结构体，但是进一步实现了数的复制，并且可以通过参数设置复制的digs数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_init_copy</span><span class="params">(<span class="type">bn_t</span> *bn, <span class="type">const</span> <span class="type">dig_t</span> *data, <span class="type">int</span> digs)</span> {</span><br><span class="line">    <span class="type">bn_err_t</span> err = bn_init(bn, digs);</span><br><span class="line">    <span class="keyword">if</span> (err != BN_SUCCESS) <span class="keyword">return</span> err;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (data &amp;&amp; digs &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">memcpy</span>(bn-&gt;data, data, digs * <span class="keyword">sizeof</span>(<span class="type">dig_t</span>));</span><br><span class="line">        bn-&gt;used_digs = digs;</span><br><span class="line">        <span class="keyword">while</span> (bn-&gt;used_digs &gt; <span class="number">0</span> &amp;&amp; bn-&gt;data[bn-&gt;used_digs - <span class="number">1</span>] == <span class="number">0</span>) {		<span class="comment">// 假如复制数据使前面的digs全是0（也称前导0），则收缩</span></span><br><span class="line">            bn-&gt;used_digs--;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>然后是内存释放函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_free</span><span class="params">(<span class="type">bn_t</span> *bn)</span>;</span><br></pre></td></tr></table></figure>
<p>帮助我们释放内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_free</span><span class="params">(<span class="type">bn_t</span> *bn)</span> {</span><br><span class="line">    <span class="keyword">if</span> (bn &amp;&amp; bn-&gt;data) {</span><br><span class="line">        <span class="built_in">free</span>(bn-&gt;data);</span><br><span class="line">        bn-&gt;data = <span class="literal">NULL</span>;	<span class="comment">// 清空指针，防止UAF</span></span><br><span class="line">        bn-&gt;capacity = <span class="number">0</span>;</span><br><span class="line">        bn-&gt;used_digs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>然后是动态内存调整</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_resize</span><span class="params">(<span class="type">bn_t</span> *bn, <span class="type">int</span> new_capacity, <span class="type">bn_resize_mode_t</span> mode)</span>;</span><br></pre></td></tr></table></figure>
<p>方便我们调整capacity的大小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_resize</span><span class="params">(<span class="type">bn_t</span> *bn, <span class="type">int</span> new_capacity, <span class="type">bn_resize_mode_t</span> mode)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!bn) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    <span class="keyword">if</span> (new_capacity &lt;= <span class="number">0</span>) <span class="keyword">return</span> BN_ERR_INVALID_SIZE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (new_capacity == bn-&gt;capacity) {</span><br><span class="line">        <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (new_capacity &lt; bn-&gt;capacity) {</span><br><span class="line">        <span class="keyword">if</span> (mode == BN_RESIZE_SAFE) {</span><br><span class="line">			<span class="comment">// 不允许截断非0数据</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = new_capacity; i &lt; bn-&gt;used_digs; i++) {</span><br><span class="line">                <span class="keyword">if</span> (bn-&gt;data[i] != <span class="number">0</span>) {</span><br><span class="line">                    <span class="keyword">return</span> BN_ERR_TRUNCATION;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (bn-&gt;used_digs &gt; new_capacity) {</span><br><span class="line">            bn-&gt;used_digs = new_capacity;	<span class="comment">// 缩减大小</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">dig_t</span> *new_data = (<span class="type">dig_t</span> *)<span class="built_in">realloc</span>(bn-&gt;data, new_capacity * <span class="keyword">sizeof</span>(<span class="type">dig_t</span>));</span><br><span class="line">    <span class="keyword">if</span> (!new_data) <span class="keyword">return</span> BN_ERR_MEMORY;	<span class="comment">// 失败也保存原来数据</span></span><br><span class="line">    </span><br><span class="line">    bn-&gt;data = new_data;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清零新增大小的内存</span></span><br><span class="line">    <span class="keyword">if</span> (new_capacity &gt; bn-&gt;capacity) {</span><br><span class="line">        <span class="built_in">memset</span>(bn-&gt;data + bn-&gt;capacity, <span class="number">0</span>, (new_capacity - bn-&gt;capacity) * <span class="keyword">sizeof</span>(<span class="type">dig_t</span>));</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    bn-&gt;capacity = new_capacity;</span><br><span class="line">    <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>然后是capacity校验函数，防止出现内存不足的情况</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_ensure_capacity</span><span class="params">(<span class="type">bn_t</span> *bn, <span class="type">int</span> required_digs)</span>;</span><br></pre></td></tr></table></figure>
<p>这里不可能发生截断，所以使用了<code>BN_RESIZE_TRUNCATE</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_ensure_capacity</span><span class="params">(<span class="type">bn_t</span> *bn, <span class="type">int</span> required_digs)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!bn) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    <span class="keyword">if</span> (required_digs &lt;= <span class="number">0</span>) <span class="keyword">return</span> BN_ERR_INVALID_SIZE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (required_digs &lt;= bn-&gt;capacity) {</span><br><span class="line">        <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 增长策略：取所需大小的1.5倍</span></span><br><span class="line">    <span class="type">int</span> new_capacity = required_digs * <span class="number">3</span> / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> bn_resize(bn, new_capacity, BN_RESIZE_TRUNCATE);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="工具函数">工具函数</h4>
<p>对于大整数运算中，去判断或是设置某一特定位是1还是0便于我们操作，比如说设置一个<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.152ex" height="1.932ex" role="img" focusable="false" viewBox="0 -853.7 951.4 853.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g><g data-mml-node="mspace" transform="translate(951.4,0)"></g></g></g></svg></mjx-container></span>，或者是在蒙哥马利模幂中判断是否为1，或者是得到我们的位数都需要依赖这两个函数</p>
<p>因此我们先设置这两个函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">bn_get_bit</span><span class="params">(<span class="type">const</span> <span class="type">bn_t</span> *bn, <span class="type">int</span> bit)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!bn || bit &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> word_idx = bit / WBITS;</span><br><span class="line">    <span class="type">int</span> bit_idx = bit % WBITS;</span><br><span class="line">    <span class="keyword">if</span> (word_idx &gt;= bn-&gt;used_digs) <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">// 零拓展</span></span><br><span class="line">    <span class="keyword">return</span> (bn-&gt;data[word_idx] &gt;&gt; bit_idx) &amp; <span class="number">1</span>;	<span class="comment">// 右移加&amp;运算</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">bn_err_t</span> <span class="title function_">bn_set_bit</span><span class="params">(<span class="type">bn_t</span> *bn, <span class="type">int</span> bit, <span class="type">int</span> value)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!bn || bit &lt; <span class="number">0</span>) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    <span class="type">int</span> word_idx = bit / WBITS;</span><br><span class="line">    <span class="type">int</span> bit_idx = bit % WBITS;</span><br><span class="line">    <span class="keyword">if</span> (word_idx &gt;= bn-&gt;capacity) {</span><br><span class="line">        <span class="type">bn_err_t</span> err = bn_ensure_capacity(bn, word_idx + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(err != BN_SUCCESS){</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (word_idx &gt;= bn-&gt;used_digs) {</span><br><span class="line">        bn-&gt;used_digs = word_idx + <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (value) {</span><br><span class="line">        bn-&gt;data[word_idx] |= (<span class="type">dig_t</span>)<span class="number">1</span> &lt;&lt; bit_idx;	<span class="comment">// 设为1</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        bn-&gt;data[word_idx] &amp;= ~((<span class="type">dig_t</span>)<span class="number">1</span> &lt;&lt; bit_idx);	<span class="comment">// 设为0</span></span><br><span class="line">        <span class="comment">// 如果清除的是最高位且 word 变为 0，更新 used_digs</span></span><br><span class="line">        <span class="keyword">if</span> (word_idx == bn-&gt;used_digs - <span class="number">1</span> &amp;&amp; bn-&gt;data[word_idx] == <span class="number">0</span>) {</span><br><span class="line">            <span class="keyword">while</span> (bn-&gt;used_digs &gt; <span class="number">0</span> &amp;&amp; bn-&gt;data[bn-&gt;used_digs - <span class="number">1</span>] == <span class="number">0</span>) {</span><br><span class="line">                bn-&gt;used_digs--;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>然后我们设置一个用来判断数字有多少位的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bn_get_bits</span><span class="params">(<span class="type">const</span> <span class="type">bn_t</span> *bn)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!bn || bn-&gt;used_digs == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">// 空数据</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i = bn-&gt;used_digs - <span class="number">1</span>;</span><br><span class="line">    <span class="type">dig_t</span> top = bn-&gt;data[i];	<span class="comment">// 只需要取最高位的数字dig_t来判断</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WBITS == 64</span></span><br><span class="line">    <span class="keyword">return</span> i * WBITS + (<span class="number">64</span> - __builtin_clzll(top));</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> i * WBITS + (<span class="number">32</span> - __builtin_clz(top));	<span class="comment">// 这个是32位程序使用的</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>判断是否为0，是否为偶数（奇数）这类函数也顺便实现一下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bn_is_zero</span><span class="params">(<span class="type">const</span> <span class="type">bn_t</span> *bn)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!bn) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (bn-&gt;used_digs == <span class="number">0</span>) || (bn-&gt;used_digs == <span class="number">1</span> &amp;&amp; bn-&gt;data[<span class="number">0</span>] == <span class="number">0</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bn_is_one</span><span class="params">(<span class="type">const</span> <span class="type">bn_t</span> *bn)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!bn) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> (bn-&gt;used_digs == <span class="number">1</span> &amp;&amp; bn-&gt;data[<span class="number">0</span>] == <span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">bn_is_even</span><span class="params">(<span class="type">const</span> <span class="type">bn_t</span> *bn)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!bn) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (bn-&gt;used_digs == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (bn-&gt;data[<span class="number">0</span>] &amp; <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">// 判断正确则返回1，否则返回0</span></span><br></pre></td></tr></table></figure>
<p>比较函数对于相减和模计算比较重要</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">bn_cmp</span><span class="params">(<span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *b)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!a || !b) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (a-&gt;used_digs != b-&gt;used_digs) {					<span class="comment">// 先比较dig_t的数目</span></span><br><span class="line">        <span class="keyword">return</span> a-&gt;used_digs &gt; b-&gt;used_digs ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = a-&gt;used_digs - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">        <span class="keyword">if</span> (a-&gt;data[i] &gt; b-&gt;data[i]) <span class="keyword">return</span> <span class="number">1</span>;			<span class="comment">// 再从高dig_t比较到低dig_t</span></span><br><span class="line">        <span class="keyword">if</span> (a-&gt;data[i] &lt; b-&gt;data[i]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>下面是几个比较常用的赋值函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_set_zero</span><span class="params">(<span class="type">bn_t</span> *bn)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!bn) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (bn-&gt;data) {</span><br><span class="line">        <span class="built_in">memset</span>(bn-&gt;data, <span class="number">0</span>, bn-&gt;capacity * <span class="keyword">sizeof</span>(<span class="type">dig_t</span>));</span><br><span class="line">    }</span><br><span class="line">    bn-&gt;used_digs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>清零函数高效清除数据</p>
<p>再设置一个置1的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_set_one</span><span class="params">(<span class="type">bn_t</span> *bn)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!bn) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bn_err_t</span> err = bn_ensure_capacity(bn, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != BN_SUCCESS) <span class="keyword">return</span> err;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (bn-&gt;used_digs &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">memset</span>(bn-&gt;data, <span class="number">0</span>, bn-&gt;capacity * <span class="keyword">sizeof</span>(<span class="type">dig_t</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置值为1</span></span><br><span class="line">    bn-&gt;data[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    bn-&gt;used_digs = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>然后是复制操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_copy</span><span class="params">(<span class="type">bn_t</span> *dst, <span class="type">const</span> <span class="type">bn_t</span> *src)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!dst || !src) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    <span class="keyword">if</span> (dst == src) <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">    <span class="keyword">if</span> (src-&gt;used_digs == <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> bn_set_zero(dst);	<span class="comment">// 清零</span></span><br><span class="line">    }</span><br><span class="line">    <span class="type">bn_err_t</span> err = bn_ensure_capacity(dst, src-&gt;used_digs);</span><br><span class="line">    <span class="keyword">if</span> (err != BN_SUCCESS) <span class="keyword">return</span> err;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memcpy</span>(dst-&gt;data, src-&gt;data, src-&gt;used_digs * <span class="keyword">sizeof</span>(<span class="type">dig_t</span>));	<span class="comment">// 复制</span></span><br><span class="line">    dst-&gt;used_digs = src-&gt;used_digs;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (dst-&gt;used_digs &lt; dst-&gt;capacity) {</span><br><span class="line">        <span class="built_in">memset</span>(dst-&gt;data + dst-&gt;used_digs, <span class="number">0</span>, (dst-&gt;capacity - dst-&gt;used_digs) * <span class="keyword">sizeof</span>(<span class="type">dig_t</span>));	<span class="comment">// 清零dst高位</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>还有随机数生成器</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_rand</span><span class="params">(<span class="type">bn_t</span> *bn, <span class="type">int</span> bits)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!bn) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    <span class="keyword">if</span> (bits &lt;= <span class="number">0</span>) <span class="keyword">return</span> BN_ERR_INVALID_SIZE;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> digs = (bits + WBITS - <span class="number">1</span>) / WBITS;</span><br><span class="line">    <span class="type">bn_err_t</span> err = bn_ensure_capacity(bn, digs);</span><br><span class="line">    <span class="keyword">if</span> (err != BN_SUCCESS) <span class="keyword">return</span> err;</span><br><span class="line">    </span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> seeded = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!seeded) {</span><br><span class="line">        srand(time(<span class="literal">NULL</span>));</span><br><span class="line">        seeded = <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; digs; i++) {</span><br><span class="line">        bn-&gt;data[i] = (<span class="type">dig_t</span>)rand() &lt;&lt; <span class="number">17</span> | (<span class="type">dig_t</span>)rand() &lt;&lt; <span class="number">2</span>  | (<span class="type">dig_t</span>)(rand() &amp; <span class="number">0x3</span>); 	<span class="comment">// rand返回0~0x7FFF</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理最高位，确保位数正确</span></span><br><span class="line">    <span class="type">int</span> bit_mask = bits % WBITS;</span><br><span class="line">    <span class="keyword">if</span> (bit_mask &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="type">dig_t</span> mask = (<span class="number">1ULL</span> &lt;&lt; bit_mask) - <span class="number">1</span>;</span><br><span class="line">        bn-&gt;data[digs - <span class="number">1</span>] &amp;= mask;</span><br><span class="line">        <span class="comment">// 确保最高位为1</span></span><br><span class="line">        <span class="keyword">if</span> (bit_mask &gt; <span class="number">1</span>) {</span><br><span class="line">            bn-&gt;data[digs - <span class="number">1</span>] |= (<span class="number">1ULL</span> &lt;&lt; (bit_mask - <span class="number">1</span>));</span><br><span class="line">        }</span><br><span class="line">    }<span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (digs &gt; <span class="number">0</span>) {</span><br><span class="line">            bn-&gt;data[digs - <span class="number">1</span>] |= (<span class="number">1ULL</span> &lt;&lt; (WBITS - <span class="number">1</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    bn-&gt;used_digs = digs;</span><br><span class="line">    <span class="keyword">while</span> (bn-&gt;used_digs &gt; <span class="number">0</span> &amp;&amp; bn-&gt;data[bn-&gt;used_digs - <span class="number">1</span>] == <span class="number">0</span>) {</span><br><span class="line">        bn-&gt;used_digs--;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>rand函数生成的随机数质量不高，我们使用<code>BCryptGenRandom</code>来生成高质量的随机数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_rand_security</span><span class="params">(<span class="type">bn_t</span> *bn, <span class="type">int</span> bits)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!bn) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    <span class="keyword">if</span> (bits &lt;= <span class="number">0</span>) <span class="keyword">return</span> BN_ERR_INVALID_SIZE;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> digs = (bits + WBITS - <span class="number">1</span>) / WBITS;</span><br><span class="line">    <span class="type">bn_err_t</span> err = bn_ensure_capacity(bn, digs);</span><br><span class="line">    <span class="keyword">if</span> (err != BN_SUCCESS) <span class="keyword">return</span> err;</span><br><span class="line">    </span><br><span class="line">    <span class="type">size_t</span> total_bytes = digs * <span class="keyword">sizeof</span>(<span class="type">dig_t</span>);</span><br><span class="line">    </span><br><span class="line">    NTSTATUS status = BCryptGenRandom(</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        (PUCHAR)bn-&gt;data,</span><br><span class="line">        (ULONG)total_bytes,</span><br><span class="line">        BCRYPT_USE_SYSTEM_PREFERRED_RNG</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> BN_ERR_RANDOM_ALLOC_FAIL;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    bn_truncate_bits(bn,bits);	<span class="comment">// 截断</span></span><br><span class="line">    <span class="type">int</span> bit_mask = bits % WBITS;</span><br><span class="line">    <span class="type">int</span> last_word = digs - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (bit_mask &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="comment">// 设置最高位为1</span></span><br><span class="line">        <span class="keyword">if</span> (bit_mask &gt; <span class="number">1</span>) {</span><br><span class="line">            bn-&gt;data[last_word] |= (<span class="number">1ULL</span> &lt;&lt; (bit_mask - <span class="number">1</span>));</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">if</span> (digs &gt; <span class="number">0</span>) {</span><br><span class="line">            bn-&gt;data[last_word] |= (<span class="number">1ULL</span> &lt;&lt; (WBITS - <span class="number">1</span>));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    bn-&gt;used_digs = digs;</span><br><span class="line">    <span class="keyword">while</span> (bn-&gt;used_digs &gt; <span class="number">0</span> &amp;&amp; bn-&gt;data[bn-&gt;used_digs - <span class="number">1</span>] == <span class="number">0</span>) {</span><br><span class="line">        bn-&gt;used_digs--;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>然后是打印函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bn_print</span><span class="params">(<span class="type">const</span> <span class="type">bn_t</span> *bn, <span class="type">const</span> <span class="type">char</span> *name)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!bn) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n%s: (null)\n"</span>, name ? name : <span class="string">"bn"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n%s: "</span>, name ? name : <span class="string">"bn"</span>);</span><br><span class="line">    <span class="keyword">if</span> (bn_is_zero(bn)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0x"</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = bn-&gt;used_digs - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WBITS == 64</span></span><br><span class="line">        <span class="keyword">if</span> (i == bn-&gt;used_digs - <span class="number">1</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%"</span> PRIx64, (<span class="type">uint64_t</span>)bn-&gt;data[i]);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%016"</span> PRIx64, (<span class="type">uint64_t</span>)bn-&gt;data[i]);</span><br><span class="line">        }</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="keyword">if</span> (i == bn-&gt;used_digs - <span class="number">1</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%"</span> PRIx32, (<span class="type">uint32_t</span>)bn-&gt;data[i]);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%08"</span> PRIx32, (<span class="type">uint32_t</span>)bn-&gt;data[i]);</span><br><span class="line">        }</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" (%d digs)\n"</span>, bn-&gt;used_digs);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>AI帮我设计了一个debug的printf</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bn_print_debug</span><span class="params">(<span class="type">const</span> <span class="type">bn_t</span> *bn, <span class="type">const</span> <span class="type">char</span> *name)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!bn) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s: (null)\n"</span>, name ? name : <span class="string">"bn"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n=== %s Debug Info ===\n"</span>, name ? name : <span class="string">"bn"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 基本状态</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  used_digs: %d\n"</span>, bn-&gt;used_digs);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  capacity:  %d\n"</span>, bn-&gt;capacity);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 安全检查</span></span><br><span class="line">    <span class="keyword">if</span> (!bn-&gt;data) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  ERROR: data pointer is NULL!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (bn-&gt;capacity &lt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  ERROR: invalid capacity (%d)!\n"</span>, bn-&gt;capacity);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (bn-&gt;used_digs &gt; bn-&gt;capacity) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"  ERROR: used_digs (%d) &gt; capacity (%d)!\n"</span>, </span><br><span class="line">               bn-&gt;used_digs, bn-&gt;capacity);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 所有分配的字</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  All allocated words (%d total):\n"</span>, bn-&gt;capacity);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = bn-&gt;capacity - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"    [%3d]: 0x"</span>, i);</span><br><span class="line">        </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WBITS == 64</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%016"</span> PRIx64, (<span class="type">uint64_t</span>)bn-&gt;data[i]);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%08"</span> PRIx32, (<span class="type">uint32_t</span>)bn-&gt;data[i]);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 状态标记</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= bn-&gt;used_digs) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"  [unused]"</span>);</span><br><span class="line">            <span class="keyword">if</span> (bn-&gt;data[i] != <span class="number">0</span>) {</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" (WARNING: non-zero!)"</span>);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (i == bn-&gt;used_digs - <span class="number">1</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"  [MSB]"</span>);  <span class="comment">// Most Significant Bit</span></span><br><span class="line">            <span class="keyword">if</span> (bn-&gt;data[i] == <span class="number">0</span>) {</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">" (ERROR: leading zero!)"</span>);</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">else</span> <span class="keyword">if</span> (bn-&gt;data[i] == <span class="number">0</span>) {</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"  [zero]"</span>);</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 标准格式（紧凑）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  Compact hex: "</span>);</span><br><span class="line">    <span class="keyword">if</span> (bn-&gt;used_digs == <span class="number">0</span> || (bn-&gt;used_digs == <span class="number">1</span> &amp;&amp; bn-&gt;data[<span class="number">0</span>] == <span class="number">0</span>)) {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0"</span>);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"0x"</span>);</span><br><span class="line">        <span class="type">int</span> i = bn-&gt;used_digs - <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最高位不带前导零</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WBITS == 64</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%"</span> PRIx64, (<span class="type">uint64_t</span>)bn-&gt;data[i]);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%"</span> PRIx32, (<span class="type">uint32_t</span>)bn-&gt;data[i]);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 其他位带前导零</span></span><br><span class="line">        <span class="keyword">for</span> (i--; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> WBITS == 64</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%016"</span> PRIx64, (<span class="type">uint64_t</span>)bn-&gt;data[i]);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%08"</span> PRIx32, (<span class="type">uint32_t</span>)bn-&gt;data[i]);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 大小估算</span></span><br><span class="line">    <span class="type">size_t</span> used_bytes = bn-&gt;used_digs * <span class="keyword">sizeof</span>(<span class="type">dig_t</span>);</span><br><span class="line">    <span class="type">size_t</span> alloc_bytes = bn-&gt;capacity * <span class="keyword">sizeof</span>(<span class="type">dig_t</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"  Memory: %zu/%zu bytes used (%.1f%%)\n"</span>, </span><br><span class="line">           used_bytes, alloc_bytes, </span><br><span class="line">           alloc_bytes ? (<span class="number">100.0</span> * used_bytes / alloc_bytes) : <span class="number">0.0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"================================\n\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>然后是截断函数，对于模<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.152ex" height="1.932ex" role="img" focusable="false" viewBox="0 -853.7 951.4 853.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g><g data-mml-node="mspace" transform="translate(951.4,0)"></g></g></g></svg></mjx-container></span>有奇效</p>
<p>这种是复制型的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_truncate_copy</span><span class="params">(<span class="type">bn_t</span> *dst, <span class="type">const</span> <span class="type">bn_t</span> *src, <span class="type">int</span> digs)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!dst || !src) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    <span class="keyword">if</span> (digs &lt;= <span class="number">0</span>) <span class="keyword">return</span> BN_ERR_INVALID_PARAM;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 确保dst有足够容量</span></span><br><span class="line">    <span class="type">bn_err_t</span> err = bn_ensure_capacity(dst, digs);</span><br><span class="line">    <span class="keyword">if</span> (err != BN_SUCCESS) <span class="keyword">return</span> err;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清零</span></span><br><span class="line">    <span class="built_in">memset</span>(dst-&gt;data, <span class="number">0</span>, dst-&gt;capacity * <span class="keyword">sizeof</span>(<span class="type">dig_t</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算实际复制数量</span></span><br><span class="line">    <span class="type">int</span> copy_digs = (src-&gt;used_digs &lt; digs) ? src-&gt;used_digs : digs;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 复制低位</span></span><br><span class="line">    <span class="built_in">memcpy</span>(dst-&gt;data, src-&gt;data, copy_digs * <span class="keyword">sizeof</span>(<span class="type">dig_t</span>));</span><br><span class="line">    </span><br><span class="line">    dst-&gt;used_digs = copy_digs;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 去除前导零</span></span><br><span class="line">    <span class="keyword">while</span> (dst-&gt;used_digs &gt; <span class="number">0</span> &amp;&amp; dst-&gt;data[dst-&gt;used_digs - <span class="number">1</span>] == <span class="number">0</span>) {</span><br><span class="line">        dst-&gt;used_digs--;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这种是对自身数据进行截断的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_truncate</span><span class="params">(<span class="type">bn_t</span> *bn, <span class="type">int</span> digs)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!bn) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    <span class="keyword">if</span> (digs &lt; <span class="number">0</span>) <span class="keyword">return</span> BN_ERR_INVALID_SIZE;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (digs &lt; bn-&gt;used_digs) {</span><br><span class="line">        bn-&gt;used_digs = digs;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (digs &lt; bn-&gt;capacity) {</span><br><span class="line">        <span class="built_in">memset</span>(bn-&gt;data + digs, <span class="number">0</span>, (bn-&gt;capacity - digs) * <span class="keyword">sizeof</span>(<span class="type">dig_t</span>));</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>还有一种是对位截断的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_truncate_bits</span><span class="params">(<span class="type">bn_t</span> *bn, <span class="type">int</span> bits)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!bn) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    <span class="keyword">if</span> (bits &lt;= <span class="number">0</span>) <span class="keyword">return</span> BN_ERR_INVALID_SIZE;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算需要保留的字数</span></span><br><span class="line">    <span class="type">int</span> digs_needed = (bits + WBITS - <span class="number">1</span>) / WBITS;</span><br><span class="line">    <span class="type">int</span> extra_bits = bits % WBITS;</span><br><span class="line">    <span class="comment">// 如果原数位数少于需要的，不需要截断</span></span><br><span class="line">    <span class="keyword">if</span> (bn-&gt;used_digs &lt;= digs_needed) {</span><br><span class="line">        <span class="keyword">if</span> (bn-&gt;used_digs == digs_needed) {		<span class="comment">// 只需处理最高字的掩码</span></span><br><span class="line">            <span class="keyword">if</span> (extra_bits &gt; <span class="number">0</span>) {</span><br><span class="line">                <span class="type">dig_t</span> mask = ((<span class="type">dig_t</span>)<span class="number">1</span> &lt;&lt; extra_bits) - <span class="number">1</span>;</span><br><span class="line">                bn-&gt;data[digs_needed - <span class="number">1</span>] &amp;= mask;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(bn-&gt;data + digs_needed, <span class="number">0</span>, (bn-&gt;used_digs - digs_needed) * <span class="keyword">sizeof</span>(<span class="type">dig_t</span>));</span><br><span class="line">    bn-&gt;used_digs = digs_needed;</span><br><span class="line">    <span class="comment">// 处理最高字的掩码</span></span><br><span class="line">    <span class="keyword">if</span> (extra_bits &gt; <span class="number">0</span>) {</span><br><span class="line">        <span class="type">dig_t</span> mask = ((<span class="type">dig_t</span>)<span class="number">1</span> &lt;&lt; extra_bits) - <span class="number">1</span>;</span><br><span class="line">        bn-&gt;data[digs_needed - <span class="number">1</span>] &amp;= mask;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (bn-&gt;used_digs &gt; <span class="number">0</span> &amp;&amp; bn-&gt;data[bn-&gt;used_digs - <span class="number">1</span>] == <span class="number">0</span>) {</span><br><span class="line">        bn-&gt;used_digs--;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="基础运算">基础运算</h4>
<p>加法就是简单的实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_add</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *b)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!r || !a || !b) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加原地操作支持</span></span><br><span class="line">    <span class="keyword">if</span> (r == a || r == b) {</span><br><span class="line">        <span class="type">bn_t</span> temp;</span><br><span class="line">        <span class="comment">// 初始化时指定容量</span></span><br><span class="line">        <span class="type">int</span> max_digs = MAX(a-&gt;used_digs, b-&gt;used_digs);</span><br><span class="line">        bn_init(&amp;temp, max_digs + <span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">bn_err_t</span> err = bn_add(&amp;temp, a, b);</span><br><span class="line">        <span class="keyword">if</span> (err != BN_SUCCESS) {</span><br><span class="line">            bn_free(&amp;temp);</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        }</span><br><span class="line">        err = bn_copy(r, &amp;temp);</span><br><span class="line">        bn_free(&amp;temp);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max_digs = MAX(a-&gt;used_digs, b-&gt;used_digs);</span><br><span class="line">    <span class="type">bn_err_t</span> err = bn_ensure_capacity(r, max_digs + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (err != BN_SUCCESS) <span class="keyword">return</span> err;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(r-&gt;data, <span class="number">0</span>, r-&gt;capacity * <span class="keyword">sizeof</span>(<span class="type">dig_t</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="type">uint64_t</span> carry = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; max_digs; i++) {</span><br><span class="line">        <span class="type">uint64_t</span> a_val = (i &lt; a-&gt;used_digs) ? a-&gt;data[i] : <span class="number">0</span>;</span><br><span class="line">        <span class="type">uint64_t</span> b_val = (i &lt; b-&gt;used_digs) ? b-&gt;data[i] : <span class="number">0</span>;</span><br><span class="line">        carry += a_val + b_val;</span><br><span class="line">        r-&gt;data[i] = (<span class="type">dig_t</span>)(carry &amp; DIG_MASK);</span><br><span class="line">        carry &gt;&gt;= WBITS;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) {</span><br><span class="line">        r-&gt;data[i] = (<span class="type">dig_t</span>)carry;</span><br><span class="line">        r-&gt;used_digs = max_digs + <span class="number">1</span>;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        r-&gt;used_digs = max_digs;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (r-&gt;used_digs &gt; <span class="number">0</span> &amp;&amp; r-&gt;data[r-&gt;used_digs - <span class="number">1</span>] == <span class="number">0</span>) {</span><br><span class="line">        r-&gt;used_digs--;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>还有减法（a&gt;b）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_sub</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *b)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!r || !a || !b) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cmp = bn_cmp(a, b);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> BN_ERR_ALL_NEGATIVE_RESULT;</span><br><span class="line">    }<span class="keyword">if</span> (cmp == <span class="number">0</span>) {</span><br><span class="line">        bn_set_zero(r);</span><br><span class="line">        <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// 原地操作处理</span></span><br><span class="line">    <span class="keyword">if</span> (r == a || r == b) {</span><br><span class="line">        <span class="type">bn_t</span> temp;</span><br><span class="line">        bn_init(&amp;temp, <span class="number">0</span>);</span><br><span class="line">        <span class="type">bn_err_t</span> err = bn_sub(&amp;temp, a, b);</span><br><span class="line">        <span class="keyword">if</span> (err != BN_SUCCESS) {</span><br><span class="line">            bn_free(&amp;temp);</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        }</span><br><span class="line">        err = bn_copy(r, &amp;temp);</span><br><span class="line">        bn_free(&amp;temp);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> max_digs = a-&gt;used_digs;</span><br><span class="line">    <span class="type">bn_err_t</span> err = bn_ensure_capacity(r, max_digs);</span><br><span class="line">    <span class="keyword">if</span> (err != BN_SUCCESS) <span class="keyword">return</span> err;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清零</span></span><br><span class="line">    <span class="built_in">memset</span>(r-&gt;data, <span class="number">0</span>, r-&gt;capacity * <span class="keyword">sizeof</span>(<span class="type">dig_t</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="type">uint64_t</span> borrow = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 逐位相减</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; max_digs; i++) {</span><br><span class="line">        <span class="type">uint64_t</span> a_val = (<span class="type">uint64_t</span>)a-&gt;data[i];</span><br><span class="line">        <span class="type">uint64_t</span> b_val = (i &lt; b-&gt;used_digs) ? (<span class="type">uint64_t</span>)b-&gt;data[i] : <span class="number">0</span>;</span><br><span class="line">        b_val += borrow;  <span class="comment">// 加上之前的借位</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (a_val &lt; b_val) {</span><br><span class="line">            <span class="comment">// 需要借位</span></span><br><span class="line">            a_val += ((<span class="type">uint64_t</span>)<span class="number">1</span> &lt;&lt; WBITS);</span><br><span class="line">            borrow = <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            borrow = <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        r-&gt;data[i] = (<span class="type">dig_t</span>)(a_val - b_val);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    r-&gt;used_digs = max_digs;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (r-&gt;used_digs &gt; <span class="number">0</span> &amp;&amp; r-&gt;data[r-&gt;used_digs - <span class="number">1</span>] == <span class="number">0</span>) {</span><br><span class="line">        r-&gt;used_digs--;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>既然有得到正数的减法，如何实现一个得到负数的减法，毕竟拓展欧几里得算法中间是会出现负数的</p>
<p>于是灵光一闪，使用错误码返回代表是正数是负数，<code>BN_SUCCESS</code>代表非负数，<code>BN_ERR_ALL_NEGATIVE_RESULT</code>代表负数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_sub_signed</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *b)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!r || !a || !b) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    <span class="type">int</span> cmp = bn_cmp(a, b);</span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="number">0</span>) {</span><br><span class="line">        bn_set_zero(r);</span><br><span class="line">        <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r == a || r == b) {</span><br><span class="line">        <span class="type">bn_t</span> temp;</span><br><span class="line">        bn_init(&amp;temp, <span class="number">0</span>);</span><br><span class="line">        <span class="type">bn_err_t</span> err = bn_sub_signed(&amp;temp, a, b);</span><br><span class="line">        <span class="keyword">if</span> (err != BN_SUCCESS &amp;&amp; err != BN_ERR_ALL_NEGATIVE_RESULT) {</span><br><span class="line">            bn_free(&amp;temp);</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        }</span><br><span class="line">        bn_copy(r, &amp;temp);</span><br><span class="line">        bn_free(&amp;temp);</span><br><span class="line">        <span class="keyword">return</span> err;  <span class="comment">// 保持原返回值</span></span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> max_digs = MAX(a-&gt;used_digs, b-&gt;used_digs);</span><br><span class="line">    <span class="type">bn_err_t</span> err = bn_ensure_capacity(r, max_digs);</span><br><span class="line">    <span class="keyword">if</span> (err != BN_SUCCESS) <span class="keyword">return</span> err;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(r-&gt;data, <span class="number">0</span>, r-&gt;capacity * <span class="keyword">sizeof</span>(<span class="type">dig_t</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="type">uint64_t</span> borrow = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (cmp &gt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a-&gt;used_digs; i++) {</span><br><span class="line">            <span class="type">uint64_t</span> a_val = (<span class="type">uint64_t</span>)a-&gt;data[i];</span><br><span class="line">            <span class="type">uint64_t</span> b_val = (i &lt; b-&gt;used_digs) ? (<span class="type">uint64_t</span>)b-&gt;data[i] : <span class="number">0</span>;</span><br><span class="line">            b_val += borrow;</span><br><span class="line">            <span class="keyword">if</span> (a_val &lt; b_val) {</span><br><span class="line">                a_val += ((<span class="type">uint64_t</span>)<span class="number">1</span> &lt;&lt; WBITS);</span><br><span class="line">                borrow = <span class="number">1</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                borrow = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            r-&gt;data[i] = (<span class="type">dig_t</span>)(a_val - b_val);</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; b-&gt;used_digs; i++) {</span><br><span class="line">            <span class="type">uint64_t</span> b_val = (<span class="type">uint64_t</span>)b-&gt;data[i];</span><br><span class="line">            <span class="type">uint64_t</span> a_val = (i &lt; a-&gt;used_digs) ? (<span class="type">uint64_t</span>)a-&gt;data[i] : <span class="number">0</span>;</span><br><span class="line">            a_val += borrow;</span><br><span class="line">            <span class="keyword">if</span> (b_val &lt; a_val) {</span><br><span class="line">                b_val += ((<span class="type">uint64_t</span>)<span class="number">1</span> &lt;&lt; WBITS);</span><br><span class="line">                borrow = <span class="number">1</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                borrow = <span class="number">0</span>;</span><br><span class="line">            }</span><br><span class="line">            r-&gt;data[i] = (<span class="type">dig_t</span>)(b_val - a_val);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    r-&gt;used_digs = max_digs;</span><br><span class="line">    <span class="keyword">while</span> (r-&gt;used_digs &gt; <span class="number">0</span> &amp;&amp; r-&gt;data[r-&gt;used_digs - <span class="number">1</span>] == <span class="number">0</span>) {</span><br><span class="line">        r-&gt;used_digs--;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cmp &gt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">return</span> BN_SUCCESS;  <span class="comment">// 结果为正</span></span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> BN_ERR_ALL_NEGATIVE_RESULT;  <span class="comment">// 结果为负</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>假如不使用错误码判断呢，那再拓展一下，传入一个变量来判断是否是正数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_sub_with_sign</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">int</span> *is_negative, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *b)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!r || !is_negative || !a || !b) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bn_err_t</span> err = bn_sub_signed(r, a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (err == BN_SUCCESS) {</span><br><span class="line">        *is_negative = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">    } <span class="keyword">else</span> <span class="keyword">if</span> (err == BN_ERR_ALL_NEGATIVE_RESULT) {</span><br><span class="line">        *is_negative = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>然后是乘法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_mul</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *b)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!r || !a || !b) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    <span class="keyword">if</span> (bn_is_zero(a) || bn_is_zero(b)){</span><br><span class="line">        <span class="keyword">return</span> bn_set_zero(r);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (bn_is_one(a)) {</span><br><span class="line">        <span class="keyword">return</span> bn_copy(r, b);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (bn_is_one(b)) {</span><br><span class="line">        <span class="keyword">return</span> bn_copy(r, a);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (r == a || r == b) {</span><br><span class="line">        <span class="type">bn_t</span> temp;</span><br><span class="line">        bn_init(&amp;temp, <span class="number">0</span>);</span><br><span class="line">        <span class="type">bn_err_t</span> err = bn_mul(&amp;temp, a, b);</span><br><span class="line">        <span class="keyword">if</span> (err == BN_SUCCESS) {</span><br><span class="line">            err = bn_copy(r, &amp;temp);</span><br><span class="line">        }</span><br><span class="line">        bn_free(&amp;temp);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> result_digs = a-&gt;used_digs + b-&gt;used_digs;</span><br><span class="line">    <span class="type">bn_err_t</span> err = bn_ensure_capacity(r, result_digs);</span><br><span class="line">    <span class="keyword">if</span> (err != BN_SUCCESS) <span class="keyword">return</span> err;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(r-&gt;data, <span class="number">0</span>, r-&gt;capacity * <span class="keyword">sizeof</span>(<span class="type">dig_t</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a-&gt;used_digs; i++) {</span><br><span class="line">        <span class="keyword">if</span> (a-&gt;data[i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="type">uint64_t</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; b-&gt;used_digs; j++) {</span><br><span class="line">            carry += (<span class="type">uint64_t</span>)r-&gt;data[i + j] + (<span class="type">uint64_t</span>)a-&gt;data[i] * b-&gt;data[j];</span><br><span class="line">            r-&gt;data[i + j] = (<span class="type">dig_t</span>)(carry &amp; DIG_MASK);</span><br><span class="line">            carry &gt;&gt;= WBITS;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理最后的进位</span></span><br><span class="line">        <span class="type">int</span> k = i + b-&gt;used_digs;</span><br><span class="line">        <span class="keyword">while</span> (carry &gt; <span class="number">0</span> &amp;&amp; k &lt; result_digs) {</span><br><span class="line">            carry += r-&gt;data[k];</span><br><span class="line">            r-&gt;data[k] = (<span class="type">dig_t</span>)(carry &amp; DIG_MASK);</span><br><span class="line">            carry &gt;&gt;= WBITS;</span><br><span class="line">            k++;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    r-&gt;used_digs = result_digs;</span><br><span class="line">    <span class="keyword">while</span> (r-&gt;used_digs &gt; <span class="number">0</span> &amp;&amp; r-&gt;data[r-&gt;used_digs - <span class="number">1</span>] == <span class="number">0</span>) {</span><br><span class="line">        r-&gt;used_digs--;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>平方运算</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_sqr</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a)</span> {</span><br><span class="line">    <span class="keyword">return</span> bn_mul(r, a, a);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>左移和右移</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_lsh</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">int</span> bits)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!r || !a) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    <span class="keyword">if</span> (bits &lt; <span class="number">0</span>) <span class="keyword">return</span> BN_ERR_INVALID_PARAM;</span><br><span class="line">    <span class="keyword">if</span> (bits == <span class="number">0</span>) <span class="keyword">return</span> bn_copy(r, a);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (r == a) {</span><br><span class="line">        <span class="type">bn_t</span> temp;</span><br><span class="line">        bn_init(&amp;temp, <span class="number">0</span>);</span><br><span class="line">        <span class="type">bn_err_t</span> err = bn_lsh(&amp;temp, a, bits);</span><br><span class="line">        <span class="keyword">if</span> (err == BN_SUCCESS) {</span><br><span class="line">            err = bn_copy(r, &amp;temp);</span><br><span class="line">        }</span><br><span class="line">        bn_free(&amp;temp);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> dig_shift = bits / WBITS;</span><br><span class="line">    <span class="type">int</span> bit_shift = bits % WBITS;</span><br><span class="line">    <span class="type">int</span> result_digs = a-&gt;used_digs + dig_shift + (bit_shift &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">bn_err_t</span> err = bn_ensure_capacity(r, result_digs);</span><br><span class="line">    <span class="keyword">if</span> (err != BN_SUCCESS) <span class="keyword">return</span> err;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(r-&gt;data, <span class="number">0</span>, r-&gt;capacity * <span class="keyword">sizeof</span>(<span class="type">dig_t</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (bit_shift == <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">memcpy</span>(r-&gt;data + dig_shift, a-&gt;data, a-&gt;used_digs * <span class="keyword">sizeof</span>(<span class="type">dig_t</span>));</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="type">uint64_t</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a-&gt;used_digs; i++) {</span><br><span class="line">            <span class="type">uint64_t</span> val = ((<span class="type">uint64_t</span>)a-&gt;data[i] &lt;&lt; bit_shift) | carry;</span><br><span class="line">            r-&gt;data[i + dig_shift] = (<span class="type">dig_t</span>)(val &amp; DIG_MASK);</span><br><span class="line">            carry = val &gt;&gt; WBITS;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) {</span><br><span class="line">            r-&gt;data[a-&gt;used_digs + dig_shift] = (<span class="type">dig_t</span>)carry;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    r-&gt;used_digs = result_digs;</span><br><span class="line">    <span class="keyword">while</span> (r-&gt;used_digs &gt; <span class="number">0</span> &amp;&amp; r-&gt;data[r-&gt;used_digs - <span class="number">1</span>] == <span class="number">0</span>) {</span><br><span class="line">        r-&gt;used_digs--;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_rsh</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">int</span> bits)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!r || !a) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    <span class="keyword">if</span> (bits &lt; <span class="number">0</span>) <span class="keyword">return</span> BN_ERR_INVALID_PARAM;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (bits == <span class="number">0</span>) <span class="keyword">return</span> bn_copy(r, a);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (bn_is_zero(a)) {</span><br><span class="line">        <span class="keyword">return</span> bn_set_zero(r);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> dig_shift = bits / WBITS;</span><br><span class="line">    <span class="type">int</span> bit_shift = bits % WBITS;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (dig_shift &gt;= a-&gt;used_digs) {</span><br><span class="line">        <span class="keyword">return</span> bn_set_zero(r);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (r == a) {</span><br><span class="line">        <span class="type">bn_t</span> temp;</span><br><span class="line">        bn_init(&amp;temp, <span class="number">0</span>);</span><br><span class="line">        <span class="type">bn_err_t</span> err = bn_rsh(&amp;temp, a, bits);</span><br><span class="line">        <span class="keyword">if</span> (err == BN_SUCCESS) {</span><br><span class="line">            err = bn_copy(r, &amp;temp);</span><br><span class="line">        }</span><br><span class="line">        bn_free(&amp;temp);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> max_result_digs = a-&gt;used_digs - dig_shift;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bn_err_t</span> err = bn_ensure_capacity(r, max_result_digs);</span><br><span class="line">    <span class="keyword">if</span> (err != BN_SUCCESS) <span class="keyword">return</span> err;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(r-&gt;data, <span class="number">0</span>, r-&gt;capacity * <span class="keyword">sizeof</span>(<span class="type">dig_t</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (bit_shift == <span class="number">0</span>) {</span><br><span class="line">        <span class="built_in">memcpy</span>(r-&gt;data, a-&gt;data + dig_shift, max_result_digs * <span class="keyword">sizeof</span>(<span class="type">dig_t</span>));</span><br><span class="line">        r-&gt;used_digs = max_result_digs;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// 从最低的有效位置开始处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> src_idx = dig_shift; src_idx &lt; a-&gt;used_digs; src_idx++) {</span><br><span class="line">            <span class="type">int</span> dst_idx = src_idx - dig_shift;</span><br><span class="line">            <span class="comment">// 获取当前字</span></span><br><span class="line">            <span class="type">dig_t</span> current_word = a-&gt;data[src_idx];</span><br><span class="line">            <span class="comment">// 获取下一个（更高）字用于进位</span></span><br><span class="line">            <span class="type">dig_t</span> next_word = (src_idx + <span class="number">1</span> &lt; a-&gt;used_digs) ? a-&gt;data[src_idx + <span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 当前字的低位部分（右移后保留的部分）</span></span><br><span class="line">            <span class="type">dig_t</span> low_part = current_word &gt;&gt; bit_shift;</span><br><span class="line">            <span class="comment">// 下一个字的高位部分（作为进位）需要左移 (WBITS - bit_shift) 位</span></span><br><span class="line">            <span class="type">int</span> carry_shift = WBITS - bit_shift;</span><br><span class="line">            <span class="type">dig_t</span> carry_part = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (carry_shift &lt; WBITS) {  <span class="comment">// 避免移位超过字长</span></span><br><span class="line">                carry_part = next_word &lt;&lt; carry_shift;</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">// 组合结果</span></span><br><span class="line">            r-&gt;data[dst_idx] = low_part | carry_part;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        r-&gt;used_digs = max_result_digs;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (r-&gt;used_digs &gt; <span class="number">0</span> &amp;&amp; r-&gt;data[r-&gt;used_digs - <span class="number">1</span>] == <span class="number">0</span>) {</span><br><span class="line">        r-&gt;used_digs--;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (r-&gt;used_digs == <span class="number">0</span>) {</span><br><span class="line">        r-&gt;used_digs = <span class="number">1</span>;</span><br><span class="line">        r-&gt;data[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>实现了大精度加法，为了加快小精度的速度，添加了对一个dig的特殊操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">dig_t</span> <span class="title function_">bn_add_dig</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">dig_t</span> b)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!r || !a) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) {</span><br><span class="line">        bn_copy(r, a);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (bn_is_zero(a)){</span><br><span class="line">        <span class="keyword">if</span>(!(r-&gt;data)) bn_init(r, <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memset</span>(r-&gt;data, <span class="number">0</span>, r-&gt;capacity * <span class="keyword">sizeof</span>(<span class="type">dig_t</span>));</span><br><span class="line">        r-&gt;data[<span class="number">0</span>] = b;</span><br><span class="line">        r-&gt;used_digs = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">bn_err_t</span> err = bn_ensure_capacity(r, a-&gt;used_digs + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(err != BN_SUCCESS) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(r != a){</span><br><span class="line">        err = bn_copy(r, a);</span><br><span class="line">        <span class="keyword">if</span>(err != BN_SUCCESS) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">uint64_t</span> carry = b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r-&gt;used_digs &amp;&amp; carry &gt; <span class="number">0</span>; i++) {</span><br><span class="line">        carry += r-&gt;data[i];</span><br><span class="line">        r-&gt;data[i] = (<span class="type">dig_t</span>)(carry &amp; DIG_MASK);</span><br><span class="line">        carry &gt;&gt;= WBITS;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) {</span><br><span class="line">        r-&gt;data[r-&gt;used_digs] = (<span class="type">dig_t</span>)carry;</span><br><span class="line">        r-&gt;used_digs++;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (r-&gt;used_digs &gt; <span class="number">0</span> &amp;&amp; r-&gt;data[r-&gt;used_digs - <span class="number">1</span>] == <span class="number">0</span>) {</span><br><span class="line">        r-&gt;used_digs--;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="type">dig_t</span>)carry;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">dig_t</span> <span class="title function_">bn_sub_dig</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">dig_t</span> b)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!r || !a) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a-&gt;used_digs ==<span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( a-&gt;used_digs == <span class="number">1</span> &amp;&amp; a-&gt;data[<span class="number">0</span>] &lt;= b ){</span><br><span class="line">        <span class="keyword">if</span>(a-&gt;data[<span class="number">0</span>] == b) {</span><br><span class="line">            bn_set_zero(r);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) {</span><br><span class="line">        bn_copy(r, a);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(r != a){</span><br><span class="line">        <span class="type">bn_err_t</span> err = bn_copy(r, a);</span><br><span class="line">        <span class="keyword">if</span>(err != BN_SUCCESS) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="type">uint64_t</span> borrow = b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; r-&gt;used_digs &amp;&amp; borrow &gt; <span class="number">0</span>; i++) {</span><br><span class="line">        <span class="keyword">if</span> (r-&gt;data[i] &lt; borrow) {</span><br><span class="line">            r-&gt;data[i] = (<span class="type">dig_t</span>)((<span class="number">1ULL</span> &lt;&lt; WBITS) + r-&gt;data[i] - borrow);</span><br><span class="line">            borrow = <span class="number">1</span>;</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            r-&gt;data[i] -= (<span class="type">dig_t</span>)borrow;</span><br><span class="line">            borrow = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (r-&gt;used_digs &gt; <span class="number">0</span> &amp;&amp; r-&gt;data[r-&gt;used_digs - <span class="number">1</span>] == <span class="number">0</span>) {</span><br><span class="line">        r-&gt;used_digs--;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (<span class="type">dig_t</span>)borrow;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>然后是除法运算，这个主要是针对相差不大的数字</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_div</span><span class="params">(<span class="type">bn_t</span> *q, <span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *b)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!q || !r || !a || !b) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    <span class="keyword">if</span> (bn_is_zero(b)) <span class="keyword">return</span> BN_ERR_INVALID_PARAM;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cmp = bn_cmp(a, b);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) {</span><br><span class="line">        bn_set_zero(q);</span><br><span class="line">        bn_copy(r, a);</span><br><span class="line">        <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="number">0</span>) {</span><br><span class="line">        bn_set_one(q);</span><br><span class="line">        bn_set_zero(r);</span><br><span class="line">        <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="type">bn_t</span> a1, q1, temp;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cap = a-&gt;capacity + <span class="number">1</span>;</span><br><span class="line">    bn_init(&amp;a1, cap);</span><br><span class="line">    bn_init(&amp;q1, cap);</span><br><span class="line">    bn_init(&amp;temp, cap);</span><br><span class="line">    </span><br><span class="line">    bn_copy(&amp;a1, a);</span><br><span class="line">    bn_set_zero(q);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> b_bits = bn_get_bits(b);</span><br><span class="line">    <span class="keyword">while</span> (bn_cmp(&amp;a1, b) &gt;= <span class="number">0</span>) {</span><br><span class="line">        bn_set_one(&amp;q1);</span><br><span class="line">        <span class="type">int</span> shift = bn_get_bits(&amp;a1) - b_bits;</span><br><span class="line">        <span class="keyword">while</span> (shift &gt;= <span class="number">0</span>) {</span><br><span class="line">            bn_lsh(&amp;temp, b, shift);</span><br><span class="line">            <span class="keyword">if</span> (bn_cmp(&amp;temp, &amp;a1) &lt;= <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            shift--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(shift &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        bn_lsh(&amp;q1, &amp;q1, shift);</span><br><span class="line">        bn_add(q, q, &amp;q1);</span><br><span class="line"></span><br><span class="line">        bn_sub(&amp;a1, &amp;a1, &amp;temp);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// while (bn_cmp(&amp;a1, b) &gt;= 0) {		// 相差比较大的时候开销就很大了</span></span><br><span class="line">    <span class="comment">//     bn_set_one(&amp;q1);</span></span><br><span class="line">    <span class="comment">//     int shift = 0;</span></span><br><span class="line">    <span class="comment">//     while (1) {</span></span><br><span class="line">    <span class="comment">//         bn_lsh(&amp;temp, b, shift+1);</span></span><br><span class="line">    <span class="comment">//         if (bn_cmp(&amp;temp, &amp;a1) &gt; 0) {</span></span><br><span class="line">    <span class="comment">//             break;</span></span><br><span class="line">    <span class="comment">//         }</span></span><br><span class="line">    <span class="comment">//         shift++;</span></span><br><span class="line">    <span class="comment">//     }</span></span><br><span class="line">    <span class="comment">//     bn_lsh(&amp;q1, &amp;q1, shift);</span></span><br><span class="line">    <span class="comment">//     bn_add(q, q, &amp;q1);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//     bn_rsh(r, &amp;temp, 1);</span></span><br><span class="line">    <span class="comment">//     bn_sub(&amp;a1, &amp;a1, r);</span></span><br><span class="line">    <span class="comment">// }</span></span><br><span class="line"></span><br><span class="line">    bn_copy(r, &amp;a1);</span><br><span class="line"></span><br><span class="line">    bn_free(&amp;a1);</span><br><span class="line">    bn_free(&amp;q1);</span><br><span class="line">    bn_free(&amp;temp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>还有取模运算</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_mod</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *m)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!r || !a || !m) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    <span class="keyword">if</span> (bn_is_zero(m)) <span class="keyword">return</span> BN_ERR_INVALID_PARAM;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cmp = bn_cmp(a, m);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>) {</span><br><span class="line">        bn_copy(r, a);</span><br><span class="line">        <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (cmp == <span class="number">0</span>) {</span><br><span class="line">        bn_set_zero(r);</span><br><span class="line">        <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r == a || r == m){</span><br><span class="line">        <span class="type">bn_t</span> temp;</span><br><span class="line">        bn_init(&amp;temp, a-&gt;used_digs);</span><br><span class="line">        <span class="type">bn_err_t</span> err = bn_mod(&amp;temp, a, m);</span><br><span class="line">        <span class="keyword">if</span> (err == BN_SUCCESS) {</span><br><span class="line">            err = bn_copy(r, &amp;temp);</span><br><span class="line">        }</span><br><span class="line">        bn_free(&amp;temp);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">bn_t</span> a1, temp;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> cap = a-&gt;capacity + <span class="number">1</span>;</span><br><span class="line">    bn_init(&amp;a1, cap);</span><br><span class="line">    bn_init(&amp;temp, cap);</span><br><span class="line">    </span><br><span class="line">    bn_copy(&amp;a1, a);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> m_bits = bn_get_bits(m);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (bn_cmp(&amp;a1, m) &gt;= <span class="number">0</span>) {</span><br><span class="line">        <span class="type">int</span> a1_bits = bn_get_bits(&amp;a1);</span><br><span class="line">        <span class="type">int</span> shift = a1_bits - m_bits;</span><br><span class="line">        <span class="keyword">while</span> (shift &gt;= <span class="number">0</span>) {</span><br><span class="line">            bn_lsh(&amp;temp, m, shift);</span><br><span class="line">            <span class="keyword">if</span> (bn_cmp(&amp;temp, &amp;a1) &lt;= <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            shift--;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span>(shift &lt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        bn_sub(&amp;a1, &amp;a1, &amp;temp);</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// while (bn_cmp(&amp;a1, m) &gt;= 0) {	// 一样是改进了这个</span></span><br><span class="line">    <span class="comment">//     bn_set_one(&amp;q1);</span></span><br><span class="line">    <span class="comment">//     int shift = 0;</span></span><br><span class="line">    <span class="comment">//     while (1) {</span></span><br><span class="line">    <span class="comment">//         bn_lsh(&amp;temp, m, shift+1);</span></span><br><span class="line">    <span class="comment">//         if (bn_cmp(&amp;temp, &amp;a1) &gt; 0) {</span></span><br><span class="line">    <span class="comment">//             break;</span></span><br><span class="line">    <span class="comment">//         }</span></span><br><span class="line">    <span class="comment">//         shift++;</span></span><br><span class="line">    <span class="comment">//     }</span></span><br><span class="line">    <span class="comment">//     bn_rsh(r, &amp;temp, 1);</span></span><br><span class="line">    <span class="comment">//     bn_sub(&amp;a1, &amp;a1, r);</span></span><br><span class="line">    <span class="comment">// }</span></span><br><span class="line">    bn_copy(r, &amp;a1);</span><br><span class="line"></span><br><span class="line">    bn_free(&amp;a1);</span><br><span class="line">    bn_free(&amp;temp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">    <span class="comment">// bn_t q;</span></span><br><span class="line">    <span class="comment">// bn_init(&amp;q, a-&gt;capacity);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// bn_err_t err = bn_div(&amp;q, r, a, m);</span></span><br><span class="line">    <span class="comment">// bn_free(&amp;q);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//return err;</span></span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h4 id="模运算">模运算</h4>
<p>一般的模加、模减、模乘</p>
<p>这里我没使用<code>bn_mod</code>是因为数比较接近，使用<code>bn_mod</code>的时间开销大，于是便使用了时间开销更小的<code>bn_sub</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_mod_add</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *b, <span class="type">const</span> <span class="type">bn_t</span> *m)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!r || !a || !b || !m) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    <span class="keyword">if</span> (bn_is_zero(m)) <span class="keyword">return</span> BN_ERR_INVALID_PARAM;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (bn_is_zero(a)) <span class="keyword">return</span> bn_mod_sub(r, b, a, m);</span><br><span class="line">    <span class="keyword">if</span> (bn_is_zero(b)) <span class="keyword">return</span> bn_mod_sub(r, a, b, m);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="type">bn_t</span> sum;</span><br><span class="line">    <span class="type">int</span> max_capacity = (a-&gt;used_digs &gt; b-&gt;used_digs ? a-&gt;used_digs : b-&gt;used_digs) + <span class="number">1</span>;</span><br><span class="line">    bn_init(&amp;sum, max_capacity);</span><br><span class="line">    </span><br><span class="line">    <span class="type">bn_err_t</span> err = bn_add(&amp;sum, a, b);</span><br><span class="line">    <span class="keyword">if</span> (err != BN_SUCCESS) {</span><br><span class="line">        bn_free(&amp;sum);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//bn_mod(&amp;sum,&amp;sum,m);</span></span><br><span class="line">    <span class="keyword">while</span> (bn_cmp(&amp;sum, m) &gt;= <span class="number">0</span>) {</span><br><span class="line">        err = bn_sub(&amp;sum, &amp;sum, m);</span><br><span class="line">        <span class="keyword">if</span> (err != BN_SUCCESS) {</span><br><span class="line">            bn_free(&amp;sum);</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (r != &amp;sum) {</span><br><span class="line">        err = bn_copy(r, &amp;sum);</span><br><span class="line">    }</span><br><span class="line">    bn_free(&amp;sum);</span><br><span class="line">    <span class="keyword">return</span> err ? err : BN_SUCCESS;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_mod_sub</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *b, <span class="type">const</span> <span class="type">bn_t</span> *m)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!r || !a || !b || !m) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    <span class="keyword">if</span> (bn_is_zero(m)) <span class="keyword">return</span> BN_ERR_INVALID_PARAM;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bn_t</span> a_mod, b_mod;</span><br><span class="line">    bn_init(&amp;a_mod, m-&gt;used_digs);</span><br><span class="line">    bn_init(&amp;b_mod, m-&gt;used_digs);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//bn_mod(&amp;a_mod, a, m);</span></span><br><span class="line">    bn_copy(&amp;a_mod,a);</span><br><span class="line">    <span class="keyword">while</span>(bn_cmp(a,m)&gt;=<span class="number">0</span>){</span><br><span class="line">        bn_sub(&amp;a_mod,&amp;a_mod,m);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bn_mod(&amp;b_mod, b, m);</span></span><br><span class="line">    bn_copy(&amp;b_mod,b);</span><br><span class="line">    <span class="keyword">while</span>(bn_cmp(b,m)&gt;=<span class="number">0</span>){</span><br><span class="line">        bn_sub(&amp;b_mod,&amp;b_mod,m);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cmp = bn_cmp(&amp;a_mod, &amp;b_mod);</span><br><span class="line">    <span class="keyword">if</span> (cmp &gt;= <span class="number">0</span>) {</span><br><span class="line">        bn_sub(r, &amp;a_mod, &amp;b_mod);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="type">bn_t</span> temp;</span><br><span class="line">        bn_init(&amp;temp, m-&gt;used_digs);</span><br><span class="line">        bn_sub(&amp;temp, m, &amp;b_mod);</span><br><span class="line">        bn_add(r, &amp;a_mod, &amp;temp);</span><br><span class="line">        </span><br><span class="line">        bn_free(&amp;temp);</span><br><span class="line">        <span class="keyword">if</span> (bn_cmp(r, m) &gt;= <span class="number">0</span>) {</span><br><span class="line">            bn_sub(r, r, m);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    bn_free(&amp;a_mod);</span><br><span class="line">    bn_free(&amp;b_mod);</span><br><span class="line">    <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_mod_mul</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *b, <span class="type">const</span> <span class="type">bn_t</span> *m)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!r || !a || !b || !m) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    <span class="keyword">if</span> (bn_is_zero(m)) <span class="keyword">return</span> BN_ERR_INVALID_PARAM;</span><br><span class="line">    <span class="keyword">if</span> (bn_is_even(m)) <span class="keyword">return</span> BN_ERR_MODULUS_EVEN;</span><br><span class="line">    <span class="type">bn_t</span> temp;</span><br><span class="line">    <span class="type">bn_err_t</span> err = bn_init(&amp;temp,a-&gt;capacity+b-&gt;used_digs);</span><br><span class="line">    <span class="keyword">if</span>(err!=BN_SUCCESS) <span class="keyword">return</span> BN_ERR_MEMORY;</span><br><span class="line">    bn_mul(&amp;temp,a,b);</span><br><span class="line">    <span class="keyword">if</span>(err!=BN_SUCCESS) <span class="keyword">return</span> BN_ERR_INVALID_PARAM;</span><br><span class="line">    bn_mod(r,&amp;temp,m);</span><br><span class="line">    <span class="keyword">if</span>(err!=BN_SUCCESS) <span class="keyword">return</span> BN_ERR_INVALID_PARAM;</span><br><span class="line">    bn_free(&amp;temp);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_mod_sqr</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *m)</span> {</span><br><span class="line">    <span class="keyword">return</span> bn_mod_mul(r, a, a, m);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_mod_exp</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *e, <span class="type">const</span> <span class="type">bn_t</span> *m)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!r || !a || !e || !m) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    <span class="keyword">if</span> (bn_is_zero(m)) <span class="keyword">return</span> BN_ERR_INVALID_PARAM;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (bn_is_zero(e)) {</span><br><span class="line">        <span class="keyword">return</span> bn_set_one(r);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span> (bn_is_one(e)) {</span><br><span class="line">        <span class="type">bn_t</span> one;</span><br><span class="line">        bn_init(&amp;one, <span class="number">0</span>);</span><br><span class="line">        bn_set_one(&amp;one);</span><br><span class="line">        <span class="type">bn_err_t</span> err = bn_mod_mul_mont(r, a, &amp;one, m);</span><br><span class="line">        bn_free(&amp;one);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">bn_t</span> result, base, <span class="built_in">exp</span>;</span><br><span class="line">    bn_init(&amp;result, <span class="number">0</span>);</span><br><span class="line">    bn_init(&amp;base, <span class="number">0</span>);</span><br><span class="line">    bn_init(&amp;<span class="built_in">exp</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">bn_err_t</span> err = bn_copy(&amp;base, a);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> cleanup;</span><br><span class="line">    err = bn_copy(&amp;<span class="built_in">exp</span>, e);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> cleanup;</span><br><span class="line">    bn_set_one(&amp;result);</span><br><span class="line">    <span class="keyword">while</span> (!bn_is_zero(&amp;<span class="built_in">exp</span>)) {</span><br><span class="line">        <span class="keyword">if</span> (bn_is_even(&amp;<span class="built_in">exp</span>)) {</span><br><span class="line">            <span class="type">bn_t</span> temp;</span><br><span class="line">            bn_init(&amp;temp, <span class="number">0</span>);</span><br><span class="line">            err = bn_mod_mul(&amp;temp, &amp;base, &amp;base, m);</span><br><span class="line">            <span class="keyword">if</span> (err) {</span><br><span class="line">                bn_free(&amp;temp);</span><br><span class="line">                <span class="keyword">goto</span> cleanup;</span><br><span class="line">            }</span><br><span class="line">            bn_copy(&amp;base, &amp;temp);</span><br><span class="line">            bn_free(&amp;temp);</span><br><span class="line">            </span><br><span class="line">            bn_rsh(&amp;<span class="built_in">exp</span>, &amp;<span class="built_in">exp</span>, <span class="number">1</span>);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            <span class="type">bn_t</span> temp;</span><br><span class="line">            bn_init(&amp;temp, <span class="number">0</span>);</span><br><span class="line">            err = bn_mod_mul(&amp;temp, &amp;result, &amp;base, m);</span><br><span class="line">            <span class="keyword">if</span> (err) {</span><br><span class="line">                bn_free(&amp;temp);</span><br><span class="line">                <span class="keyword">goto</span> cleanup;</span><br><span class="line">            }</span><br><span class="line">            bn_copy(&amp;result, &amp;temp);</span><br><span class="line">            bn_free(&amp;temp);</span><br><span class="line">            </span><br><span class="line">            <span class="type">bn_t</span> one;</span><br><span class="line">            bn_init(&amp;one, <span class="number">0</span>);</span><br><span class="line">            bn_set_one(&amp;one);</span><br><span class="line">            err = bn_sub(&amp;<span class="built_in">exp</span>, &amp;<span class="built_in">exp</span>, &amp;one);</span><br><span class="line">            bn_free(&amp;one);</span><br><span class="line">            <span class="keyword">if</span> (err) <span class="keyword">goto</span> cleanup;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    err = bn_copy(r, &amp;result);</span><br><span class="line">cleanup:</span><br><span class="line">    bn_free(&amp;result);</span><br><span class="line">    bn_free(&amp;base);</span><br><span class="line">    bn_free(&amp;<span class="built_in">exp</span>);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>还有模折半</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_mod_hlv</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *m)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!r || !a || !m) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    <span class="keyword">if</span> (bn_is_zero(m)) <span class="keyword">return</span> BN_ERR_INVALID_PARAM;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bn_t</span> a_reduced;</span><br><span class="line">    bn_init(&amp;a_reduced, a-&gt;used_digs);</span><br><span class="line">    bn_copy(&amp;a_reduced, a);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// while (bn_cmp(&amp;a_reduced, m) &gt;= 0) {</span></span><br><span class="line">    <span class="comment">//     bn_sub(&amp;a_reduced, &amp;a_reduced, m);</span></span><br><span class="line">    <span class="comment">// }</span></span><br><span class="line"></span><br><span class="line">    bn_mod(&amp;a_reduced, a, m);</span><br><span class="line">    <span class="type">bn_err_t</span> err;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (bn_is_even(&amp;a_reduced)) {</span><br><span class="line">        err = bn_rsh(r, &amp;a_reduced, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (err != BN_SUCCESS) {</span><br><span class="line">            bn_free(&amp;a_reduced);</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="type">bn_t</span> sum;</span><br><span class="line">        bn_init(&amp;sum, (a_reduced.used_digs &gt; m-&gt;used_digs ? </span><br><span class="line">                      a_reduced.used_digs : m-&gt;used_digs) + <span class="number">1</span>);</span><br><span class="line">        err = bn_add(&amp;sum, &amp;a_reduced, m);</span><br><span class="line">        <span class="keyword">if</span> (err != BN_SUCCESS) {</span><br><span class="line">            bn_free(&amp;a_reduced);</span><br><span class="line">            bn_free(&amp;sum);</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        }</span><br><span class="line">        err = bn_rsh(r, &amp;sum, <span class="number">1</span>);</span><br><span class="line">        bn_free(&amp;sum);</span><br><span class="line">        <span class="keyword">if</span> (err != BN_SUCCESS) {</span><br><span class="line">            bn_free(&amp;a_reduced);</span><br><span class="line">            <span class="keyword">return</span> err;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    bn_free(&amp;a_reduced);</span><br><span class="line">    <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">}</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="进阶模运算">进阶模运算</h4>
<p>求逆元是模运算中比较常用的</p>
<p>有拓展欧几里得算法，但是这个好像在我的大整数运算中开销特别大，于是后来我改进成了牛顿迭代法，毕竟完成的模乘和模幂等等只需要求<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: 0;" xmlns="http://www.w3.org/2000/svg" width="2.152ex" height="1.932ex" role="img" focusable="false" viewBox="0 -853.7 951.4 853.7"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mi" transform="translate(533,363) scale(0.707)"><path data-c="1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path></g></g><g data-mml-node="mspace" transform="translate(951.4,0)"></g></g></g></svg></mjx-container></span>的逆元，使用牛顿迭代法特别快</p>
<p>首先是拓展欧几里得算法，因为我还没实现负数的运算，只能使用返回错误码来判断回溯是两个值的正负性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   BN_SUCCESS = <span class="number">0</span>,</span><br><span class="line">BN_ERR_ALL_NEGATIVE_RESULT = <span class="number">-10</span>,</span><br><span class="line">   BN_ERR_FIRST_NEGATIVE_RESULT = <span class="number">-11</span>,</span><br><span class="line">   BN_ERR_SECOND_NEGATIVE_RESULT = <span class="number">-12</span>,</span><br></pre></td></tr></table></figure>
<p>也算是比较巧思了吧</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">extended_gcd</span><span class="params">(<span class="type">bn_t</span> *gcd, <span class="type">bn_t</span> *x, <span class="type">bn_t</span> *y, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *b)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!gcd || !x || !y || !a || !b) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bn_is_zero(b)) {</span><br><span class="line">        bn_copy(gcd, a);</span><br><span class="line">        bn_set_one(x);</span><br><span class="line">        bn_set_zero(y);</span><br><span class="line">        <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="type">bn_t</span> q, r, x1, y1, product, temp;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cap = a-&gt;capacity &gt; b-&gt;capacity ? a-&gt;capacity : b-&gt;capacity;</span><br><span class="line">    cap += <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    bn_init(&amp;q, cap);</span><br><span class="line">    bn_init(&amp;r, cap);</span><br><span class="line">    bn_init(&amp;x1, cap);</span><br><span class="line">    bn_init(&amp;y1, cap);</span><br><span class="line">    bn_init(&amp;product, cap);</span><br><span class="line">    bn_init(&amp;temp, cap);</span><br><span class="line">    bn_set_zero(&amp;x1);</span><br><span class="line">    bn_set_zero(&amp;y1);</span><br><span class="line">    bn_set_zero(&amp;q);</span><br><span class="line">    bn_set_zero(&amp;r);</span><br><span class="line">    bn_div(&amp;q, &amp;r, a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="type">bn_err_t</span> err = extended_gcd(gcd, &amp;x1, &amp;y1, b, &amp;r);</span><br><span class="line"></span><br><span class="line">    bn_copy(x, &amp;y1);</span><br><span class="line">    bn_mul(&amp;product, &amp;q, &amp;y1);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// printf("err before %d ",err);</span></span><br><span class="line">    <span class="keyword">if</span>(err == BN_ERR_FIRST_NEGATIVE_RESULT){</span><br><span class="line">        bn_add(y,&amp;product,&amp;x1);</span><br><span class="line">        err=BN_ERR_SECOND_NEGATIVE_RESULT;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(err == BN_ERR_SECOND_NEGATIVE_RESULT){</span><br><span class="line">        bn_add(y,&amp;product,&amp;x1);</span><br><span class="line">        err = BN_ERR_FIRST_NEGATIVE_RESULT;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(err == BN_SUCCESS){</span><br><span class="line">        <span class="keyword">if</span>(bn_cmp(&amp;x1, &amp;product) &gt;= <span class="number">0</span>){</span><br><span class="line">            bn_sub(y, &amp;x1, &amp;product);</span><br><span class="line">            err = BN_SUCCESS;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            bn_sub(y, &amp;product, &amp;x1);</span><br><span class="line">            err = BN_ERR_SECOND_NEGATIVE_RESULT;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">if</span>(bn_cmp(&amp;x1, &amp;product) &lt;= <span class="number">0</span>){</span><br><span class="line">            bn_sub(y, &amp;product, &amp;x1);</span><br><span class="line">            err = BN_ERR_FIRST_NEGATIVE_RESULT;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            bn_sub(y, &amp;x1, &amp;product);</span><br><span class="line">            err = BN_ERR_ALL_NEGATIVE_RESULT;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">// printf("err after %d ",err);</span></span><br><span class="line">    <span class="comment">// bn_print(&amp;x1,"x1 ");</span></span><br><span class="line">    <span class="comment">// bn_print(&amp;y1,"y1 ");</span></span><br><span class="line">    <span class="comment">// bn_print(&amp;q,"q ");</span></span><br><span class="line">    <span class="comment">// bn_print(&amp;r,"r ");</span></span><br><span class="line">    <span class="comment">// bn_print(&amp;product,"product ");</span></span><br><span class="line"></span><br><span class="line">    bn_free(&amp;q);</span><br><span class="line">    bn_free(&amp;r);</span><br><span class="line">    bn_free(&amp;x1);</span><br><span class="line">    bn_free(&amp;y1);</span><br><span class="line">    bn_free(&amp;product);</span><br><span class="line">    bn_free(&amp;temp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_mod_inv</span><span class="params">(<span class="type">bn_t</span> *inv, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *m)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!inv || !a || !m) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    <span class="keyword">if</span> (bn_is_zero(m) || bn_is_zero(a)) <span class="keyword">return</span> BN_ERR_INVALID_PARAM;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="type">bn_t</span> a_mod_m;</span><br><span class="line">    bn_init(&amp;a_mod_m, m-&gt;capacity + <span class="number">1</span>);</span><br><span class="line">    bn_mod(&amp;a_mod_m, a, m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (bn_is_zero(&amp;a_mod_m)) {</span><br><span class="line">        bn_free(&amp;a_mod_m);</span><br><span class="line">        <span class="keyword">return</span> BN_ERR_NO_INVERSE;</span><br><span class="line">    }</span><br><span class="line">    <span class="type">int</span> cap = m-&gt;capacity + <span class="number">2</span>;</span><br><span class="line">    <span class="type">bn_t</span> one;</span><br><span class="line">    bn_init(&amp;one, cap);</span><br><span class="line">    bn_set_one(&amp;one);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (bn_cmp(&amp;a_mod_m, &amp;one) == <span class="number">0</span>) {</span><br><span class="line">        bn_copy(inv, &amp;one);</span><br><span class="line">        bn_free(&amp;one);</span><br><span class="line">        bn_free(&amp;a_mod_m);</span><br><span class="line">        <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="type">bn_t</span> gcd, x, y;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    bn_init(&amp;gcd, cap);</span><br><span class="line">    bn_init(&amp;x, cap);</span><br><span class="line">    bn_init(&amp;y, cap);</span><br><span class="line">    bn_set_zero(&amp;gcd);</span><br><span class="line">    bn_set_zero(&amp;x);</span><br><span class="line">    bn_set_zero(&amp;y);</span><br><span class="line">    </span><br><span class="line">    <span class="type">bn_err_t</span> err = extended_gcd(&amp;gcd, &amp;x, &amp;y, &amp;a_mod_m, m);</span><br><span class="line">    <span class="keyword">if</span>(bn_cmp(&amp;gcd,&amp;one)!=<span class="number">0</span>){</span><br><span class="line">        err = BN_ERR_NO_INVERSE;</span><br><span class="line">        <span class="keyword">goto</span> cleanup_all;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="type">bn_t</span> temp1;</span><br><span class="line">    bn_init(&amp;temp1,cap);</span><br><span class="line">    bn_set_zero(&amp;temp1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(err==BN_ERR_FIRST_NEGATIVE_RESULT || err == BN_ERR_ALL_NEGATIVE_RESULT){</span><br><span class="line">        bn_sub(inv,m,&amp;x);</span><br><span class="line">        err = BN_SUCCESS;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        bn_copy(inv,&amp;x);</span><br><span class="line">        err = BN_SUCCESS;</span><br><span class="line">    }</span><br><span class="line">    bn_free(&amp;temp1);</span><br><span class="line">    </span><br><span class="line">cleanup_all:</span><br><span class="line">    bn_free(&amp;gcd);</span><br><span class="line">    bn_free(&amp;x);</span><br><span class="line">    bn_free(&amp;y);</span><br><span class="line">    bn_free(&amp;one);</span><br><span class="line">    bn_free(&amp;a_mod_m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>牛顿迭代法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_mod_inv_usedNewton</span><span class="params">(<span class="type">bn_t</span> *inv, <span class="type">const</span> <span class="type">bn_t</span> *N, <span class="type">const</span> <span class="type">bn_t</span> *R, <span class="type">const</span> <span class="type">int</span> k)</span>{</span><br><span class="line">    <span class="keyword">if</span> (!inv || !N || !R) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    <span class="keyword">if</span> (bn_is_zero(N) || bn_is_zero(R)) <span class="keyword">return</span> BN_ERR_INVALID_PARAM;</span><br><span class="line">    <span class="type">bn_t</span> inv_0, <span class="type">temp_t</span>, one, two, temp_1;</span><br><span class="line">    bn_init(&amp;inv_0, <span class="number">2</span>*R-&gt;used_digs);</span><br><span class="line">    bn_init(&amp;<span class="type">temp_t</span>, <span class="number">2</span>*R-&gt;used_digs);</span><br><span class="line">    bn_init(&amp;temp_1, <span class="number">2</span>*R-&gt;used_digs);</span><br><span class="line">    bn_init(&amp;one, <span class="number">1</span>);</span><br><span class="line">    bn_init(&amp;two, <span class="number">1</span>);</span><br><span class="line">    bn_set_one(&amp;one);</span><br><span class="line">    bn_set_one(&amp;inv_0);</span><br><span class="line">    bn_set_one(&amp;<span class="type">temp_t</span>);</span><br><span class="line">    bn_set_zero(&amp;temp_1);</span><br><span class="line">    (&amp;two)-&gt;data[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">    (&amp;two)-&gt;used_digs = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i&lt;k ;i &lt;&lt;= <span class="number">1</span>){</span><br><span class="line">        bn_mul(&amp;<span class="type">temp_t</span>, N, &amp;inv_0);</span><br><span class="line">        <span class="keyword">if</span>(bn_cmp(&amp;two,&amp;<span class="type">temp_t</span>)&gt;=<span class="number">0</span>){</span><br><span class="line">            bn_sub(&amp;<span class="type">temp_t</span>,&amp;two, &amp;<span class="type">temp_t</span>);</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            bn_sub(&amp;<span class="type">temp_t</span>,&amp;<span class="type">temp_t</span>,&amp;two);</span><br><span class="line">            bn_truncate_bits(&amp;<span class="type">temp_t</span>, MIN(k, <span class="number">2</span>*i));</span><br><span class="line">            bn_lsh(&amp;temp_1, &amp;one, MIN(k,<span class="number">2</span>*i));</span><br><span class="line">            bn_sub(&amp;<span class="type">temp_t</span>,&amp;temp_1, &amp;<span class="type">temp_t</span>);</span><br><span class="line">        }</span><br><span class="line">        bn_mul(&amp;inv_0, &amp;inv_0, &amp;<span class="type">temp_t</span>);</span><br><span class="line">        bn_truncate_bits(&amp;inv_0, MIN(k, <span class="number">2</span>*i));</span><br><span class="line">    }</span><br><span class="line">    bn_copy(inv,&amp;inv_0);</span><br><span class="line">    bn_free(&amp;inv_0);</span><br><span class="line">    bn_free(&amp;temp_1);</span><br><span class="line">    bn_free(&amp;<span class="type">temp_t</span>);</span><br><span class="line">    bn_free(&amp;two);</span><br><span class="line">    bn_free(&amp;one);</span><br><span class="line">    <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<h5 id="蒙哥马利算法">蒙哥马利算法</h5>
<p>使用一个结构体储存我们预计算的蒙哥马利上下文</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">mont_ctx_init</span><span class="params">(<span class="type">mont_ctx_t</span> *ctx, <span class="type">const</span> <span class="type">bn_t</span> *N)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!ctx || !N) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    <span class="keyword">if</span> (bn_is_even(N)) <span class="keyword">return</span> BN_ERR_MODULUS_EVEN;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(ctx, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">mont_ctx_t</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="type">bn_err_t</span> err = bn_copy(&amp;ctx-&gt;N, N);</span><br><span class="line">    <span class="keyword">if</span> (err != BN_SUCCESS) <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    ctx-&gt;k = bn_get_bits(N);</span><br><span class="line">    ctx-&gt;k_digs = (ctx-&gt;k + WBITS - <span class="number">1</span>) / WBITS;</span><br><span class="line">    </span><br><span class="line">    err = mont_compute_R(&amp;ctx-&gt;R, N, &amp;ctx-&gt;k);</span><br><span class="line">    <span class="keyword">if</span> (err != BN_SUCCESS) {</span><br><span class="line">        bn_free(&amp;ctx-&gt;N);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    err = mont_compute_N_prime(&amp;ctx-&gt;N_prime, N, &amp;ctx-&gt;R);</span><br><span class="line">    <span class="keyword">if</span> (err != BN_SUCCESS) {</span><br><span class="line">        bn_free(&amp;ctx-&gt;N);</span><br><span class="line">        bn_free(&amp;ctx-&gt;R);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="type">bn_t</span> R2_pre;</span><br><span class="line">    bn_init(&amp;R2_pre, (ctx-&gt;k_digs)*<span class="number">2</span>);</span><br><span class="line">    bn_mul(&amp;R2_pre, &amp;ctx-&gt;R, &amp;ctx-&gt;R);</span><br><span class="line">    err = bn_mod(&amp;ctx-&gt;R2, &amp;R2_pre, N);</span><br><span class="line">    bn_free(&amp;R2_pre);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != BN_SUCCESS) {</span><br><span class="line">        bn_free(&amp;ctx-&gt;N);</span><br><span class="line">        bn_free(&amp;ctx-&gt;R);</span><br><span class="line">        bn_free(&amp;ctx-&gt;N_prime);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> BN_SUCCESS;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mont_ctx_free</span><span class="params">(<span class="type">mont_ctx_t</span> *ctx)</span> {</span><br><span class="line">    <span class="keyword">if</span> (ctx) {</span><br><span class="line">        bn_free(&amp;ctx-&gt;N);</span><br><span class="line">        bn_free(&amp;ctx-&gt;R);</span><br><span class="line">        bn_free(&amp;ctx-&gt;N_prime);</span><br><span class="line">        bn_free(&amp;ctx-&gt;R2);</span><br><span class="line">        <span class="built_in">memset</span>(ctx, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="type">mont_ctx_t</span>));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">mont_ctx_compute</span><span class="params">(<span class="type">mont_ctx_t</span> *ctx, <span class="type">const</span> <span class="type">bn_t</span> *N)</span> {</span><br><span class="line">    mont_ctx_free(ctx);</span><br><span class="line">    <span class="keyword">return</span> mont_ctx_init(ctx, N);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>首先是计算我们的<code>R</code>的位数，使用<code>bn_get_bits</code>就可以了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">mont_compute_R</span><span class="params">(<span class="type">bn_t</span> *R, <span class="type">const</span> <span class="type">bn_t</span> *N, <span class="type">int</span> *k)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!R || !N) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    </span><br><span class="line">    *k = bn_get_bits(N);</span><br><span class="line">    <span class="type">bn_err_t</span> err = bn_set_one(R);</span><br><span class="line">    <span class="keyword">if</span> (err != BN_SUCCESS) <span class="keyword">return</span> err;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> bn_lsh(R, R, *k);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>然后是构造我们的<code>R</code>，使用<code>bn_set_bit</code>设置我们上面得到的位为<code>1</code></p>
<p>然后是另一个很重要的参数 <span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.186ex;" xmlns="http://www.w3.org/2000/svg" width="22.814ex" height="2.016ex" role="img" focusable="false" viewBox="0 -809 10083.7 891"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mi" transform="translate(975.3,413) scale(0.707)"><path data-c="2032" d="M79 43Q73 43 52 49T30 61Q30 68 85 293T146 528Q161 560 198 560Q218 560 240 545T262 501Q262 496 260 486Q259 479 173 263T84 45T79 43Z"></path></g></g><g data-mml-node="mo" transform="translate(1441.9,0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"></path></g><g data-mml-node="mi" transform="translate(1942.1,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mo" transform="translate(3107.9,0)"><path data-c="2261" d="M56 444Q56 457 70 464H707Q722 456 722 444Q722 430 706 424H72Q56 429 56 444ZM56 237T56 250T70 270H707Q722 262 722 250T707 230H70Q56 237 56 250ZM56 56Q56 71 72 76H706Q722 70 722 56Q722 44 707 36H70Q56 43 56 56Z"></path></g><g data-mml-node="mo" transform="translate(4163.7,0)"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(4941.7,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g><g data-mml-node="mstyle" transform="translate(5441.7,0)"><g data-mml-node="mspace"></g></g><g data-mml-node="mi" transform="translate(6441.7,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(7319.7,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(7804.7,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mstyle" transform="translate(8324.7,0)"><g data-mml-node="mspace"></g></g><g data-mml-node="mi" transform="translate(9324.7,0)"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mspace" transform="translate(10083.7,0)"></g></g></g></svg></mjx-container></span> 先计算出逆元再相减</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">mont_compute_N_prime</span><span class="params">(<span class="type">bn_t</span> *N_prime, <span class="type">const</span> <span class="type">bn_t</span> *N, <span class="type">const</span> <span class="type">bn_t</span> *R)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!N_prime || !N || !R) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = bn_get_bits(N);</span><br><span class="line">    <span class="type">int</span> k_digs = (k + WBITS - <span class="number">1</span>) / WBITS;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bn_t</span> inv;</span><br><span class="line">    bn_init(&amp;inv, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">bn_err_t</span> err = bn_mod_inv_usedNewton(&amp;inv, N, R, k);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> cleanup;</span><br><span class="line">    </span><br><span class="line">    err = bn_sub(N_prime, R, &amp;inv);</span><br><span class="line"></span><br><span class="line">cleanup:</span><br><span class="line">    bn_free(&amp;inv);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p><code>R2</code>就是<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.048ex;" xmlns="http://www.w3.org/2000/svg" width="18.444ex" height="1.934ex" role="img" focusable="false" viewBox="0 -833.9 8152.1 854.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"></path></g><g data-mml-node="mo" transform="translate(1129.8,0)"><path data-c="2261" d="M56 444Q56 457 70 464H707Q722 456 722 444Q722 430 706 424H72Q56 429 56 444ZM56 237T56 250T70 270H707Q722 262 722 250T707 230H70Q56 237 56 250ZM56 56Q56 71 72 76H706Q722 70 722 56Q722 44 707 36H70Q56 43 56 56Z"></path></g><g data-mml-node="msup" transform="translate(2185.6,0)"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="mn" transform="translate(792,363) scale(0.707)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g><g data-mml-node="mstyle" transform="translate(3381.1,0)"><g data-mml-node="mspace"></g></g><g data-mml-node="mi" transform="translate(4381.1,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(5259.1,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(5744.1,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mstyle" transform="translate(6264.1,0)"><g data-mml-node="mspace"></g></g><g data-mml-node="mi" transform="translate(7264.1,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mspace" transform="translate(8152.1,0)"></g></g></g></svg></mjx-container></span>，便于我们进行蒙哥马利域转换</p>
<p>转换为蒙哥马利形式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">mont_map</span><span class="params">(<span class="type">bn_t</span> *a_mont, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">mont_ctx_t</span> *ctx)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!a_mont || !a || !ctx) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line"></span><br><span class="line">    <span class="type">bn_t</span> aR2;</span><br><span class="line">    bn_init(&amp;aR2, (ctx-&gt;k_digs)*<span class="number">2</span>);</span><br><span class="line">    bn_set_zero(&amp;aR2);</span><br><span class="line">    <span class="type">bn_err_t</span> err = bn_mul(&amp;aR2, a, &amp;ctx-&gt;R2);</span><br><span class="line">    <span class="keyword">if</span> (err != BN_SUCCESS) {</span><br><span class="line">        bn_free(&amp;aR2);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    }</span><br><span class="line">    err = mont_redc_internal(a_mont, &amp;aR2, &amp;ctx-&gt;N, &amp;ctx-&gt;N_prime, ctx-&gt;k);</span><br><span class="line">    </span><br><span class="line">    bn_free(&amp;aR2);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>使用模约减返回 <span class="math display"><mjx-container class="MathJax" jax="SVG" display="true"><svg style="vertical-align: -0.048ex;" xmlns="http://www.w3.org/2000/svg" width="22.52ex" height="2.047ex" role="img" focusable="false" viewBox="0 -883.9 9953.7 904.9"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D44B" d="M42 0H40Q26 0 26 11Q26 15 29 27Q33 41 36 43T55 46Q141 49 190 98Q200 108 306 224T411 342Q302 620 297 625Q288 636 234 637H206Q200 643 200 645T202 664Q206 677 212 683H226Q260 681 347 681Q380 681 408 681T453 682T473 682Q490 682 490 671Q490 670 488 658Q484 643 481 640T465 637Q434 634 411 620L488 426L541 485Q646 598 646 610Q646 628 622 635Q617 635 609 637Q594 637 594 648Q594 650 596 664Q600 677 606 683H618Q619 683 643 683T697 681T738 680Q828 680 837 683H845Q852 676 852 672Q850 647 840 637H824Q790 636 763 628T722 611T698 593L687 584Q687 585 592 480L505 384Q505 383 536 304T601 142T638 56Q648 47 699 46Q734 46 734 37Q734 35 732 23Q728 7 725 4T711 1Q708 1 678 1T589 2Q528 2 496 2T461 1Q444 1 444 10Q444 11 446 25Q448 35 450 39T455 44T464 46T480 47T506 54Q523 62 523 64Q522 64 476 181L429 299Q241 95 236 84Q232 76 232 72Q232 53 261 47Q262 47 267 47T273 46Q276 46 277 46T280 45T283 42T284 35Q284 26 282 19Q279 6 276 4T261 1Q258 1 243 1T201 2T142 2Q64 2 42 0Z"></path></g><g data-mml-node="mo" transform="translate(1129.8,0)"><path data-c="2261" d="M56 444Q56 457 70 464H707Q722 456 722 444Q722 430 706 424H72Q56 429 56 444ZM56 237T56 250T70 270H707Q722 262 722 250T707 230H70Q56 237 56 250ZM56 56Q56 71 72 76H706Q722 70 722 56Q722 44 707 36H70Q56 43 56 56Z"></path></g><g data-mml-node="mi" transform="translate(2185.6,0)"><path data-c="1D44E" d="M33 157Q33 258 109 349T280 441Q331 441 370 392Q386 422 416 422Q429 422 439 414T449 394Q449 381 412 234T374 68Q374 43 381 35T402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487Q506 153 506 144Q506 138 501 117T481 63T449 13Q436 0 417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157ZM351 328Q351 334 346 350T323 385T277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q217 26 254 59T298 110Q300 114 325 217T351 328Z"></path></g><g data-mml-node="mo" transform="translate(2936.8,0)"><path data-c="22C5" d="M78 250Q78 274 95 292T138 310Q162 310 180 294T199 251Q199 226 182 208T139 190T96 207T78 250Z"></path></g><g data-mml-node="msup" transform="translate(3437,0)"><g data-mml-node="mi"><path data-c="1D445" d="M230 637Q203 637 198 638T193 649Q193 676 204 682Q206 683 378 683Q550 682 564 680Q620 672 658 652T712 606T733 563T739 529Q739 484 710 445T643 385T576 351T538 338L545 333Q612 295 612 223Q612 212 607 162T602 80V71Q602 53 603 43T614 25T640 16Q668 16 686 38T712 85Q717 99 720 102T735 105Q755 105 755 93Q755 75 731 36Q693 -21 641 -21H632Q571 -21 531 4T487 82Q487 109 502 166T517 239Q517 290 474 313Q459 320 449 321T378 323H309L277 193Q244 61 244 59Q244 55 245 54T252 50T269 48T302 46H333Q339 38 339 37T336 19Q332 6 326 0H311Q275 2 180 2Q146 2 117 2T71 2T50 1Q33 1 33 10Q33 12 36 24Q41 43 46 45Q50 46 61 46H67Q94 46 127 49Q141 52 146 61Q149 65 218 339T287 628Q287 635 230 637ZM630 554Q630 586 609 608T523 636Q521 636 500 636T462 637H440Q393 637 386 627Q385 624 352 494T319 361Q319 360 388 360Q466 361 492 367Q556 377 592 426Q608 449 619 486T630 554Z"></path></g><g data-mml-node="TeXAtom" transform="translate(792,413) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mo"><path data-c="2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path></g><g data-mml-node="mn" transform="translate(778,0)"><path data-c="31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path></g></g></g><g data-mml-node="mstyle" transform="translate(5182.7,0)"><g data-mml-node="mspace"></g></g><g data-mml-node="mi" transform="translate(6182.7,0)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g><g data-mml-node="mi" transform="translate(7060.7,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mi" transform="translate(7545.7,0)"><path data-c="1D451" d="M366 683Q367 683 438 688T511 694Q523 694 523 686Q523 679 450 384T375 83T374 68Q374 26 402 26Q411 27 422 35Q443 55 463 131Q469 151 473 152Q475 153 483 153H487H491Q506 153 506 145Q506 140 503 129Q490 79 473 48T445 8T417 -8Q409 -10 393 -10Q359 -10 336 5T306 36L300 51Q299 52 296 50Q294 48 292 46Q233 -10 172 -10Q117 -10 75 30T33 157Q33 205 53 255T101 341Q148 398 195 420T280 442Q336 442 364 400Q369 394 369 396Q370 400 396 505T424 616Q424 629 417 632T378 637H357Q351 643 351 645T353 664Q358 683 366 683ZM352 326Q329 405 277 405Q242 405 210 374T160 293Q131 214 119 129Q119 126 119 118T118 106Q118 61 136 44T179 26Q233 26 290 98L298 109L352 326Z"></path></g><g data-mml-node="mstyle" transform="translate(8065.7,0)"><g data-mml-node="mspace"></g></g><g data-mml-node="mi" transform="translate(9065.7,0)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mspace" transform="translate(9953.7,0)"></g></g></g></svg></mjx-container></span> 调用原来的上下文就可以避免重复计算</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">mont_reduce</span><span class="params">(<span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *a_mont, <span class="type">const</span> <span class="type">mont_ctx_t</span> *ctx)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!a || !a_mont || !ctx) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    <span class="keyword">return</span> mont_redc_internal(a, a_mont, &amp;ctx-&gt;N, &amp;ctx-&gt;N_prime, ctx-&gt;k);</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>调用的函数是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">mont_redc_internal</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *T, <span class="type">const</span> <span class="type">bn_t</span> *N, <span class="type">const</span> <span class="type">bn_t</span> *N_prime, <span class="type">int</span> k)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!r || !T || !N || !N_prime) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> k_digs = (k + WBITS - <span class="number">1</span>) / WBITS;</span><br><span class="line">    <span class="type">bn_err_t</span> err;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bn_t</span> temp_T,temp, R;</span><br><span class="line">    <span class="type">int</span> T_capacity=T-&gt;capacity;</span><br><span class="line">    <span class="type">int</span> N_capacity=N-&gt;capacity;</span><br><span class="line">    <span class="type">int</span> max = (T_capacity&gt;=N_capacity)?T_capacity:N_capacity;</span><br><span class="line">    bn_init(&amp;temp_T, max*<span class="number">2</span>);</span><br><span class="line">    bn_init(&amp;temp, max*<span class="number">2</span>);</span><br><span class="line">    bn_init(&amp;R, max*<span class="number">2</span>);</span><br><span class="line">    bn_set_zero(&amp;temp_T);</span><br><span class="line">    bn_set_zero(&amp;temp);</span><br><span class="line">    bn_set_zero(&amp;R);</span><br><span class="line">    bn_set_bit(&amp;R,k,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    err = bn_copy(&amp;temp_T, T);</span><br><span class="line">    <span class="keyword">if</span> (err) {</span><br><span class="line">        bn_free(&amp;temp_T);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    bn_mul(&amp;temp, N_prime, &amp;temp_T);</span><br><span class="line">    bn_truncate_bits(&amp;temp,k);</span><br><span class="line">    <span class="keyword">while</span>(bn_cmp(&amp;temp,&amp;R)&gt;=<span class="number">0</span>){</span><br><span class="line">        bn_sub(&amp;temp,&amp;temp,&amp;R);</span><br><span class="line">    }</span><br><span class="line">    bn_mul(&amp;temp_T, N, &amp;temp);</span><br><span class="line">    bn_add(&amp;temp,&amp;temp_T,T);</span><br><span class="line"></span><br><span class="line">    err = bn_rsh(&amp;temp_T, &amp;temp, k);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (bn_cmp(&amp;temp_T, N) &gt;= <span class="number">0</span>) {</span><br><span class="line">        err = bn_sub(r, &amp;temp_T, N);</span><br><span class="line">    }<span class="keyword">else</span>{</span><br><span class="line">        bn_copy(r,&amp;temp_T);</span><br><span class="line">    }</span><br><span class="line">    bn_free(&amp;temp_T);</span><br><span class="line">    bn_free(&amp;temp);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>由于我们是按位截取的，所以循环减开销时间比较短，比起<code>bn_mod</code>速度快不少</p>
<p>然后就是我们的模乘和模幂的具体代码，都是经典算法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_mod_mul_mont</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *b, <span class="type">const</span> <span class="type">bn_t</span> *m)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!r || !a || !b || !m) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    <span class="keyword">if</span> (bn_is_zero(m)) <span class="keyword">return</span> BN_ERR_INVALID_PARAM;</span><br><span class="line">    <span class="keyword">if</span> (bn_is_even(m)) <span class="keyword">return</span> BN_ERR_MODULUS_EVEN;</span><br><span class="line"></span><br><span class="line">    <span class="type">mont_ctx_t</span> ctx;</span><br><span class="line">    <span class="type">bn_err_t</span> err = mont_ctx_init(&amp;ctx, m);</span><br><span class="line">    <span class="keyword">if</span> (err != BN_SUCCESS) <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="type">bn_t</span> a_mont, b_mont;</span><br><span class="line">    bn_init(&amp;a_mont, (&amp;ctx)-&gt;k_digs);</span><br><span class="line">    bn_init(&amp;b_mont, (&amp;ctx)-&gt;k_digs);</span><br><span class="line"></span><br><span class="line">    err = mont_map(&amp;a_mont, a, &amp;ctx);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">    err = mont_map(&amp;b_mont, b, &amp;ctx);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">    <span class="type">bn_t</span> result_mont;</span><br><span class="line">    bn_init(&amp;result_mont, <span class="number">0</span>);</span><br><span class="line">    err = mont_mul(&amp;result_mont, &amp;a_mont, &amp;b_mont, &amp;ctx);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> cleanup2;</span><br><span class="line">    </span><br><span class="line">    err = mont_reduce(r, &amp;result_mont, &amp;ctx);</span><br><span class="line">    </span><br><span class="line">cleanup2:</span><br><span class="line">    bn_free(&amp;result_mont);</span><br><span class="line">cleanup:</span><br><span class="line">    bn_free(&amp;a_mont);</span><br><span class="line">    bn_free(&amp;b_mont);</span><br><span class="line">    mont_ctx_free(&amp;ctx);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">mont_mul</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *b, <span class="type">const</span> <span class="type">mont_ctx_t</span> *ctx)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!r || !a || !b || !ctx) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line"></span><br><span class="line">    <span class="type">bn_t</span> T;</span><br><span class="line">    bn_init(&amp;T, <span class="number">0</span>);</span><br><span class="line">    <span class="type">bn_err_t</span> err = bn_mul(&amp;T, a, b);</span><br><span class="line">    <span class="keyword">if</span> (err != BN_SUCCESS) {</span><br><span class="line">        bn_free(&amp;T);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    err = mont_redc_internal(r, &amp;T, &amp;ctx-&gt;N, &amp;ctx-&gt;N_prime, ctx-&gt;k);</span><br><span class="line"></span><br><span class="line">    bn_free(&amp;T);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>模幂算法也是</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">bn_err_t</span> <span class="title function_">bn_mod_exp_mont</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *e, <span class="type">const</span> <span class="type">bn_t</span> *m)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!r || !a || !e || !m) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line">    <span class="keyword">if</span> (bn_is_zero(m)) <span class="keyword">return</span> BN_ERR_INVALID_PARAM;</span><br><span class="line">    <span class="keyword">if</span> (bn_is_even(m)) <span class="keyword">return</span> BN_ERR_MODULUS_EVEN;</span><br><span class="line"></span><br><span class="line">    <span class="type">mont_ctx_t</span> ctx;</span><br><span class="line">    <span class="type">bn_err_t</span> err = mont_ctx_init(&amp;ctx, m);</span><br><span class="line">    <span class="keyword">if</span> (err != BN_SUCCESS) <span class="keyword">return</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="type">bn_t</span> a_mont;</span><br><span class="line">    bn_init(&amp;a_mont, <span class="number">0</span>);</span><br><span class="line">    err = mont_map(&amp;a_mont, a, &amp;ctx);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">    err = mont_exp(r, &amp;a_mont, e, &amp;ctx);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> cleanup2;</span><br><span class="line">    </span><br><span class="line">    err = mont_reduce(&amp;a_mont, r, &amp;ctx);</span><br><span class="line">    <span class="keyword">if</span> (err == BN_SUCCESS) {</span><br><span class="line">        bn_copy(r, &amp;a_mont);</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">cleanup2:</span><br><span class="line">    bn_free(&amp;a_mont);</span><br><span class="line">cleanup:</span><br><span class="line">    mont_ctx_free(&amp;ctx);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="type">bn_err_t</span> <span class="title function_">mont_exp</span><span class="params">(<span class="type">bn_t</span> *r, <span class="type">const</span> <span class="type">bn_t</span> *a, <span class="type">const</span> <span class="type">bn_t</span> *e, <span class="type">const</span> <span class="type">mont_ctx_t</span> *ctx)</span> {</span><br><span class="line">    <span class="keyword">if</span> (!r || !a || !e || !ctx) <span class="keyword">return</span> BN_ERR_NULL_PTR;</span><br><span class="line"></span><br><span class="line">    <span class="type">bn_t</span> result, base;</span><br><span class="line">    bn_init(&amp;result, <span class="number">0</span>);</span><br><span class="line">    bn_init(&amp;base, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">bn_err_t</span> err = bn_copy(&amp;base, a);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> cleanup;</span><br><span class="line"></span><br><span class="line">    <span class="type">bn_t</span> one;</span><br><span class="line">    bn_init(&amp;one, <span class="number">0</span>);</span><br><span class="line">    bn_set_one(&amp;one);</span><br><span class="line">    err = mont_map(&amp;result, &amp;one, ctx);</span><br><span class="line">    bn_free(&amp;one);</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">goto</span> cleanup;</span><br><span class="line">    <span class="type">bn_t</span> temp;</span><br><span class="line">    bn_init(&amp;temp, <span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> bits = bn_get_bits(e);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = bits - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</span><br><span class="line">        err = mont_sqr(&amp;temp, &amp;result, ctx);</span><br><span class="line">        <span class="keyword">if</span> (err) {</span><br><span class="line">            bn_free(&amp;temp);</span><br><span class="line">            <span class="keyword">goto</span> cleanup;</span><br><span class="line">        }</span><br><span class="line">        bn_copy(&amp;result, &amp;temp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bn_get_bit(e, i)) {</span><br><span class="line">            err = mont_mul(&amp;temp, &amp;result, &amp;base, ctx);</span><br><span class="line">            <span class="keyword">if</span> (err) {</span><br><span class="line">                bn_free(&amp;temp);</span><br><span class="line">                <span class="keyword">goto</span> cleanup;</span><br><span class="line">            }</span><br><span class="line">            bn_copy(&amp;result, &amp;temp);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    err = bn_copy(r, &amp;result);</span><br><span class="line">    </span><br><span class="line">cleanup:</span><br><span class="line">    bn_free(&amp;temp);</span><br><span class="line">    bn_free(&amp;result);</span><br><span class="line">    bn_free(&amp;base);</span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">}</span><br></pre></td></tr></table></figure>
<p>这就是我的代码啦</p>
<p>经过测试，速度如下，每一项都是随机的数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">+------------------------------------------------------------------------------+</span><br><span class="line">+---    Bench module  ---&gt;  bn</span><br><span class="line">BENCH: bn_set_zero                      =    0.0024 us</span><br><span class="line">BENCH: bn_rand                          =    0.0864 us</span><br><span class="line">BENCH: bn_rand_security                 =    0.0656 us</span><br><span class="line">BENCH: bn_copy                          =    0.0063 us</span><br><span class="line">BENCH: bn_get_bits                      =    0.0017 us</span><br><span class="line">BENCH: bn_get_bit                       =    0.0021 us</span><br><span class="line">BENCH: bn_set_bit                       =    0.0065 us</span><br><span class="line">BENCH: bn_truncate                      =    0.0013 us</span><br><span class="line">BENCH: bn_truncate_bits                 =    0.0009 us</span><br><span class="line">BENCH: bn_add                           =    0.0085 us</span><br><span class="line">BENCH: bn_add_dig                       =    0.0056 us</span><br><span class="line">BENCH: bn_sub                           =    0.0096 us</span><br><span class="line">BENCH: bn_sub_dig                       =    0.0055 us</span><br><span class="line">BENCH: bn_mul                           =    0.0423 us</span><br><span class="line">BENCH: bn_sqr                           =    0.0420 us</span><br><span class="line">BENCH: bn_div                           =    0.0080 us</span><br><span class="line">BENCH: bn_mod                           =    0.1465 us</span><br><span class="line">BENCH: bn_cmp                           =    0.0014 us</span><br><span class="line">BENCH: bn_lsh                           =    0.0072 us</span><br><span class="line">BENCH: bn_rsh                           =    0.0029 us</span><br><span class="line">BENCH: bn_mod_add                       =    0.1829 us</span><br><span class="line">BENCH: bn_mod_sub                       =    0.1042 us</span><br><span class="line">BENCH: bn_mod_hlv                       =    0.0898 us</span><br><span class="line">BENCH: mont_compute_R                   =    0.1209 us</span><br><span class="line">BENCH: mod_inv                          =  139.5866 us</span><br><span class="line">BENCH: mod_inv_useNewton                =    1.7169 us</span><br><span class="line">BENCH: mont_compute_N_prime             =    2.4169 us</span><br><span class="line">BENCH: mont_ctx_init                    =   13.0413 us</span><br><span class="line">BENCH: bn_mod_rdc                       =    0.1674 us</span><br><span class="line">BENCH: bn_mod_mul                       =   14.3162 us</span><br><span class="line">BENCH: bn_mod_exp                       =  142.5800 us</span><br><span class="line">+------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>
<p>感觉还是有点慢了，可以优化的地方还可以多一些，不过这里就告一段落了</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://LightCloveyou.github.io">LightCloveyou</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://lightcloveyou.github.io/2025/12/21/%E6%B5%85%E8%B0%88C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A4%A7%E6%95%B4%E6%95%B0%E5%BA%93%E5%AE%9E%E7%8E%B0/">https://lightcloveyou.github.io/2025/12/21/%E6%B5%85%E8%B0%88C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A4%A7%E6%95%B4%E6%95%B0%E5%BA%93%E5%AE%9E%E7%8E%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://LightCloveyou.github.io" target="_blank">LightCloveyou's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Programming-Language/">Programming Language</a></div><div class="post-share"><div class="social-share" data-image="/img/47.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/12/12/StackSkill/" title="StackSkill"><img class="cover" src="/img/39.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">StackSkill</div></div><div class="info-2"><div class="info-item-1">知不足而奋进，望远山而前行</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related no-desc" href="/2025/11/28/Assembly/" title="Assembly"><img class="cover" src="/img/20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-28</div><div class="info-item-2">Assembly</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">LightCloveyou</div><div class="author-info-description">PWN your Heart</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">11</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/LightCloveyou/LightCloveyou.github.io"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BD%93%E7%B3%BB%E5%8F%8A%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.</span> <span class="toc-text">函数体系及实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">内存管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.</span> <span class="toc-text">工具函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%BF%90%E7%AE%97"><span class="toc-number">2.3.</span> <span class="toc-text">基础运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E8%BF%90%E7%AE%97"><span class="toc-number">2.4.</span> <span class="toc-text">模运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6%E6%A8%A1%E8%BF%90%E7%AE%97"><span class="toc-number">2.5.</span> <span class="toc-text">进阶模运算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%92%99%E5%93%A5%E9%A9%AC%E5%88%A9%E7%AE%97%E6%B3%95"><span class="toc-number">2.5.1.</span> <span class="toc-text">蒙哥马利算法</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/12/21/%E6%B5%85%E8%B0%88C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A4%A7%E6%95%B4%E6%95%B0%E5%BA%93%E5%AE%9E%E7%8E%B0/" title="浅谈C语言的大整数库实现"><img src="/img/47.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="浅谈C语言的大整数库实现"/></a><div class="content"><a class="title" href="/2025/12/21/%E6%B5%85%E8%B0%88C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%A4%A7%E6%95%B4%E6%95%B0%E5%BA%93%E5%AE%9E%E7%8E%B0/" title="浅谈C语言的大整数库实现">浅谈C语言的大整数库实现</a><time datetime="2025-12-21T12:21:07.000Z" title="发表于 2025-12-21 20:21:07">2025-12-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/12/StackSkill/" title="StackSkill"><img src="/img/39.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="StackSkill"/></a><div class="content"><a class="title" href="/2025/12/12/StackSkill/" title="StackSkill">StackSkill</a><time datetime="2025-12-12T08:02:02.000Z" title="发表于 2025-12-12 16:02:02">2025-12-12</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/08/kernel/" title="kernel"><img src="/img/44.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="kernel"/></a><div class="content"><a class="title" href="/2025/12/08/kernel/" title="kernel">kernel</a><time datetime="2025-12-08T08:49:01.000Z" title="发表于 2025-12-08 16:49:01">2025-12-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/07/ISCTF2025/" title="ISCTF2025"><img src="/img/33.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ISCTF2025"/></a><div class="content"><a class="title" href="/2025/12/07/ISCTF2025/" title="ISCTF2025">ISCTF2025</a><time datetime="2025-12-06T16:26:57.000Z" title="发表于 2025-12-07 00:26:57">2025-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/28/Assembly/" title="Assembly"><img src="/img/20.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Assembly"/></a><div class="content"><a class="title" href="/2025/11/28/Assembly/" title="Assembly">Assembly</a><time datetime="2025-11-28T03:45:14.000Z" title="发表于 2025-11-28 11:45:14">2025-11-28</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/13.jpg);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By LightCloveyou</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.0.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js">
</script></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@6.1.4/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"></div><meting-js class="no-destroy" id="8932390" server="netease" type="playlist" fixed="true" autoplay="false" order="random" volume="0.3" list-folded="false" list-max-height="36vh"> </meting-js><link rel="stylesheet" href="https://npm.elemecdn.com/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://npm.elemecdn.com/aplayer/dist/APlayer.min.js"></script><script src="https://npm.elemecdn.com/meting/dist/Meting.min.js"></script><script>(() => {
  const destroyAplayer = () => {
    if (window.aplayers) {
      for (let i = 0; i < window.aplayers.length; i++) {
        if (!window.aplayers[i].options.fixed) {
          window.aplayers[i].destroy()
        }
      }
    }
  }

  const runMetingJS = () => {
    typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()
  }

  btf.addGlobalFn('pjaxSend', destroyAplayer, 'destroyAplayer')
  btf.addGlobalFn('pjaxComplete', loadMeting, 'runMetingJS')
})()</script><script src="https://cdn.bootcdn.net/ajax/libs/jquery.pjax/2.0.1/jquery.pjax.min.js"></script><script>(() => {
  const pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

  window.pjax = new Pjax({
    elements: 'a:not([target="_blank"])',
    selectors: pjaxSelectors,
    cacheBust: false,
    analytics: false,
    scrollRestoration: false
  })

  const triggerPjaxFn = (val) => {
    if (!val) return
    Object.values(val).forEach(fn => {
      try {
        fn()
      } catch (err) {
        console.debug('Pjax callback failed:', err)
      }
    })
  }

  document.addEventListener('pjax:send', () => {
    // removeEventListener
    btf.removeGlobalFnEvent('pjaxSendOnce')
    btf.removeGlobalFnEvent('themeChange')

    // reset readmode
    const $bodyClassList = document.body.classList
    if ($bodyClassList.contains('read-mode')) $bodyClassList.remove('read-mode')

    triggerPjaxFn(window.globalFn.pjaxSend)
  })

  document.addEventListener('pjax:complete', () => {
    btf.removeGlobalFnEvent('pjaxCompleteOnce')
    document.querySelectorAll('script[data-pjax]').forEach(item => {
      const newScript = document.createElement('script')
      const content = item.text || item.textContent || item.innerHTML || ""
      Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
      newScript.appendChild(document.createTextNode(content))
      item.parentNode.replaceChild(newScript, item)
    })

    triggerPjaxFn(window.globalFn.pjaxComplete)
  })

  document.addEventListener('pjax:error', e => {
    if (e.request.status === 404) {
      const usePjax = true
      false
        ? (usePjax ? pjax.loadUrl('/404.html') : window.location.href = '/404.html')
        : window.location.href = e.request.responseURL
    }
  })
})()</script><script async data-pjax src="/"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索文章" type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js?v=5.5.2"></script></div></div></body></html>